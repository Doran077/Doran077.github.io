<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>webstorm之解决目前阶段翻译插件Translation谷歌翻译的问题</title>
    <url>/webstorm/webstorm/1-webstorm%E4%B9%8B%E7%BF%BB%E8%AF%91%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>从上个月起IDEA翻译插件Translation的谷歌翻译不能使用了，今天特地的写下这篇文章，本篇文章内容大部分来自网络上一些大牛给的建议，并且亲测有效。</p>
<h3 id="1-复活谷歌翻译"><a href="#1-复活谷歌翻译" class="headerlink" title="1.复活谷歌翻译"></a>1.复活谷歌翻译</h3><p>Google翻译API突然不能用，其原因是Google重定向了中国的Google翻译网页版，直接把API也重定向了，所以我们通过修改hosts文件来实现谷歌翻译复活。</p>
<p>因为需要修改hosts文件所以我把相关操作系统的文件路径给大家：</p>
<p>Windows：C:\Windows\System32\drivers\etc\hosts<br>Mac：/etc/hosts<br>Linux：/etc/hosts<br>Android：/system/etc/hosts<br>iOS：/etc/hosts</p>
<a id="more"></a>

<p>因为谷歌在国内有很多服务器，所有我们只需要要找到离自己最近的谷歌服务器IP，可以通过ping的方法，寻找到国内的谷歌IP地址。</p>
<p>可以直接通过 <strong>ping google.cn -t</strong> 命令来获取。</p>
<p>也可以通过 <a href="https://ping.chinaz.com/translate.google.cn">https://ping.chinaz.com/translate.google.cn</a> 这个网址来查看相关的最近谷歌IP地址。</p>
<p>接下来就可以修改hosts文件了。</p>
<p>因为很多电脑的hosts文件都是“只读”，因此我们需要先修改 hosts 文件的属性，然后把“只读”去掉勾即可。</p>
<p>接下来可以用记事本打开 hosts 文件并且在最后一行添加获取到的： </p>
<p>谷歌ip地址+空格+translate.googleapis.com</p>
<p>例如我获取到的谷歌IP地址是：220.181.174.98</p>
<p>在hosts文件末尾添加 220.181.174.98 translate.googleapis.com</p>
<p>保存后再用谷歌即可正常翻译了</p>
<h3 id="2-使用其它翻译–例如：有道翻译"><a href="#2-使用其它翻译–例如：有道翻译" class="headerlink" title="2.使用其它翻译–例如：有道翻译"></a>2.使用其它翻译–例如：有道翻译</h3><p>首先使用有道翻译前我们需要获取到有道翻译的应用id和密钥</p>
<p>没有的我们需要注册一个有道翻译的账号</p>
<p><a href="https://imgse.com/i/zC9HN8"><img src="https://s1.ax1x.com/2022/11/11/zC9HN8.png" alt="zC9HN8.png"></a></p>
<p>注册好账号之后在应用总览里创建一个应用</p>
<p><a href="https://imgse.com/i/zC9b4S"><img src="https://s1.ax1x.com/2022/11/11/zC9b4S.png" alt="zC9b4S.png"></a></p>
<p> 创建好应用之后就能够在应用总览里看到自己的应用ID和密钥</p>
<p>填写到IDEA的翻译插件里就能够使用了</p>
]]></content>
      <categories>
        <category>webstorm</category>
      </categories>
      <tags>
        <tag>webstorm</tag>
        <tag>Translation翻译插件</tag>
      </tags>
  </entry>
  <entry>
    <title>webstorm之好用的插件1</title>
    <url>/webstorm/webstorm/2-webstorm%E4%B9%8B%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B6%20/</url>
    <content><![CDATA[<h2 id="webstorm必装插件"><a href="#webstorm必装插件" class="headerlink" title="webstorm必装插件"></a>webstorm必装插件</h2><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p> 作为一个FE开发者，在日常工作中用的最多的可能就是WebStorm与VsCode，我在工作的这几年一直使用的是WebStorm进行开发，今天为大家带来我工作中使用的一些Webstorm插件以及一些可以提效的配置方法，希望能够帮助使用WebStorm的朋友们更加高效工作，多余时间可以多摸摸🐟！</p>
<h2 id="最终效果展示"><a href="#最终效果展示" class="headerlink" title="最终效果展示"></a>最终效果展示</h2><p><a href="https://imgse.com/i/zCaIr4"><img src="https://s1.ax1x.com/2022/11/11/zCaIr4.png" alt="zCaIr4.png"></a></p>
<h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><blockquote>
<p> 下面会详细介绍每一个插件的安装、使用建议，推荐指数✨ </p>
</blockquote>
<h3 id="ignore-版本管理工具的忽略文件插件"><a href="#ignore-版本管理工具的忽略文件插件" class="headerlink" title=".ignore: 版本管理工具的忽略文件插件"></a><strong>.ignore</strong>: 版本管理工具的忽略文件插件</h3><ul>
<li>插件描述：支持创建多种.ignore文件，会默认设置到需要忽略的文件或文件夹，我常用的是.gitignore，用于常见前端常见的需要忽略提交的文件，如node_modules，dist等；支持将文件旋选中右键进行添加到.gitignore；</li>
<li>安装方式：webstorm内部插件市场搜索<code>.ignore</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/7495--ignore">https://plugins.jetbrains.com/plugin/7495–ignore</a></li>
<li>使用效果：个人感觉很实用，会非常方便，有时候如果已经将文件添加到git提交缓存中的时候，需要使用命令清除缓存把文件撤销出来，这个插件可以帮助你完成这一步。更多功能需要自己使用进行发掘</li>
<li>推荐指数：🌟🌟🌟🌟🌟 </li>
</ul>
<h3 id="Power-Mode-II-打字特效"><a href="#Power-Mode-II-打字特效" class="headerlink" title="Power Mode II: 打字特效"></a><strong>Power Mode II</strong>: 打字特效</h3><ul>
<li>插件描述：炫酷的打字效果，除了炫酷，没任何卵用，屏幕抖动的看着难受；</li>
<li>安装方式：webstorm内部插件市场搜索<code>Power Mode II</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/8251-power-mode-ii">https://plugins.jetbrains.com/plugin/8251-power-mode-ii</a></li>
<li>使用效果：装13可以，效果不大</li>
<li>推荐指数：🌟🌟 </li>
</ul>
<h3 id="activate-power-mode-打字特效"><a href="#activate-power-mode-打字特效" class="headerlink" title="activate-power-mode: 打字特效"></a><strong>activate-power-mode</strong>: 打字特效</h3><ul>
<li>插件描述：与Power Mode II类似，效果更爆炸</li>
<li>安装方式：webstorm内部插件市场搜索<code>activate-power-mode</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/8330-activate-power-mode">https://plugins.jetbrains.com/plugin/8330-activate-power-mode</a></li>
<li>使用效果：头晕式摸鱼</li>
<li>推荐指数：🌟🌟 </li>
</ul>
<h3 id="CodeSearch-右键搜索-通过Google搜索-墙内不能用"><a href="#CodeSearch-右键搜索-通过Google搜索-墙内不能用" class="headerlink" title="CodeSearch: 右键搜索(通过Google搜索,墙内不能用)"></a><strong>CodeSearch</strong>: 右键搜索(通过Google搜索,墙内不能用)</h3><ul>
<li>插件描述：选中某段内容，可以直接右键通过搜索引擎搜索进行搜索；需要配置搜索引擎，可以配置Baidu, Google, StackOverflow and GitHub四种</li>
<li>安装方式：webstorm内部插件市场搜索<code>codeSearch</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/12578-codesearch">https://plugins.jetbrains.com/plugin/12578-codesearch</a></li>
<li>使用效果：实用性挺高，很方便的帮助搜索，安装以后就可以选中要搜索的东西</li>
<li>推荐指数：🌟🌟🌟🌟🌟 </li>
</ul>
<p><a href="https://imgse.com/i/zCaWGV"><img src="https://s1.ax1x.com/2022/11/11/zCaWGV.png" alt="zCaWGV.png"></a></p>
<p><a href="https://imgse.com/i/zCaf2T"><img src="https://s1.ax1x.com/2022/11/11/zCaf2T.png" alt="zCaf2T.png"></a></p>
<h3 id="Rainbow-Brackets-括号换色提示插件"><a href="#Rainbow-Brackets-括号换色提示插件" class="headerlink" title="Rainbow Brackets: 括号换色提示插件"></a><strong>Rainbow Brackets</strong>: 括号换色提示插件</h3><ul>
<li>插件描述：代码中如果嵌套较深的话，找前面的括号与后面对应的地方会很麻烦，这款插件使用不同颜色进行标记，可以很方便的找到对应的开始和结尾的括号</li>
<li>安装方式：webstorm内部插件市场搜索<code>.ignore</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/10080-rainbow-brackets">https://plugins.jetbrains.com/plugin/10080-rainbow-brackets</a></li>
<li>使用效果：个人感觉比较方便，可以快速定位，并且代码界面也会看起来更好看一点，愉悦心情，开心coding；</li>
<li>推荐指数：🌟🌟🌟🌟 </li>
</ul>
<p><a href="https://imgse.com/i/zCag5q"><img src="https://s1.ax1x.com/2022/11/11/zCag5q.png" alt="zCag5q.png"></a></p>
<h3 id="Translation-翻译插件"><a href="#Translation-翻译插件" class="headerlink" title="Translation: 翻译插件"></a><strong>Translation</strong>: 翻译插件</h3><ul>
<li>插件描述：翻译插件，可以便捷的在WebStorm中进行翻译，省去了去浏览器进行翻译的操作，也支持右键方式选中翻译</li>
<li>安装方式：webstorm内部插件市场搜索<code>Translation</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/8579-translation">https://plugins.jetbrains.com/plugin/8579-translation</a></li>
<li>使用效果：翻译更便捷啦，但是还是要多动脑子想一想呀</li>
<li>推荐指数：🌟🌟🌟🌟 </li>
</ul>
<p><a href="https://imgse.com/i/zCaRP0"><img src="https://s1.ax1x.com/2022/11/11/zCaRP0.png" alt="zCaRP0.png"></a></p>
<p><a href="https://imgse.com/i/zCaoqJ"><img src="https://s1.ax1x.com/2022/11/11/zCaoqJ.png" alt="zCaoqJ.png"></a></p>
<h3 id="AceJump-光标快速定位"><a href="#AceJump-光标快速定位" class="headerlink" title="AceJump: 光标快速定位"></a><strong>AceJump</strong>: 光标快速定位</h3><ul>
<li>插件描述：AceJump 允许您将插入符号快速导航到编辑器中可见的任何位置，使用方式快捷键：Ctrl+;</li>
<li>安装方式：webstorm内部插件市场搜索<code>AceJump</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/7086-acejump">https://plugins.jetbrains.com/plugin/7086-acejump</a></li>
<li>使用效果：用的不是很多，得使用快捷键，也不是很方便，马马虎虎吧，看个人喜好</li>
<li>推荐指数：🌟🌟 </li>
</ul>
<p><a href="https://imgse.com/i/zCahxU"><img src="https://s1.ax1x.com/2022/11/11/zCahxU.png" alt="zCahxU.png"></a></p>
]]></content>
      <categories>
        <category>webstorm</category>
      </categories>
      <tags>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title>webstorm之好用的插件2</title>
    <url>/webstorm/webstorm/3-webstorm%E4%B9%8B%E5%A5%BD%E7%94%A8%E7%9A%84%E6%8F%92%E4%BB%B62/</url>
    <content><![CDATA[<h2 id="webstorm必装插件"><a href="#webstorm必装插件" class="headerlink" title="webstorm必装插件"></a>webstorm必装插件</h2><h2 id="插件推荐"><a href="#插件推荐" class="headerlink" title="插件推荐"></a>插件推荐</h2><blockquote>
<p> 下面会详细介绍每一个插件的安装、使用建议，推荐指数✨ </p>
</blockquote>
<h3 id="Material-Theme-UI-设置主题，不好的是大部分是暗色主题，亮色的特别亮，但是支持的文件图标不错"><a href="#Material-Theme-UI-设置主题，不好的是大部分是暗色主题，亮色的特别亮，但是支持的文件图标不错" class="headerlink" title="Material Theme UI: 设置主题，不好的是大部分是暗色主题，亮色的特别亮，但是支持的文件图标不错"></a><strong>Material Theme UI</strong>: 设置主题，不好的是大部分是暗色主题，亮色的特别亮，但是支持的文件图标不错</h3><ul>
<li>插件描述：众所周知，一款很出名的主题</li>
<li>安装方式：webstorm内部插件市场搜索<code>Material Theme UI</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/8006-material-theme-ui">https://plugins.jetbrains.com/plugin/8006-material-theme-ui</a></li>
<li>使用效果：根据个人喜好吧，自己喜欢的才是最好的</li>
<li>推荐指数：🌟🌟🌟🌟 </li>
</ul>
<p><a href="https://imgse.com/i/zCa5MF"><img src="https://s1.ax1x.com/2022/11/11/zCa5MF.png" alt="zCa5MF.png"></a></p>
<h3 id="CodeGlance-右侧小地图导航，像sublime-text中一样的那个，可以配置宽度"><a href="#CodeGlance-右侧小地图导航，像sublime-text中一样的那个，可以配置宽度" class="headerlink" title="CodeGlance: 右侧小地图导航，像sublime text中一样的那个，可以配置宽度"></a><strong>CodeGlance</strong>: 右侧小地图导航，像sublime text中一样的那个，可以配置宽度</h3><ul>
<li>插件描述：可以在打开的窗口右边显示小地图，用于快速定位跳转，尤其是针对很多行的文件，就很方便的；</li>
<li>安装方式：webstorm内部插件市场搜索<code>CodeGlance</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/7275-codeglance">https://plugins.jetbrains.com/plugin/7275-codeglance</a></li>
<li>使用效果：可以配置小地图宽度，可以设置固定宽，也可以拖拉设置宽度</li>
<li>推荐指数：🌟🌟🌟🌟🌟 </li>
</ul>
<p><a href="https://imgse.com/i/zCaHaR"><img src="https://s1.ax1x.com/2022/11/11/zCaHaR.png" alt="zCaHaR.png"></a></p>
<h3 id="Codota-AI代码生成，自动联想，支持javaScript和java；"><a href="#Codota-AI代码生成，自动联想，支持javaScript和java；" class="headerlink" title="Codota: AI代码生成，自动联想，支持javaScript和java；"></a><strong>Codota</strong>: AI代码生成，自动联想，支持javaScript和java；</h3><ul>
<li>插件描述：代码联想，不用过多解释了</li>
<li>安装方式：webstorm内部插件市场搜索<code>Codota</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/7638-codota-ai-autocomplete-for-java-and-javascript">https://plugins.jetbrains.com/plugin/7638-codota-ai-autocomplete-for-java-and-javascript</a></li>
<li>使用效果：我用的觉得还行，它可以快捷显示之前输入过的内容，或者快捷生成函数等，可以提升写代码的速度</li>
<li>推荐指数：🌟🌟🌟🌟🌟 </li>
</ul>
<h3 id="Atom-Material-Icons-文件图标、系统图标会更好看；"><a href="#Atom-Material-Icons-文件图标、系统图标会更好看；" class="headerlink" title="Atom Material Icons: 文件图标、系统图标会更好看；"></a><strong>Atom Material Icons</strong>: 文件图标、系统图标会更好看；</h3><ul>
<li>插件描述：为文件夹、文件增加图标，让编译器看起来更美观，也是一款可以愉快coding的好用插件</li>
<li>安装方式：webstorm内部插件市场搜索<code>Atom Material Icons</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/10044-atom-material-icons">https://plugins.jetbrains.com/plugin/10044-atom-material-icons</a></li>
<li>使用效果：针不戳啊针不戳</li>
<li>推荐指数：🌟🌟🌟🌟🌟 </li>
</ul>
<p><a href="https://imgse.com/i/zCa7Z9"><img src="https://s1.ax1x.com/2022/11/11/zCa7Z9.png" alt="zCa7Z9.png"></a></p>
<h3 id="GitToolBox-git提交记录插件，鼠标在某行代码的时候可以看见是谁在什么时候提交的，提交信息是什么；"><a href="#GitToolBox-git提交记录插件，鼠标在某行代码的时候可以看见是谁在什么时候提交的，提交信息是什么；" class="headerlink" title="GitToolBox: git提交记录插件，鼠标在某行代码的时候可以看见是谁在什么时候提交的，提交信息是什么；"></a><strong>GitToolBox</strong>: git提交记录插件，鼠标在某行代码的时候可以看见是谁在什么时候提交的，提交信息是什么；</h3><ul>
<li>插件描述：没记错的话VsCode里面也有一款类似的插件，可以看见每行代码是谁、在什么时候提交的，提交message是什么，不用再使用Annote with Git Blame了</li>
<li>安装方式：webstorm内部插件市场搜索<code>GitToolBox</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/7499-gittoolbox">https://plugins.jetbrains.com/plugin/7499-gittoolbox</a></li>
<li>使用效果：方便啊方便，非常方便的！！一看有bug，就知道是谁写的这垃圾代码了！</li>
<li>推荐指数：🌟🌟🌟🌟🌟 </li>
</ul>
<p><a href="https://imgse.com/i/zCaLPx"><img src="https://s1.ax1x.com/2022/11/11/zCaLPx.png" alt="zCaLPx.png"></a></p>
<h3 id="Paste-images-into-MarkDown-在编写markdown时，如果需要添加图片，则复制以后可直接使用ctrl-v或command-v进行粘贴，会弹出一个弹框设置图片名称、路径，十分方便"><a href="#Paste-images-into-MarkDown-在编写markdown时，如果需要添加图片，则复制以后可直接使用ctrl-v或command-v进行粘贴，会弹出一个弹框设置图片名称、路径，十分方便" class="headerlink" title="Paste images into MarkDown: 在编写markdown时，如果需要添加图片，则复制以后可直接使用ctrl+v或command+v进行粘贴，会弹出一个弹框设置图片名称、路径，十分方便"></a><strong>Paste images into MarkDown</strong>: 在编写markdown时，如果需要添加图片，则复制以后可直接使用ctrl+v或command+v进行粘贴，会弹出一个弹框设置图片名称、路径，十分方便</h3><ul>
<li>插件描述：在WebStorm写markdwon文档的时候，有时候需要增加图片可能要先将图片放到文件夹，再在markdown中引用，那么这个插件可以很好的解决问题，剪贴板上有图片信息，直接ctrl+V进行粘贴</li>
<li>安装方式：webstorm内部插件市场搜索<code>Paste images into MarkDown</code>或官方地址下载到本地进行安装</li>
<li>官方地址：<a href="https://plugins.jetbrains.com/plugin/8446-paste-images-into-markdown">https://plugins.jetbrains.com/plugin/8446-paste-images-into-markdown</a></li>
<li>使用效果：提升效率的利器，还可以设置图片存储路径，是否是圆角、图片大小等</li>
<li>推荐指数：🌟🌟🌟🌟🌟 </li>
</ul>
<p><a href="https://imgse.com/i/zCabI1"><img src="https://s1.ax1x.com/2022/11/11/zCabI1.png" alt="zCabI1.png"></a></p>
<p>好啦，可以写出来的常用的就这些基本插件啦，更多的插件可以去我的博客了解：<a href="https://blog.wangboweb.site/2019/08/17/63952.html">https://blog.wangboweb.site/2019/08/17/63952.html</a></p>
<h2 id="设置一下"><a href="#设置一下" class="headerlink" title="设置一下"></a>设置一下</h2><h3 id="字体以及UI、展示风格"><a href="#字体以及UI、展示风格" class="headerlink" title="字体以及UI、展示风格"></a>字体以及UI、展示风格</h3><p><a href="https://imgse.com/i/zCaOG6"><img src="https://s1.ax1x.com/2022/11/11/zCaOG6.png" alt="zCaOG6.png"></a></p>
<h3 id="文件模板设置"><a href="#文件模板设置" class="headerlink" title="文件模板设置"></a>文件模板设置</h3><p>详情：<a href="https://blog.wangboweb.site/2021/08/04/60426.html">https://blog.wangboweb.site/2021/08/04/60426.html</a> </p>
<p><a href="https://imgse.com/i/zCajxO"><img src="https://s1.ax1x.com/2022/11/11/zCajxO.png" alt="zCajxO.png"></a></p>
<h3 id="配置信息备份"><a href="#配置信息备份" class="headerlink" title="配置信息备份"></a>配置信息备份</h3><p>可以备份到云上，也可以备份到jetbrains 账户上 </p>
<p><a href="https://imgse.com/i/zCdSqH"><img src="https://s1.ax1x.com/2022/11/11/zCdSqH.png" alt="zCdSqH.png"></a></p>
<h3 id="设置背景图片"><a href="#设置背景图片" class="headerlink" title="设置背景图片"></a>设置背景图片</h3><p><a href="https://imgse.com/i/zCazse"><img src="https://s1.ax1x.com/2022/11/11/zCazse.png" alt="zCazse.png"></a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p> 大概就是这么多了，其实很多功能在日常开发中不一定会用到，但是一旦发现了，就会很顺手，需要自己多多探索，打造一个适合自己的编译器，才能真正的提高开发效率！！！</p>
]]></content>
      <categories>
        <category>webstorm</category>
      </categories>
      <tags>
        <tag>webstorm</tag>
      </tags>
  </entry>
  <entry>
    <title>02_Vue的使用</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/02-Vue%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Vue的使用"><a href="#Vue的使用" class="headerlink" title="Vue的使用"></a>Vue的使用</h2><p>在js代码中使用Vue时，先构造一个vue对象的实例。</p>
<p>Vue是个构造函数，该构造函数在创建实例时可向内部传入一个对象作为参数，对象内部可存放的属性有：</p>
<p>el：其值为css选择器，表示该vue实例管理的DOM区域</p>
<a id="more"></a>

<p>data：其值为一个对象或一个函数，内部存储的是该管理DOM区域的数据</p>
<p>methods：其值为一个对象，内部存储函数(事件监听的回调)<br><font color="red"><strong>注意：</strong></font>这些函数中如果使用了this则不能使用箭头函数。</p>
<h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p><a href="https://www.cnblogs.com/caoyi/p/11356500.html">Vue生命周期详解</a></p>
<p>创建前后 挂载前后 更新前后 销毁前后 一共八个生命周期</p>
<p>记住dom渲染完毕，是在mounted</p>
<p><strong>activated和deactivated</strong>这两个回调是<strong>只有在当组件在keep-alive中时（保持了状态）</strong>（否则执行的就是销毁回调了），当组件处于活跃中时调用前者，不活跃时调用后者。</p>
<p><a href="https://imgchr.com/i/s9SqhV"><img src="https://s3.ax1x.com/2021/01/03/s9SqhV.png" alt="s9SqhV.png"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>03_Vue的API</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/03-Vue%E7%9A%84API/</url>
    <content><![CDATA[<h1 id="Vue的基础操作"><a href="#Vue的基础操作" class="headerlink" title="Vue的基础操作"></a>Vue的基础操作</h1><h2 id="插值的操作（Mustache语法）"><a href="#插值的操作（Mustache语法）" class="headerlink" title="插值的操作（Mustache语法）"></a>插值的操作（Mustache语法）</h2><h3 id="将数据显示在标签内容中"><a href="#将数据显示在标签内容中" class="headerlink" title="将数据显示在标签内容中"></a>将数据显示在标签内容中</h3><p>v-once数据不会变化</p>
<p>v-for=“item in movies”（item为双大括号的绑定数据movies为vue中的数组,表示item会循环遍历该数组呈现该数组中的数据）</p>
<a id="more"></a>

<p>v-on:click = “函数名或执行代码”    <font color="Cyan"><strong>语法糖：@click</strong></font> = “函数名或执行代码”（绑定事件及其回调函数）</p>
<p>v-html=”变量名”（该指令表示传入的(变量名)数据是html的格式,在解析时会将其解析为html）</p>
<p>v-cloak 将这个指令添加在vue管理DOM区域的便签属性上，再在css中添加[v-cloak]{display: none; }。就会使得在页面没有解析到vue代码时，会隐藏Mustache语法。给用户更好的体验。</p>
<p>v-pre（该指令表示不解析Mustache语法就将双大括号展示在界面）</p>
<p>v-text=”变量名”（该指令与Mustache类似但是该指令会覆盖这个便签中的内容，使用起来不灵活）</p>
<h2 id="动态绑定属性（v-bind）"><a href="#动态绑定属性（v-bind）" class="headerlink" title="动态绑定属性（v-bind）"></a>动态绑定属性（v-bind）</h2><h3 id="将数据绑定基本属性"><a href="#将数据绑定基本属性" class="headerlink" title="将数据绑定基本属性"></a>将数据绑定基本属性</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>当需要给一个标签的一个属性绑定一个vue数据时，在该属性前写入v-bind：将属性值写成“vue数据的属性名”即可</p>
<p><font color="Cyan"><strong>语法糖：将v-bind：仅写一个：即可</strong></font></p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgurl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imgurl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">   data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;你好&#x27;</span>,</span><br><span class="line">    imgurl:<span class="string">&#x27;http://pic1.win4000.com/wallpaper/2018-05-21/5b0287e6cd57e.jpg&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="动态绑定class属性"><a href="#动态绑定class属性" class="headerlink" title="动态绑定class属性"></a>动态绑定class属性</h3><h4 id="1-对象语法"><a href="#1-对象语法" class="headerlink" title="1_对象语法"></a><font color="blue">1_对象语法</font></h4><p>当一些类名有去除与添加的需求时就可使用v-bind，使用时class的值传入一个字符串(或一个函数的调用)，该字符串中为一个对象，对象中保存的属性名是类名，属性值是一个布尔值，当布尔值为true时对应的类名会添加到该标签上，反正则不添加。并且他会与不使用v-bind的类名结合，而不是互相覆盖。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active:isActive,line:isLine&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;getClasses()&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="javascript">        message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        isActive:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        isLine:<span class="literal">true</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line"><span class="javascript">        btnClick:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.isActive = !<span class="built_in">this</span>.isActive</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        getClasses:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          reurn &#123;<span class="attr">active</span>:<span class="built_in">this</span>.isActive,<span class="attr">line</span>:<span class="built_in">this</span>.isLine&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="2-数组语法"><a href="#2-数组语法" class="headerlink" title="2_数组语法"></a>2_数组语法</h4><p>与对象语法类似他一样可以传入数组或方法调用效果如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;active&#x27;,&#x27;line&#x27;]&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- class为：&quot;title active line&quot; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;[active,line]&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!-- class为：&quot;title aaaa bbbbb&quot; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;getClasses()&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!-- class为：&quot;title aaaa bbbbb&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      active:<span class="string">&#x27;aaaa&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      line:<span class="string">&#x27;bbbbb&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getClasses:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> [<span class="built_in">this</span>.active,<span class="built_in">this</span>.line]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="动态绑定style属性"><a href="#动态绑定style属性" class="headerlink" title="动态绑定style属性"></a>动态绑定style属性</h3><h4 id="1-对象绑定"><a href="#1-对象绑定" class="headerlink" title="1_对象绑定"></a><font color="blue">1_对象绑定</font></h4><p>为了将页面成模块化(提高复用)，就使得某些样式需要定制，将这些需要定制的样式写成可改变的就可使用v-bind。使用时style的值传入一个字符串(或一个函数的调用)，该字符串中为一个对象，对象中保存的属性名是css样式名，属性值是样式值(加引号)或变量(不加引号)。<font color="deeppink"><strong>属性值不加引号vue会将其当做变量去data对象中寻找。不加引号就相当于正常的css属性值</strong></font>为了使标签内部简化，可向style属性值中传入一个函数的调用(该函数返回的就是上述的对象)。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize:finalSize + &#x27;px&#x27;,backgroundColor:finalColor&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;getStyles()&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message:<span class="string">&#x27;nihao&#x27;</span>,</span></span><br><span class="line">      finalSize: 40,</span><br><span class="line"><span class="javascript">      finalColor: <span class="string">&#x27;#bfa&#x27;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getStyles:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;<span class="attr">fontSize</span>:<span class="built_in">this</span>.finalSize + <span class="string">&#x27;px&#x27;</span>,<span class="attr">backgroundColor</span>:<span class="built_in">this</span>.finalColor&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="2-数组绑定"><a href="#2-数组绑定" class="headerlink" title="2_数组绑定"></a>2_数组绑定</h4><p>与对象绑定类似，style传入的值还可是数组。（极少使用）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize:&#x27;50px&#x27;,backgroundColor:&#x27;#bfa&#x27;&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;[baseStyle1,baseStyle2]&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message:<span class="string">&#x27;nihao&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      baseStyle1: &#123;<span class="attr">fontSize</span>: <span class="string">&#x27;50px&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">      baseStyle2: &#123;<span class="attr">backgroundColor</span>: <span class="string">&#x27;#bfa&#x27;</span>&#125;,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="计算属性（computed）"><a href="#计算属性（computed）" class="headerlink" title="计算属性（computed）"></a>计算属性（computed）</h2><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>为了在html中简化表示一些数据的结合，就可以使用计算属性（computed）。下边三种表示全名的结果相同（第三种为计算属性）</p>
<p><font color="red"><strong>计算属性（computed）与methods的区别：</strong></font></p>
<ul>
<li><strong>计算属性在多次调用时只计算一次(缓存)，但是methods却是调用几次计算几次。</strong></li>
<li><strong>计算属性调用时不用加小括号(因为他的简写,此时他是一个属性不是函数)，但是methods的函数需要加括号</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName:<span class="string">&#x27;lebron&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      lastName:<span class="string">&#x27;james&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line"><span class="javascript">      fullName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getFullName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="复杂操作"><a href="#复杂操作" class="headerlink" title="复杂操作"></a>复杂操作</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>总价格：&#123;&#123;totalPrice&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      books:[</span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">110</span>,<span class="attr">name</span>:<span class="string">&#x27;Unix编程艺术&#x27;</span>,<span class="attr">price</span>:<span class="number">58</span>&#125;,</span></span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">111</span>,<span class="attr">name</span>:<span class="string">&#x27;代码大全&#x27;</span>,<span class="attr">price</span>:<span class="number">69</span>&#125;,</span></span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">112</span>,<span class="attr">name</span>:<span class="string">&#x27;深入理解计算机原理&#x27;</span>,<span class="attr">price</span>:<span class="number">85</span>&#125;,</span></span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">113</span>,<span class="attr">name</span>:<span class="string">&#x27;现代操作系统&#x27;</span>,<span class="attr">price</span>:<span class="number">98</span>&#125;,</span></span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">114</span>,<span class="attr">name</span>:<span class="string">&#x27;犀牛书&#x27;</span>,<span class="attr">price</span>:<span class="number">129</span>&#125;,</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      totalPrice:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> result = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.books.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">          result += <span class="built_in">this</span>.books[i].price</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> result</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="计算属性的get-和set"><a href="#计算属性的get-和set" class="headerlink" title="计算属性的get(和set)"></a>计算属性的get(和set)</h3><p>计算属性的完整写法如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName:<span class="string">&#x27;kobe&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      lastName:<span class="string">&#x27;Bryant&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    /*</span><br><span class="line">    计算属性的完整写法如下</span><br><span class="line">    computed: &#123;</span><br><span class="line">      fullName:&#123;</span><br><span class="line"><span class="javascript">        set:<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    但是一般计算属性没有set方法(只读属性)，他只是计算出基本数据的结果返回，</span><br><span class="line">    不需要对其进行设置,因此简写之后就变成了如下所示：</span><br><span class="line">    */</span><br><span class="line">    computed: &#123;</span><br><span class="line">      </span><br><span class="line">      /*</span><br><span class="line">      fullName:&#123;</span><br><span class="line"><span class="javascript">        get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      */</span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="comment">//最终简写成这样</span></span></span><br><span class="line"><span class="javascript">      fullName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为最终简写之后fullName是一个属性而不是一个方法，所以调用时不用加括号。</p>
<h3 id="计算属性computed与methods的对比"><a href="#计算属性computed与methods的对比" class="headerlink" title="计算属性computed与methods的对比"></a>计算属性computed与methods的对比</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1.直接拼接：语法过于繁琐 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 2.通过定义methods --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 3.使用computed --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName:<span class="string">&#x27;kobe&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      lastName:<span class="string">&#x27;Bryant&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getFullName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;getFullName()&#x27;</span>)		<span class="comment">//打印了4次</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      fullName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;fullName&#x27;</span>)		<span class="comment">//打印了1次</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过多次调用可以看出两者在重复使用时，computed利用了缓存只调用了一次(当内部内容改变时才会再次调用)，而methods是使用几次则调用几次。</p>
<h2 id="事件监听-v-on"><a href="#事件监听-v-on" class="headerlink" title="事件监听(v-on/@)"></a>事件监听(v-on/@)</h2><h3 id="v-on的参数问题"><a href="#v-on的参数问题" class="headerlink" title="v-on的参数问题"></a>v-on的参数问题</h3><ul>
<li><p>事件定义的方法没有形参时</p>
<p>此时在标签中调用函数加不加括号都可以</p>
</li>
<li><p>事件定义的方法有形参时</p>
<ul>
<li><font color="deeppink">当不带括号时候</font><ul>
<li><font color="red">此时vue会将event对象传入函数第一个参数</font></li>
</ul>
</li>
<li>当带括号不传入参数时<ul>
<li>此时函数中就接收不到任何参数，形参的值在初始化时都变成了undefined</li>
</ul>
</li>
<li>当带括号传入参数时<ul>
<li>正常传入参数时（传入参数个数与形参个数相同）<ul>
<li>当传入的参数为基本数据类型时，就以该数据传入函数</li>
<li>当传入的参数不是基本数据类型时，会去vue对象的data对象中寻找对应的变量传入函数<font color="red">（注意字符串要带引号否则就认为去data对象寻找）</font></li>
<li><font color="red">注意当需要向函数中传入event对象时，要写成**$event**。如果将传入的参数直接写成event时，vue会将其当做变量去data对象中寻找对应的变量。在里边找不到会报错，并将其赋值为undefined</font></li>
</ul>
</li>
<li>不正常传入参数时（传入参数个数与形参个数不匹配）<ul>
<li>与前者类似，只不过不够的会初始化时成为undefined，多的会没用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1.事件定义的方法没有参数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn1Click&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn1Click()&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 2.在事件定义的方法有参数时 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click(123)&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click()&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 3.event对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(123,event)&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(123,$event)&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(123,$event,13,16)&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      abc:123</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btn1Click</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;btn1Click()&#x27;</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btn2Click</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;btn2Click()&#x27;</span>,event)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btn3Click</span>(<span class="params">abc,event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;btn3Click()&#x27;</span>,abc,event)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="v-on的修饰符"><a href="#v-on的修饰符" class="headerlink" title="v-on的修饰符"></a>v-on的修饰符</h3><ul>
<li>.stop    禁止事件冒泡，相当于调用event.stopPropagation()</li>
<li>.prevent    禁止默认行为，相当于调用event.preventDefault()</li>
<li>.{keyCode|keyAlias}    只当事件是从特定按键触发时才会触发的回调。keyCode表示按键的编码(查表)，keyAlias表示按键的关键词</li>
<li>.once    只触发一次的回调</li>
<li>.native    监听组件根元素的原生事件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- .stop的使用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;divClick&quot;</span>&gt;</span></span><br><span class="line">    我是div</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- .prevent的使用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;baidu&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;submitClick&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 监听某个按键 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;keyUp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 监听一次的事件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;btn2Click&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      abc:123</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;btnClick()&#x27;</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">divClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;divClick()&#x27;</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">submitClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;submitClick()&#x27;</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">keyUp</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;keyUp()&#x27;</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btn2Click</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;btn2Click()&#x27;</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="v-if和v-else的使用"><a href="#v-if和v-else的使用" class="headerlink" title="v-if和v-else的使用"></a>v-if和v-else的使用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>isShow为true时显示<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>isShow为false时显示<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message:<span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      isShow:<span class="literal">true</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="v-if、v-else-if和v-else的使用"><a href="#v-if、v-else-if和v-else的使用" class="headerlink" title="v-if、v-else-if和v-else的使用"></a>v-if、v-else-if和v-else的使用</h3><p>如果判断逻辑较多不建议使用，应该写成方法调用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;score&gt;=90&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score&gt;=80&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score&gt;=60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;result&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      score:95</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">result</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> showMessage = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="built_in">this</span>.score&gt;=<span class="number">90</span>)&#123;</span></span><br><span class="line"><span class="javascript">          showMessage = <span class="string">&#x27;优秀&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.score&gt;=<span class="number">80</span>)&#123;</span></span><br><span class="line"><span class="javascript">          showMessage = <span class="string">&#x27;良好&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.score&gt;=<span class="number">60</span>)&#123;</span></span><br><span class="line"><span class="javascript">          showMessage = <span class="string">&#x27;及格&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">          showMessage = <span class="string">&#x27;不及格&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> showMessage</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h4><p><font color="deeppink">在输入框中输入内容后，点击切换按钮，输入框中的内容不会清除。</font><br>原因：<br>因为vue在处理DOM元素时，是先将其存储在内存中的一个虚拟DOM中，在切换时vue会对比相同标签的key值如果两者相同则会在原来基础上进行修改(提高复用性,提高性能)，而不是创建一个新的DOM。如果两者key值不同，则会创建一个新的DOM去覆盖之前的DOM。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&#x27;isUser&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户账号<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户账号&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>用户邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户邮箱&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isUser=!isUser&quot;</span>&gt;</span>切换类型<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      isUser: <span class="literal">true</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="v-show与v-if"><a href="#v-show与v-if" class="headerlink" title="v-show与v-if"></a>v-show与v-if</h3><p>v-if和v-show都可使一个DOM元素消失。<br>    v-if的消失是将该DOM元素从DOM树中删除。<br>    v-show的消失是给该DOM元素设置display为none，但该DOM元素依然在DOM树中。</p>
<p>两者的使用场景：<br>当显示与隐藏的切换频繁时使用v-show，当只有一次切换时使用v-if</p>
<h2 id="v-for遍历"><a href="#v-for遍历" class="headerlink" title="v-for遍历"></a>v-for遍历</h2><h3 id="遍历数组与对象"><a href="#遍历数组与对象" class="headerlink" title="遍历数组与对象"></a>遍历数组与对象</h3><ul>
<li>遍历数组<ul>
<li>仅使用一个值，则改值表示item</li>
<li>使用两个值，第一个表示item，第二个表示index</li>
</ul>
</li>
<li>遍历对象<ul>
<li>仅使用一个值，则改值表示value</li>
<li>使用两个值，第一个表示value，第二个表示key</li>
<li>使用三个值，第一个表示value，第二个表示key，第三个表示index</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app-Array&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in names&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in names&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;-&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app-Object&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in person&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key) in person&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key,index) in person&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app_Array = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app-Array&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      names:[<span class="string">&#x27;ysj&#x27;</span>,<span class="string">&#x27;lufei&#x27;</span>,<span class="string">&#x27;yingyan&#x27;</span>,<span class="string">&#x27;suolong&#x27;</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app_Object = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app-Object&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      person:&#123;</span><br><span class="line"><span class="javascript">        name:<span class="string">&#x27;ysj&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        age:<span class="string">&#x27;21&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        heght:<span class="string">&#x27;1.78&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="遍历注意事项使用key提高性能"><a href="#遍历注意事项使用key提高性能" class="headerlink" title="遍历注意事项使用key提高性能"></a>遍历注意事项使用key提高性能</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in letters&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      letters:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如：在这个示例中在letters数组中第二个位置插入一个元素f，此时vue的虚拟DOM中就会将原本第三个显示c的li变为显示f，第四个显示d的li变为显示c，以此类推然后最后再添加一个li的DOM元素显示e。这样做的性能及其低。<br>为了解决这一问题需要向li中添加一个key属性，并且要保证key值与其DOM元素的内容关联起来，因此写成：<font color="deeppink"><strong>:key=”item”</strong></font>这样此时再向数组中间插入一个f时，vue则会优先判断DOM元素中的key属性值是否与内容相关联（<font color="blue">调用diff算法</font>），相关联则保持原本不变，此时就会新创建一个li的DOM元素并写入f，然后插入到对应位置。此时的性能就比之前高很多。</p>
<h3 id="哪些数组的方法是响应式的"><a href="#哪些数组的方法是响应式的" class="headerlink" title="哪些数组的方法是响应式的"></a>哪些数组的方法是响应式的</h3><h4 id="响应式的："><a href="#响应式的：" class="headerlink" title="响应式的："></a><font color="deeppink"><strong>响应式的：</strong></font></h4><p>push()    在数组最后添加一个或多个元素<br>unshift()    在数组前面添加一个或多个元素<br>pop()    删除数组最后一个元素<br>shift()    删除数组第一个元素<br>sort()    排序<br>reverse()    反转数组<br>splice()    删除元素/插入元素/替换元素</p>
<h4 id="不是响应式的："><a href="#不是响应式的：" class="headerlink" title="不是响应式的："></a><font color="deeppink"><strong>不是响应式的：</strong></font></h4><p>使用数组下标值更改数组内容<br>例如：arr[0] = ‘aaaa’</p>
<p>替换为响应式的方法：</p>
<ul>
<li>arr.splice(0,1,’aaaa’)</li>
<li><font color="blue"><strong>Vue.set(arr,0,’aaaa’)</strong></font></li>
</ul>
<p><font color="blue"><strong>第二种方法为Vue内部的方法使用方式为：</strong></font></p>
<p>第一个参数表示要修改的对象，第二个为修改的索引值，第三个为修改后的值</p>
<h4 id="splice-使用方法："><a href="#splice-使用方法：" class="headerlink" title="splice()    使用方法："></a><font color="red"><strong>splice()    使用方法：</strong></font></h4><ul>
<li><p>参数：<br>第一个参数:    (start)操作数组开始的位置<br>第二个参数:    (delnum)删除元素个数,如果没有传入值则表示后边的全删,传入0表示不删<br>后续参数:    (item)表示从start位置插入的元素(可传入多个)</p>
</li>
<li><p>使用方法</p>
<p>删除元素就传入两个参数：第一个为删除起始位置，第二个为删除个数<br>插入元素就传入三个参数：第一个为起始位置，第二个为0，第三个为插入内容<br>替换元素就传入三个参数：第一个为起始位置，第二个为需要替换下来的元素个数（即把他们删除），第三个为插入内容</p>
</li>
</ul>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>在vue对象中可以创建一个过滤器对象（filters），内部存入函数，这些函数是对数据进行过滤处理的。使用时在Mustache语法中的变量后添加<font color="deeppink"> | 过滤器函数名</font>即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in books&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.id&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.date&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.price | showPrice&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>总价格：&#123;&#123;totalPrice | showPrice&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;./js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      books: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 1,</span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;《算法导论》&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          date: <span class="string">&#x27;2006-9&#x27;</span>,</span></span><br><span class="line">          price: 85.00,</span><br><span class="line">          count: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 2,</span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;《UNIX编程艺术》&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          date: <span class="string">&#x27;2006-2&#x27;</span>,</span></span><br><span class="line">          price: 59.00,</span><br><span class="line">          count: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 3,</span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;《编程珠玑》&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          date: <span class="string">&#x27;2008-10&#x27;</span>,</span></span><br><span class="line">          price: 39.00,</span><br><span class="line">          count: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 4,</span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;《代码大全》&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          date: <span class="string">&#x27;2006-3&#x27;</span>,</span></span><br><span class="line">          price: 128.00,</span><br><span class="line">          count: 1</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">totalPrice</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> totalPrice = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.books.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">          totalPrice += <span class="built_in">this</span>.books[i].price * <span class="built_in">this</span>.books[i].count</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> totalPrice</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    filters:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">showPrice</span>(<span class="params">price</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">&#x27;￥&#x27;</span> + price.toFixed(<span class="number">2</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="v-model-表单-textarea-数据的双向绑定"><a href="#v-model-表单-textarea-数据的双向绑定" class="headerlink" title="v-model:表单(textarea)数据的双向绑定"></a>v-model:表单(textarea)数据的双向绑定</h2><h3 id="基本使用及其原理"><a href="#基本使用及其原理" class="headerlink" title="基本使用及其原理"></a>基本使用及其原理</h3><p>v-model其实是一个语法糖，他背后的本质是包含两个操作</p>
<ul>
<li>v-bind绑定一个value属性（使vue对象中的数据绑定到BOM中）</li>
<li>v-on指令给当前元素绑定input事件（使页面中数据改变会同步到vue对象的数据中）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;valueChange&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;message = $event.target.value&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      valueChange:<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.message = e.target.value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="v-model结合radio使用"><a href="#v-model结合radio使用" class="headerlink" title="v-model结合radio使用"></a>v-model结合radio使用</h3><p>注意点：</p>
<ul>
<li>radio单选框要实现单选需要绑定相同的name属性值，但是如果都使用的相同的v-model属性值则name属性可以省略。</li>
<li>默认值：当时使用v-model时，将其进行初始化，此时就会默认选中初始化的值。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;sex&#x27;</span>&gt;</span>男</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;sex&#x27;</span>&gt;</span>女</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您选择的性别是：&#123;&#123;sex&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      sex:<span class="string">&#x27;男&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="v-model结合checkbox使用"><a href="#v-model结合checkbox使用" class="headerlink" title="v-model结合checkbox使用"></a>v-model结合checkbox使用</h3><ul>
<li><p>单选（仅有一个checkbox）例如同意协议<br>对应一个Boolean值</p>
</li>
<li><p>多选（有多个checkbox）<br>对应一个数组</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 单选 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;agree&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;agree&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isAgree&quot;</span>&gt;</span>同意协议</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的选择是：&#123;&#123;isAgree&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">:disabled</span>=<span class="string">&quot;!isAgree&quot;</span>&gt;</span>下一步<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 多选 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;篮球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>篮球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;羽毛球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>羽毛球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;乒乓球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>乒乓球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;足球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>足球</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的爱好是:&#123;&#123;hobbies&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      isAgree: <span class="literal">false</span>,</span></span><br><span class="line">      hobbies:[]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h4><p>将数据并不是写死到DOM元素中，而是通过vue的数据来显示在页面中。（使用v-for遍历）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">v-for</span>=<span class="string">&quot;item in originFruits&quot;</span> <span class="attr">:for</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:id</span>=<span class="string">&quot;item&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fruits&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的选择的水果是：&#123;&#123;fruits&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      fruits:[],</span><br><span class="line"><span class="javascript">      originFruits:[<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>,<span class="string">&#x27;梨&#x27;</span>,<span class="string">&#x27;榴莲&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span>,<span class="string">&#x27;菠萝&#x27;</span>,<span class="string">&#x27;哈密瓜&#x27;</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h3 id="v-model结合select使用"><a href="#v-model结合select使用" class="headerlink" title="v-model结合select使用"></a>v-model结合select使用</h3><p>v-model绑定在select标签上而不是option标签</p>
<ul>
<li><p>选择一个<br>对应一个数据（当给该数据初始化赋值后,会默认选中该选项）</p>
</li>
<li><p>选择多个<br>要想选中多个需要在select标签上添加multiple属性，此时用户需要多选时按住Ctrl点击即可多选。<br>对应一个数组</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 单选 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;fruit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香蕉&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;梨&quot;</span>&gt;</span>梨<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;葡萄&quot;</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的选择的水果是：&#123;&#123;fruit&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 多选 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香蕉&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;梨&quot;</span>&gt;</span>梨<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;葡萄&quot;</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的选择的水果是：&#123;&#123;fruits&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      fruit: <span class="string">&#x27;香蕉&#x27;</span>,</span></span><br><span class="line">      fruits:[]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="v-model修饰符的使用"><a href="#v-model修饰符的使用" class="headerlink" title="v-model修饰符的使用"></a>v-model修饰符的使用</h3><ul>
<li>lazy<ul>
<li>默认情况下，数据的双向绑定是实时的</li>
<li>即在input中只要输入的内容发生改变，数据就会频繁的与vue中的存储数据进行对应变化</li>
<li>lazy修饰符可以使用户在输入框中点击回车，或输入框失去焦点时才进行数据更新。</li>
</ul>
</li>
<li>number<ul>
<li>默认情况下，在输入框无论我们输入的是数字韩式字母，v-model在传输时都会将其转化为string处理</li>
<li>但是当我们希望处理的是数字类型，可以使用number修饰符。此时会将输入框的内容自动转换成数字类型。</li>
</ul>
</li>
<li>trim<ul>
<li>如果输入的内容首尾有很多空格，通常我们希望将其去除</li>
<li>trim修饰符就可将输入框中的左右两边空格去除后再存入vue的数据中。</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;age&#125;&#125;_&#123;&#123;typeof age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您输入的名字:&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line">      age: 18,</span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h1 id="Vue的组件化"><a href="#Vue的组件化" class="headerlink" title="Vue的组件化"></a><font color="red">Vue的组件化</font></h1><h2 id="组件化的基本使用"><a href="#组件化的基本使用" class="headerlink" title="组件化的基本使用"></a>组件化的基本使用</h2><p><font color="Cyan"><strong>组件化思想：</strong></font>（提高复用性，降低耦合性）<br>将一个页面拆分成一个一个的小功能块（每个功能块又可以向下继续查分更小的功能块。最终将其抽象成一个组件树），每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就会变得很容易。</p>
<p>组件使用步骤：</p>
<ul>
<li><p>创建组件构造器对象</p>
<p>使用Vue的extend方法创建组件构造器对象，该方法需要传入一个对象作为参数，对象中有一个template(模板)属性，该属性的属性值为字符串，用来存储html的模板。</p>
</li>
<li><p>注册组件</p>
<p>使用Vue的component(组件)方法注册组件，该方法传入两个值。第一个为使用组件时的标签名，第二个为对应的构造器对象。<font color="deeppink">（通过该方式注册的组件为全局组件）</font></p>
</li>
<li><p>使用组件</p>
<p>在html中直接使用注册组件时的标签名即可使用该组件（注意必须放在vue控制的范围内才会生效）</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span> </span><br><span class="line"><span class="javascript">  <span class="comment">//1.创建组件构造器对象 </span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnC = Vue.extend(&#123;</span></span><br><span class="line">    template:`</span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,哈哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="comment">// 2.注册组件</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;my_con&#x27;</span>,cpnC)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a>全局组件和局部组件</h3><ul>
<li><p>全局组件    (即可以在任何一个vue的实例中使用)</p>
<p>使用Vue的component(组件)方法注册组件就是全局组件</p>
</li>
<li><p><font color="blue">局部组件</font>    (仅可以再对应的vue实例中使用)</p>
<p>在vue实例中的components属性中注册的组件就是局部组件,仅能在这个vue实例控制的DOM元素中使用</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">con</span>&gt;</span><span class="tag">&lt;/<span class="name">con</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">con</span>&gt;</span><span class="tag">&lt;/<span class="name">con</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app1&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">con</span>&gt;</span><span class="tag">&lt;/<span class="name">con</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">con</span>&gt;</span><span class="tag">&lt;/<span class="name">con</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">con</span>&gt;</span><span class="tag">&lt;/<span class="name">con</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span> </span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnC = Vue.extend(&#123;</span></span><br><span class="line">    template:`</span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,哈哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn1C = Vue.extend(&#123;</span></span><br><span class="line">    template:`</span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;my_con&#x27;</span>,cpnC)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      con:cpn1C</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app1 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app1&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="注册组件语法糖"><a href="#注册组件语法糖" class="headerlink" title="注册组件语法糖"></a>注册组件语法糖</h3><p>省略了创建组件构造器对象的步骤，而将其直接写入注册组件中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;my_con&#x27;,&#123;</span><br><span class="line">  template:`</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;你好&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    con:&#123;</span><br><span class="line">      template:`</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      `</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const app1 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app1&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;你好&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="组件模板抽离"><a href="#组件模板抽离" class="headerlink" title="组件模板抽离"></a>组件模板抽离</h2><p>两种方式：</p>
<ul>
<li>使用script标签引入,类型必须是text/x-template</li>
<li>使用template标签</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 1.使用script标签引入,类型必须是text/x-template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/x-template&#x27;</span> <span class="attr">id</span>=<span class="string">&quot;template1&quot;</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是template1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是template1内容,哈哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.使用template标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;template2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是template2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是template2内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span> </span><br><span class="line"><span class="javascript">Vue.component(<span class="string">&#x27;cpn1&#x27;</span>,&#123;</span></span><br><span class="line"><span class="javascript">  template: <span class="string">&#x27;#template1&#x27;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  components:&#123;</span><br><span class="line"><span class="javascript">    <span class="string">&#x27;cpn2&#x27;</span>:&#123;</span></span><br><span class="line"><span class="javascript">      template: <span class="string">&#x27;#template2&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="组件中的数据存储问题"><a href="#组件中的数据存储问题" class="headerlink" title="组件中的数据存储问题"></a><font color="red">组件中的数据存储问题</font></h2><p>首先组件无法访问vue实例的data数据，就算可以也不建议，这样会让vue实例存储内容过多。耦合性增强。</p>
<p>数据应该存储在组件构造器对象中（这个对象与vue实例对象很相似，可以存储data，methods等等）当将数据存储到组件构造器对象的data中时不能以对象的形式存入，要以函数其函数返回对象的形式存入。</p>
<p><strong><font color="red">为什么组件中数据存储时必须存入一个函数且函数返回一个对象：</font></strong></p>
<p>​        因为组件是会被多次使用的，如果直接存入对象（虽然会报错），这些组件实例多次使用这个组件时，当一个组件实例使用组件内对这个数据进行修改时，其他的组件实例中的数据内容也会随之更改。<br>​        当数据被存入到一个函数且函数返回一个对象时，每个组件实例中的数据对象是不同的，其中一个更改数据，对其他组件实例没有影响。</p>
<p>当写成下列方式会出现修改其中一个数据，其他组件实例数据跟随改变。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件实例对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 1.注册组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> obj = &#123;</span></span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;cpn&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// data() &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   return &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//     counter: 0</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> obj</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.counter++</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.counter--</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="父组件与子组件"><a href="#父组件与子组件" class="headerlink" title="父组件与子组件"></a>父组件与子组件</h2><p>父子组件即，在一个组件中的components属性中注册了另一个组件。此时后者便是前者的子组件。</p>
<p>如果想要在#app中使用cpn1组件,那么这个组件要么是全局组件,要么在管理app的vue实例中定义过局部组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span> </span><br><span class="line"><span class="javascript">  <span class="comment">// 子组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnC1 = Vue.extend(&#123;</span></span><br><span class="line">    template:`</span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,哈哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="comment">// 父组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnC2 = Vue.extend(&#123;</span></span><br><span class="line">    template:`</span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `,</span><br><span class="line">    components:&#123;</span><br><span class="line">      cpn1:cpnC1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="comment">// root(根组件)</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      cpn2:cpnC2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="父子组件的通信-数据"><a href="#父子组件的通信-数据" class="headerlink" title="父子组件的通信(数据)"></a><font color="red">父子组件的通信</font>(数据)</h3><p>​        首先子组件是不能引用父组件或vue实例的数据的<br>在开发时通常是将网络请求的任务交给最外边的大组件(降低发送请求次数,降低服务器网络负担，这时候就需要将请求到的数据从父组件传递给子组件。</p>
<p>通信方式：</p>
<ul>
<li><p>通过props（properties属性）向子组件传递数据</p>
<p>首先在子组件的组件构造器对象中添加props属性，其属性值为一个数组(不常用)或一个对象，然后在使用组件时用v-bind绑定子组件数据与父组件数据的对应关系。此时就可在模板中使用这些数据了。</p>
<p>注意：</p>
<ol>
<li>props的属性值为数组时，数组中每一项都要加引号，但他们表示的是变量</li>
<li>在使用组件时<font color="red">必须用v-bind绑定</font>否则会将其等号右侧的当做一个字符串而不是变量。</li>
<li>props中的<font color="blue">驼峰标示</font>时，当在使用该组件时，标签属性中使用时应该讲驼峰标示转换为以-连接的语法（例如：cMessage变成c-message）其中得原因是html没有大小写的概念。</li>
</ol>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>  <span class="attr">:c-message</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:c-movies</span>=<span class="string">&quot;movies&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in cMovies&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;cMessage&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// 父传子:props</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">  template:<span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="comment">// props: [&#x27;cmovies&#x27;,&#x27;cmessage&#x27;],</span></span></span><br><span class="line">  props: &#123;</span><br><span class="line"><span class="javascript">    <span class="comment">// cmovies: Array,		//类型的限制</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// cmassage: String,	</span></span></span><br><span class="line">    cMessage: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,       <span class="comment">//类型限制</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">&#x27;aaaaa&#x27;</span>,   <span class="comment">//默认值</span></span></span><br><span class="line"><span class="javascript">      required: <span class="literal">true</span>      <span class="comment">//是否是必传值</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    cMovies: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// default: [],     //这样写会报错,数组和对象默认值直接写会报错,提示使用工厂函数返回一个对象或数组</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> []</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    movies: [<span class="string">&#x27;海王&#x27;</span>,<span class="string">&#x27;海贼王&#x27;</span>,<span class="string">&#x27;海尔兄弟&#x27;</span>]</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    cpn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<ul>
<li><p>通过自定义事件向父组件发送消息</p>
<p>​        一般都是子组件触发了什么事件，此时子组件将触发事件的消息传递给父组件</p>
<p>​        首先在子组件的模板绑定的事件被触发，在这个触发事件的回调函数中使用this.$emit（发射）方法向父组件传递信息，这个方法需要传递进两个参数，第一个是自定义事件的名称（字符串），后边的参数是想要传递给父组件的信息。然后在父组件的模板中监听子组件的自定义事件，在父组件中处理这个自定义事件。</p>
</li>
</ul>
<p>注意：</p>
<ol>
<li>在父组件模板中监听子组件的自定义事件时不用定义参数，这时<font color="blue">不会像往常一样给回调函数传入event，而是传入子组件的后续参数。</font></li>
<li>驼峰标示问题</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在这里不写参数不会像之前给函数传入event而会传入子组件的后续参数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> @<span class="attr">item-click</span>=<span class="string">&quot;cpnClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--子组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-for</span>=<span class="string">&quot;item in categories&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">click</span>=<span class="string">&quot;btnClick(item)&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;item.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 1.子组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        categories: [</span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;热门推荐&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;bbb&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;手机数码&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;ccc&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;家用家电&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;ddd&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;电脑办公&#x27;</span>&#125;,</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btnClick</span>(<span class="params">item</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 发射事件: 自定义事件</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;item-click&#x27;</span>, item)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 2.父组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">cpnClick</span>(<span class="params">item</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;cpnClick&#x27;</span>, item);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="父子组件访问-方法"><a href="#父子组件访问-方法" class="headerlink" title="父子组件访问(方法)"></a>父子组件访问(方法)</h3><h4 id="父组件访问子组件"><a href="#父组件访问子组件" class="headerlink" title="父组件访问子组件"></a>父组件访问子组件</h4><p>使用$children或者$refs（reference引用）</p>
<ul>
<li><p>$children（这个属性<strong>不建议使用</strong>，因为他是通过下标取得对应的子组件，当组件个数发生更改就会导致出现问题。）</p>
<p>在父组件中使用该属性时返回的是一个<font color="red">数组</font>，数组中存储的是所有的子组。通过下标来获得对应子组件的使用权。</p>
</li>
<li><p>$refs (reference)</p>
<p>使用时先在父组件中使用该属性时返回的是一个<font color="red">对象</font>，中存储的是所有的子组。通过下标来获得对应子组件的使用权。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">ref</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 1.使用$children  数组类型</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(this.$children) </span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$children[0].showMessage()</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 2.使用$refs  对象类型</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.aaa.name)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    cpn: &#123;</span><br><span class="line"><span class="javascript">      template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;我是子组件的name&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        showMessage () &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&#x27;showMessage()&#x27;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="子组件访问父组件"><a href="#子组件访问父组件" class="headerlink" title="子组件访问父组件"></a>子组件访问父组件</h4><p>使用$parent以及$root</p>
<ul>
<li><p>$parent    (不建议使用因为会加强子组件对父组件的依赖,使耦合性增强,复用性降低)</p>
</li>
<li><p>$root</p>
<p>访问到的是顶层的Vue实例对象</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是cpn组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ccpn</span>&gt;</span><span class="tag">&lt;/<span class="name">ccpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;ccpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件ccpn<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    cpn: &#123;</span><br><span class="line"><span class="javascript">      template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;我是cpn组件的name&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        ccpn: &#123;</span><br><span class="line"><span class="javascript">          template: <span class="string">&#x27;#ccpn&#x27;</span>,</span></span><br><span class="line">          methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">// 1.访问父组件的$parent</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent)       <span class="comment">//VueComponent对象</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent.name)</span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.$root)         <span class="comment">//顶层Vue实例对象</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.$root.message)</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a><font color="red">插槽slot</font></h2><p>插槽的特点：</p>
<ul>
<li><font color="red">为了让封装的组件更加具有扩展性。</font></li>
<li><font color="red">让使用者可以决定组件内部的一些内容到底展示什么。</font></li>
</ul>
<p>使用插槽的原则：抽取共性，保留不同。</p>
<h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li>插槽的基本使用：在模板中使用&lt;slot&gt;&lt;/slot&gt;</li>
<li>插槽的默认值：在使用插槽时向该插槽中写入的就是该插槽的默认值，在使用组件时不像组件中添加内容就会使用该插槽的默认值</li>
<li>如果有多个值同时被放入组件进行替换时会全部替换</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span>hehehe<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件,哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    cpn: &#123;</span><br><span class="line"><span class="javascript">      template: <span class="string">&#x27;#cpn&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>当在使用组件时如果该组件没有设置插槽，此时在组件内写的HTML内容会被组件直接替换。如果设置的插槽（无名），此时没有指定插槽的HTML内容会将其替换后再加入DOM，如果设置的插槽（有名），此时将对应指定插槽的HTML内容会将其替换后再加入DOM。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span>搜索栏<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;left&quot;</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;left&quot;</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 2.6之后的新写法及其简写(必须用template包裹) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:left</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">center</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;rigth&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    cpn: &#123;</span><br><span class="line"><span class="javascript">      template: <span class="string">&#x27;#cpn&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="编译作用域以及作用域插槽"><a href="#编译作用域以及作用域插槽" class="headerlink" title="编译作用域以及作用域插槽"></a>编译作用域以及作用域插槽</h3><p>改变了父子组件数据的通信</p>
<p><font color="red">父组件模板的内容在父组件作用域编译，子组件模板的内容在子组件作用域编译</font></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 旧写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--目的是获取子组件中的pLanguages--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;a&quot;</span> <span class="attr">slot-scope</span>=<span class="string">&quot;slot&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;span v-for=&quot;item in slot.data&quot;&gt;&#123;&#123;item&#125;&#125; * &lt;/span&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;slot.data.join(&#x27; * &#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 新写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--目的是获取子组件中的pLanguages--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">a</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 将包含所有插槽 prop 的对象命名为 slotProps --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;slotProps&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 这里注意大小写HTML没有大写只认识小写 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;slotProps.data.join(&#x27; * &#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 把pLanguages数组改名为data绑定传输过去 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&#x27;a&#x27;</span> <span class="attr">:data</span>=<span class="string">&quot;pLanguages&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in pLanguages&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            pLanguages: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C#&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Go&#x27;</span>, <span class="string">&#x27;Swift&#x27;</span>]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>04_有关webpack</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/04-%E6%9C%89%E5%85%B3webpack/</url>
    <content><![CDATA[<h4 id="1-什么是webpack"><a href="#1-什么是webpack" class="headerlink" title="1. 什么是webpack"></a>1. 什么是webpack</h4><ul>
<li>webpack和gulp对比</li>
<li>webpack依赖环境</li>
<li>安装webpack</li>
</ul>
<a id="more"></a>

<h4 id="2-webpack的起步"><a href="#2-webpack的起步" class="headerlink" title="2. webpack的起步"></a>2. webpack的起步</h4><ul>
<li>webpack命令</li>
<li>webpack配置: webpack.config.js/package.json(scripts)</li>
</ul>
<p>文件目录解析：</p>
<p><a href="https://imgchr.com/i/s9pSB9"><img src="https://s3.ax1x.com/2021/01/03/s9pSB9.png" alt="s9pSB9.png"></a></p>
<p><img src="/Vue/%E7%AC%94%E8%AE%B0/vue/04-%E6%9C%89%E5%85%B3webpack/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20210320093146245.png" alt="image-20210320093146245"></p>
<h4 id="3-webpack的loader"><a href="#3-webpack的loader" class="headerlink" title="3. webpack的loader"></a>3. webpack的loader</h4><ul>
<li>css-loader/style-loader</li>
<li>less-loader/less</li>
<li>url-loader/file-loader</li>
<li>babel-loader</li>
</ul>
<h4 id="4-webpack中配置Vue"><a href="#4-webpack中配置Vue" class="headerlink" title="4. webpack中配置Vue"></a>4. webpack中配置Vue</h4><ul>
<li>vue-loader</li>
</ul>
<p>模板快捷键：default</p>
<p><strong>安装vue-loader和vue-template-compiler</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue-loader vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure>
<h4 id="5-webpack的plugin"><a href="#5-webpack的plugin" class="headerlink" title="5. webpack的plugin"></a>5. webpack的plugin</h4><h4 id="6-搭建本地服务器"><a href="#6-搭建本地服务器" class="headerlink" title="6. 搭建本地服务器"></a>6. 搭建本地服务器</h4><ul>
<li>webpack-dev-server</li>
</ul>
<h4 id="7-配置文件的分离"><a href="#7-配置文件的分离" class="headerlink" title="7. 配置文件的分离"></a>7. 配置文件的分离</h4><h4 id="执行npm-run-build的过程"><a href="#执行npm-run-build的过程" class="headerlink" title="执行npm run build的过程"></a><font color="red">执行npm run build的过程</font></h4><p><a href="https://imgchr.com/i/s9pCA1"><img src="https://s3.ax1x.com/2021/01/03/s9pCA1.png" alt="s9pCA1.png"></a></p>
<h4 id="执行npm-run-dev的过程"><a href="#执行npm-run-dev的过程" class="headerlink" title="执行npm run dev的过程"></a><font color="red">执行npm run dev的过程</font></h4><p><a href="https://imgchr.com/i/s9pih6"><img src="https://s3.ax1x.com/2021/01/03/s9pih6.png" alt="s9pih6.png"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>05_Vue Cli</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/05-Vue-Cli/</url>
    <content><![CDATA[<h2 id="一-初见Vue-Cli"><a href="#一-初见Vue-Cli" class="headerlink" title="一.初见Vue Cli"></a>一.初见Vue Cli</h2><h3 id="1-1-什么是CLI"><a href="#1-1-什么是CLI" class="headerlink" title="1.1. 什么是CLI"></a>1.1. 什么是CLI</h3><ul>
<li>脚手架是什么东西.</li>
<li>CLI依赖webpack,node,npm</li>
<li>安装CLI3 -&gt; 拉去CLI2模块</li>
</ul>
<a id="more"></a>

<p>Cli是Command-Line Interface，翻译为命令行界面，但是俗称<font color="red">脚手架</font></p>
<p>Vue Cli是一个官方发布的vue.js项目脚手架</p>
<p>使用vue-cli可以快速的搭建Vue开发环境以及对应的webpack配置。</p>
<h3 id="1-2-安装Vue-Cli"><a href="#1-2-安装Vue-Cli" class="headerlink" title="1.2 安装Vue Cli"></a>1.2 安装Vue Cli</h3><p>安装Vue Cli</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure>
<p>拉取2.x模板</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br></pre></td></tr></table></figure>
<p>初始化cli2项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue init webpack 项目名称</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/s9pVje"><img src="https://s3.ax1x.com/2021/01/03/s9pVje.png" alt="s9pVje.png"></a></p>
<h3 id="1-3-cli2目录分析"><a href="#1-3-cli2目录分析" class="headerlink" title="1.3 cli2目录分析"></a>1.3 cli2目录分析</h3><p><a href="https://imgchr.com/i/s9pmBd"><img src="https://s3.ax1x.com/2021/01/03/s9pmBd.png" alt="s9pmBd.png"></a></p>
<h3 id="1-4-runtim-compiler于runtim-only的区别"><a href="#1-4-runtim-compiler于runtim-only的区别" class="headerlink" title="1.4 runtim-compiler于runtim-only的区别"></a>1.4 runtim-compiler于runtim-only的区别</h3><p>两者只在main.js文件中存在差异</p>
<p><a href="https://imgchr.com/i/s9pMNt"><img src="https://s3.ax1x.com/2021/01/03/s9pMNt.png" alt="s9pMNt.png"></a></p>
<p>首先来了解一下Vue程序的运行过程</p>
<p><a href="https://imgchr.com/i/s9p19f"><img src="https://s3.ax1x.com/2021/01/03/s9p19f.png" alt="s9p19f.png"></a></p>
<p>runtim-compiler<br>template –&gt; ast –&gt;render –&gt; vdom –&gt; UI</p>
<p>runtim-only    （性能更高，代码更少）<br>render –&gt; vdom –&gt; UI</p>
<ul>
<li><p>如果在之后的开发中，你依然使用template，就需要选择Runtime-Compiler</p>
</li>
<li><p>如果你之后的开发中，使用的是.vue文件夹开发，那么可以选择Runtime-only</p>
</li>
</ul>
<h3 id="1-5-render函数"><a href="#1-5-render函数" class="headerlink" title="1.5 render函数"></a><font color="red">1.5 render函数</font></h3><ul>
<li>不使用render函数:</li>
</ul>
<p><a href="https://imgchr.com/i/s9pYuQ"><img src="https://s3.ax1x.com/2021/01/03/s9pYuQ.png" alt="s9pYuQ.png"></a></p>
<ul>
<li>使用方式1：</li>
</ul>
<p><a href="https://imgchr.com/i/s9paEn"><img src="https://s3.ax1x.com/2021/01/03/s9paEn.png" alt="s9paEn.png"></a></p>
<ul>
<li>使用方式2：</li>
</ul>
<p><a href="https://imgchr.com/i/s9PBCt"><img src="https://s3.ax1x.com/2021/01/03/s9PBCt.png" alt="s9PBCt.png"></a></p>
<p>在.vue文件中的template模板，不需要进行template –&gt; ast –&gt;render –&gt; vdom –&gt; UI 中的前两步。</p>
<p><strong><font color="red">那么.vue文件中的template是由谁处理了呢？</font></strong><br>因为在解析.vue文件时，会经过<font color="red">vue-template-compiler</font>（安装vue时安装过的）来将.vue文件进行解析成一个对象。该对象中的template会被解析为render函数。</p>
<h2 id="二-Vue-Cli3"><a href="#二-Vue-Cli3" class="headerlink" title="二. Vue Cli3"></a>二. Vue Cli3</h2><p>在vue cli2中使用了flow-type(Facebook)<br>vue cli3中使用的是TypeScript(微软)</p>
<h3 id="2-1-创建cli3项目"><a href="#2-1-创建cli3项目" class="headerlink" title="2.1 创建cli3项目"></a>2.1 创建cli3项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create 项目名称</span><br></pre></td></tr></table></figure>
<p>选择配置</p>
<p><a href="https://imgchr.com/i/s9Prgf"><img src="https://s3.ax1x.com/2021/01/03/s9Prgf.png" alt="s9Prgf.png"></a></p>
<p>目录结构分析</p>
<p><a href="https://imgchr.com/i/s9PD8P"><img src="https://s3.ax1x.com/2021/01/03/s9PD8P.png" alt="s9PD8P.png"></a></p>
<p>在cli3中的.vue文件的vue的el属性写成了vue.$mount<br>原因:vue中el属性(vue管理的区域)在源码中是：vue.el等价于vue.$mount</p>
<h3 id="2-2-配置去哪儿了"><a href="#2-2-配置去哪儿了" class="headerlink" title="2.2 配置去哪儿了"></a>2.2 配置去哪儿了</h3><h4 id="2-2-1-第一种方式-使用vue-ui"><a href="#2-2-1-第一种方式-使用vue-ui" class="headerlink" title="2.2.1 第一种方式:使用vue ui"></a>2.2.1 第一种方式:使用vue ui</h4><p>在本地安装vue/cli时会同时安装了vue，在vue中包含了vue ui。在哪个目录下都可以使用，他管理的是本地服务器。然后导入项目中，即可查看该项目的配置。</p>
<h4 id="2-2-2-第二种方式-在文件目录中查找"><a href="#2-2-2-第二种方式-在文件目录中查找" class="headerlink" title="2.2.2 第二种方式:在文件目录中查找"></a>2.2.2 第二种方式:在文件目录中查找</h4><p>在node_modules@vue\cli-service\webpack.config.js中</p>
<h4 id="2-2-3-当需要修改默认配置"><a href="#2-2-3-当需要修改默认配置" class="headerlink" title="2.2.3 当需要修改默认配置"></a><font color="red">2.2.3 当需要修改默认配置</font></h4><p>在项目文件夹根目录下创建一个vue.config.js配置文件（文件名不能修改）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>07_Vuex状态管理插件</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/07-Vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="一-认识Vuex"><a href="#一-认识Vuex" class="headerlink" title="一 认识Vuex"></a>一 认识Vuex</h3><h4 id="1-1-vuex是做什么的"><a href="#1-1-vuex是做什么的" class="headerlink" title="1.1 vuex是做什么的"></a>1.1 vuex是做什么的</h4><ul>
<li>官方解释：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。<ul>
<li>它采用 集中式存储管理 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</li>
<li>Vuex 也集成到 Vue 的官方调试工具 <a href="https://github.com/vuejs/vue-devtools">devtools</a><a href="https://github.com/vuejs/vue-devtools"> extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p><strong>状态管理</strong>到底是什么？</p>
<ul>
<li><strong>状态管理模式、集中式存储管理</strong>这些名词听起来就非常高大上，让人捉摸不透。</li>
<li>其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。</li>
<li>然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。</li>
<li>那么，多个组件是不是就可以共享这个对象中的所有变量属性了呢？</li>
</ul>
</li>
<li><p>等等，如果是这样的话，为什么官方还要专门出一个插件Vuex呢？难道我们不能自己封装一个对象来管理吗？</p>
<ul>
<li>当然可以，只是我们要先想想VueJS带给我们最大的便利是什么呢？没错，就是<font color="red"><strong>响应式</strong></font>。</li>
<li>如果你自己封装实现一个对象能不能保证它里面所有的属性做到响应式呢？当然也可以，只是自己封装可能稍微麻烦一些。</li>
<li>不用怀疑，Vuex就是为了提供这样一个在多个组件间共享状态的插件，用它就可以了。</li>
</ul>
</li>
</ul>
<h4 id="1-2-vuex管理什么状态呢"><a href="#1-2-vuex管理什么状态呢" class="headerlink" title="1.2 vuex管理什么状态呢"></a>1.2 vuex管理什么状态呢</h4><ul>
<li>但是，有什么状态时需要我们在多个组件间共享的呢？<ul>
<li>如果你做过大型开放，你一定遇到过多个状态，在多个界面间的共享问题。</li>
<li>比如用户的登录状态、用户名称、头像、地理位置信息等等。</li>
<li>比如商品的收藏、购物车中的物品等等。</li>
<li>这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的（待会儿我们就可以看到代码了，莫着急）。</li>
</ul>
</li>
</ul>
<h4 id="1-3-单页面的状态管理"><a href="#1-3-单页面的状态管理" class="headerlink" title="1.3 单页面的状态管理"></a>1.3 单页面的状态管理</h4><ul>
<li>我们知道，要在单个组件中进行状态管理是一件非常简单的事情<ul>
<li>State：不用多说，就是我们的状态。（你姑且可以当做就是data中的属性）</li>
<li>View：视图层，可以针对State的变化，显示不同的信息。（这个好理解吧？）</li>
<li>Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。</li>
</ul>
</li>
</ul>
<p><a href="https://imgchr.com/i/s9MAoV"><img src="https://s3.ax1x.com/2021/01/03/s9MAoV.png" alt="s9MAoV.png"></a></p>
<h4 id="1-4-全局单例模式（大管家）"><a href="#1-4-全局单例模式（大管家）" class="headerlink" title="1.4 全局单例模式（大管家）"></a>1.4 全局<font color="red">单例模式</font>（大管家）</h4><ul>
<li><p>我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。</p>
</li>
<li><p>之后，你们每个试图，按照我<font color="blue"><strong>规定好的</strong></font>规定，进行访问和修改等操作。</p>
</li>
<li><p>这就是Vuex背后的基本思想。</p>
</li>
</ul>
<h3 id="二-vuex的使用"><a href="#二-vuex的使用" class="headerlink" title="二 vuex的使用:"></a>二 vuex的使用:</h3><h4 id="2-1-配置vuex"><a href="#2-1-配置vuex" class="headerlink" title="2.1 配置vuex"></a>2.1 配置vuex</h4><ul>
<li><p><strong>首先安装vuex    npm install vuex –save</strong></p>
</li>
<li><p><strong>然后在src文件夹下创建一个store文件夹，在该文件夹下创建index.js配置vuex。</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;		<span class="comment">// Vuex.Store内存储的状态(数据内容)</span></span><br><span class="line">    counter: <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;		<span class="comment">// 定义操作state的方法,这些方法中都有默认的形参,传入的就是store对象的state对象</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.counter++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.counter--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;		<span class="comment">//进行异步操作</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;		<span class="comment">// 类似于计算属性</span></span><br><span class="line">    <span class="function"><span class="title">squareofCounter</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.counter * state.counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;		<span class="comment">//划分模块</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.导出store对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>最后在main.js中导入并挂载在Vue实例中</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    // 使用$store.state.属性名来访问state</span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sub&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    // getters的使用</span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.squareofCounter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello-vuex</span>&gt;</span><span class="tag">&lt;/<span class="name">hello-vuex</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> HelloVuex <span class="keyword">from</span> <span class="string">&#x27;./components/HelloVuex&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 使用$store.commit(&#x27;方法名&#x27;)来修改state</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">sub</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;decrement&#x27;</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloVuex</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="2-2-使用vuex"><a href="#2-2-使用vuex" class="headerlink" title="2.2 使用vuex"></a>2.2 使用vuex</h4><p>通过<font color="deeppink">$store.state.状态名</font>来使用store.state内部存储的数据。</p>
<p>但是注意需要更改store.state内部的状态时：不要直接通过<font color="deeppink">$store.state.状态名</font>这种方式更改。</p>
<p>原因：</p>
<p>​        流程步骤：首先State提供状态给组件，当需要修改State时，组件先发布一个Action，然后提交到Mutations。最后再将State进行修改。<br>​        由于只有通过Mutations修改的State，此时Devtools才会记录到修改State的信息，比如谁进行了修改、修改内容是什么。此时才会让后续出错时容易查找问题出在哪儿。因此不提倡绕过Mutations直接修改<font color="deeppink">$store.state.状态名</font>的方法进行修改状态。（此外绕过Actions直接进入Mutations修改也是可以的。但是Actions可以处理异步操作。）</p>
<p>​    使用$store.commit(‘方法名’)来修改state</p>
<p><a href="https://imgchr.com/i/s9KXIf"><img src="https://s3.ax1x.com/2021/01/03/s9KXIf.png" alt="s9KXIf.png"></a></p>
<h4 id="2-3-Vuex的核心概念"><a href="#2-3-Vuex的核心概念" class="headerlink" title="2.3 Vuex的核心概念"></a>2.3 Vuex的核心概念</h4><p>vuex的核心概念包括：</p>
<ul>
<li><p>State单一状态树(用于存储状态)</p>
<p>​        单一状态树（Single Source of Truth）也可翻译为单一数据源。这个意思就是在一个项目中，只需要创建一个store对象，所以需要管理的状态都放在该对象中，不要创建多余的store对象。这样在管理时只需要去找这一个store对象就能找到你需要的状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">  counter: <span class="number">100</span>,</span><br><span class="line">  students: [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">112</span>, <span class="attr">name</span>: <span class="string">&#x27;james&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">113</span>, <span class="attr">name</span>: <span class="string">&#x27;curry&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  info: &#123;</span><br><span class="line">  name: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">    age: <span class="number">40</span>,</span><br><span class="line">  height: <span class="number">1.98</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>Getters(类似于计算属性)</li>
</ul>
<p>getters作为参数和传递参数</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// 1. getters基本使用,默认会将state作为参数传递进去</span></span><br><span class="line">  <span class="function"><span class="title">squareofCounter</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.counter * state.counter</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">more20stu</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age &gt; <span class="number">20</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 2. getters作为参数</span></span><br><span class="line">  <span class="function"><span class="title">more20stuLength</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.more20stu.length</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 3.getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</span></span><br><span class="line">  <span class="function"><span class="title">moreAgeStu</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// return function (age) &#123;</span></span><br><span class="line">    <span class="comment">//   return state.students.filter(s =&gt; s.age &gt; age)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">age</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age &gt; age)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  使用时 :</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.squareofCounter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.more20stu&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.more20stuLength&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.moreAgeStu(12)&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>


<ul>
<li>Mutations</li>
</ul>
<ol>
<li>Vuex的store状态的<strong>更新唯一方式</strong>：<strong>提交Mutations</strong></li>
<li>Mutations主要包括两部分：</li>
</ol>
<p>字符串的<strong>事件类型（type）</strong>和一个<strong>回调函数（handler）</strong>,该回调函数的第一个参数就是state。</p>
<ol start="3">
<li>Mutations的参数<br>他传入参数与getters传参不同,他<strong>只能接收两个参数</strong>。他可以直接在第一个参数state后添加一个要传入的参数,第二个参数被称为payload(负载)。这个payload分两种情况（具体看第四点）</li>
<li>Mutations的提交风格</li>
</ol>
<ul>
<li><p>普通提交风格</p>
<p>例如：this.$store.commit(‘incrementCount’, count)</p>
<pre><code>    此时传入的只能有两个值,第一个是要提交给的Mutations的函数名,第二个是传入的参数,可以是基本数据类型或对象。此时Mutations接收的参数中的payload就代表第二个传入的数据。</code></pre>
</li>
<li><p>特殊的提交风格在</p>
<p>例如：</p>
<p>this.$store.commit({</p>
<pre><code>  type: &#39;incrementCount&#39;,
  a:a,
  b:b</code></pre>
<p>})        </p>
<p>​        使用$store.commit提交时传入一个对象,这个对象的第一个属性是type其属性值为要提交给的Mutations的函数名。后边的属性是接着要传入的参数。此时Mutations接收的参数中的payload就是一个对象,该对象中存储了commit后的这个对象的所有内容。</p>
</li>
</ul>
<ol start="5">
<li>Mutations响应规则</li>
</ol>
<p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新。这就要求我们必须遵守一些Vuex对应的规则:</p>
<p><strong><font color="deeppink">提前在store中初始化好所需的属性.</font></strong></p>
<p>当给state中的对象添加新属性时, 使用下面的方式:<br>方式一: 使用Vue.set(obj, ‘newProp’, 123)<br>方式二: 用新对象给旧对象重新赋值</p>
<p>当给state中的对象删除属性时, 使用下面的方式:<br>Vue.delete(state.info, ‘age’)</p>
<p><font color="red"><strong>总结</strong></font>：Vuex的store中的state中的数据在原本就有的时候，这些数据是响应式的（因为在初始化时vue就将这些原本就有的属性加入响应式系统,响应式系统会进行监听变化,当变化时会通知界面中有用到该属性的地方进行刷新,而后添加的属性却没有加入响应式系统），自己后来添加上去的属性要使用一些方式才能是响应式的。</p>
<ol start="6">
<li>Mutations的类型常量</li>
</ol>
<p>首先在src/store文件夹下创建mutations-types.js文件。在该文件中配置Mutations的类型常量。<br>例如：export const INCREMENT = ‘increment’</p>
<p>然后在src/store的index.js中使用increment函数是写成[INCREMENT ]的形式具体看代码。并在APP.vue中向该方法传递时使用this.$store.commit(INCREMENT)</p>
<p>为什么要这么使用?<br>因为如果在配置Mutations的类型常量时出错也没关系,因为两者用的都是相同的一个常量,因此就相当于两处用的虽然都是错的,但是都是相同的不会出问题。而且在定义常量后在使用常量时编辑器会有提示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  INCREMENT</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./mutations-types&#x27;</span></span><br><span class="line"></span><br><span class="line">mutations: &#123;		<span class="comment">// 定义操作state的方法,这些方法中都有默认的形参,传入的就是store对象的state对象</span></span><br><span class="line">  <span class="comment">// 6.使用Mutations的类型常量</span></span><br><span class="line">  [INCREMENT](state) &#123;</span><br><span class="line">    state.counter++</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    state.counter--</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 接收参数</span></span><br><span class="line">  <span class="function"><span class="title">incrementCount</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(state,payload);</span></span><br><span class="line">    state.counter += payload.count</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">addStudent</span>(<span class="params">state, stu</span>)</span> &#123;</span><br><span class="line">    state.students.push(stu)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Mutations响应规则</span></span><br><span class="line">  <span class="function"><span class="title">updateInfo</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// state.info.name = &#x27;coderwhy&#x27;    // 响应式的</span></span><br><span class="line"></span><br><span class="line">    state.info[<span class="string">&#x27;address&#x27;</span>] = <span class="string">&#x27;洛杉矶&#x27;</span>    <span class="comment">// 非响应式的</span></span><br><span class="line">    <span class="comment">//Vue.set(state.info, &#x27;address&#x27;, &#x27;洛杉矶&#x27;)  // 响应式的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete state.info.age   // 非响应式的</span></span><br><span class="line">    <span class="comment">// Vue.delete(state.info, &#x27;age&#x27;)   // 响应式的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>使用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;add&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;sub&quot;</span>&gt;-&lt;/button&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;addCount(5)&quot;</span>&gt;+<span class="number">5</span>&lt;/button&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;addCount(10)&quot;</span>&gt;+<span class="number">10</span>&lt;/button&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;addStudent&quot;</span>&gt;添加学生&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mutations响应规则</span></span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.state.info&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;updateInfo&quot;</span>&gt;修改信息&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  INCREMENT</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./store/mutations-types&#x27;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 6.使用Mutations的类型常量</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(INCREMENT)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">sub</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用$store.commit(&#x27;方法名&#x27;)来修改state</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;decrement&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// payload: 负载</span></span><br><span class="line">    <span class="comment">// 1.普通的提交风格</span></span><br><span class="line">    <span class="comment">// this.$store.commit(&#x27;incrementCount&#x27;, count)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.特殊的提交风格</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">      type: <span class="string">&#x27;incrementCount&#x27;</span>,</span><br><span class="line">      count</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">addStudent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> stu = &#123;<span class="attr">id</span>: <span class="number">114</span>, <span class="attr">name</span>: <span class="string">&#x27;alan&#x27;</span>, <span class="attr">age</span>: <span class="number">35</span>&#125;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;addStudent&#x27;</span>, stu)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">updateInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this.$store.commit(&#x27;updateInfo&#x27;)</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>Action</p>
<p>​        时刻注意,不要在Mutations中进行异步操作。那样做虽然对数据存储和界面显示没有影响，但是这个时候vue的官方插件Devtools捕获不到这次操作，在Devtools界面中就会显示错误的信息。解决该问题的方法就是把异步操作放到Action中进行处理。（Action类似于Mutations, 但是是用来代替Mutations进行异步操作的.）</p>
<p>​        在使用时与Mutations类似，不同的是在Action中定义方法时他只能接收两个参数，第一个是context（context表示上下文,在这里就相当于store）第二个是payload。在使用时用$store.dispatch传入参数，他也是两个参数，第一个是要用于处理的Action中的方法名。第二个是携带的参数。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用:</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;aUpdateInfo&#x27;</span>,&#123;</span><br><span class="line">  message: <span class="string">&#x27;我是携带的信息&#x27;</span>,</span><br><span class="line">  success: <span class="function">() =&gt;</span> &#123;  <span class="comment">// 定义成功的回调</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;里面已经完成了&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义:</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// context表示上下文,在这里就相当于store</span></span><br><span class="line">  <span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context,payload</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;updateInfo&#x27;</span>)</span><br><span class="line">      <span class="comment">// console.log(payload)</span></span><br><span class="line">      <span class="built_in">console</span>.log(payload.message)</span><br><span class="line">      payload.success()  <span class="comment">// 在commit调用成功的回调</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用promise</span></span><br><span class="line"><span class="comment">// 使用:</span></span><br><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store</span><br><span class="line">    .dispatch(<span class="string">&#x27;aUpdateInfo&#x27;</span>,<span class="string">&#x27;我是携带的信息&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;		<span class="comment">//调用dispatch后因为对方return一个Promise实例,所以调用他的then方法及成功的回调函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context,payload</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;updateInfo&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(payload)</span><br><span class="line">        resolve(<span class="string">&#x27;11111&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<ul>
<li>Module</li>
</ul>
<p>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?</p>
<p>​        Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理.当应用变得非常复杂时,store对象就有可能变得相当臃肿.<br>​        为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutation、action、getters等</p>
<p>使用Module</p>
<ol>
<li>使用模块中的state<br>$store.state.模块名.属性名            例如:$store.state.a.name</li>
<li>使用模块中的mutations<br>例如:updatedName(state,payload) {state.name = payload},应参中的state仅仅表示模块中的state对象。payload表示传入的参数。在使用时是正常使用，他会在配置中循环遍历根和子模块中所有的mutations方法，只要是同名的都执行。</li>
<li>使用模块中的getters<br>和之前一样使用，但是要想访问根状态时就可在第三个参数传入rootState，这个参数就是根状态的state对象。</li>
<li>使用模块中的actions<br>此时这里面参数中的<font color="red">context</font>表示自己所处的模块，不在代表根状态整体store。并且内部还存储了一些根状态的信息。<font color="red"><strong>具体如下</strong></font>：</li>
</ol>
<p><a href="https://imgchr.com/i/s9KOdP"><img src="https://s3.ax1x.com/2021/01/03/s9KOdP.png" alt="s9KOdP.png"></a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line">modules: &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    getters: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    getters: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 细节</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.state.a.name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;updatedName&quot;</span>&gt;修改&lt;/button&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.fullname&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.fullname2&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.fullname3&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;asyncupdatedName&quot;</span>&gt;异步修改&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">updatedName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;updatedName&#x27;</span>,<span class="string">&quot;lisi&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">asyncupdatedName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;aUpdateName&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">updatedName</span>(<span class="params">state,payload</span>)</span> &#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="function"><span class="title">fullname</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.name + <span class="string">&#x27;11111&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullname2</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullname + <span class="string">&#x27;2222&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullname3</span>(<span class="params">state, getters, rootState</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullname2 + rootState.counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">aUpdateName</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(context)</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;updatedName&#x27;</span>,<span class="string">&#x27;wangwu&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modules: &#123;</span><br><span class="line">  a: moduleA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>项目结构组织</li>
</ul>
<p><a href="https://imgchr.com/i/s9Mkd0"><img src="https://s3.ax1x.com/2021/01/03/s9Mkd0.png" alt="s9Mkd0.png"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>08_axios框架</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/08-axios%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>有关JSONP去看BV1jt411j72F</p>
<h3 id="axios框架之认识axios"><a href="#axios框架之认识axios" class="headerlink" title="axios框架之认识axios"></a>axios框架之认识axios</h3><h4 id="1-选择什么网络模块"><a href="#1-选择什么网络模块" class="headerlink" title="1 选择什么网络模块"></a>1 选择什么网络模块</h4><ul>
<li>传统的Ajax是基于XMLHttpRequest(XHR)<br>不选择该方式：原因是配置和调用方式等非常混乱</li>
</ul>
<a id="more"></a>

<ul>
<li>jQuery-Ajax<br>不选择该方式：原因是没有必要为了用网络请求就引用这个重量级的框架</li>
<li>Vue-resource<br>不选择该方式：原因是作者不再维护，并且推荐使用axios</li>
<li>axios<br>axios有非常多的优点, 并且用起来也非常方便</li>
</ul>
<h4 id="2-axios的特点"><a href="#2-axios的特点" class="headerlink" title="2. axios的特点"></a>2. axios的特点</h4><ul>
<li><p>在浏览器中发送 XMLHttpRequests 请求</p>
</li>
<li><p>在 node.js 中发送 http请求</p>
</li>
<li><p>支持 Promise API</p>
</li>
<li><p>拦截请求和响应</p>
</li>
<li><p>转换请求和响应数据</p>
</li>
</ul>
<h4 id="3-使用axios"><a href="#3-使用axios" class="headerlink" title="3. 使用axios"></a>3. 使用axios</h4><p>首先安装axios框架：npm install axios –save</p>
<p>使用axios，首先他是框架与之前的vue-router、vuex插件把不同。插件在使用前必须用Vue.use安装插件。但是框架不用，使用npm安装完框架就可直接使用。</p>
<p>支持多种请求方式:</p>
<ul>
<li>axios(config)</li>
<li>axios.request(config)</li>
<li>axios.get(url[, config])</li>
<li>axios.delete(url[, config])</li>
<li>axios.head(url[, config])</li>
<li>axios.post(url[, data[, config]])</li>
<li>axios.put(url[, data[, config]])</li>
<li>axios.patch(url[, data[, config]])</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.基本使用</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://152.136.185.210:7878/api/m5/home/multidata&#x27;</span>,</span><br><span class="line">  method: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置参数信息</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://152.136.185.210:7878/api/m5/home/data&#x27;</span>,</span><br><span class="line">  method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.发送并发请求</span></span><br><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://152.136.185.210:7878/api/m5/home/multidata&#x27;</span>,</span><br><span class="line">&#125;),axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://152.136.185.210:7878/api/m5/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;sell&#x27;</span>,</span><br><span class="line">    page: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread(<span class="function">(<span class="params">res1,res2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局配置</span></span><br><span class="line"><span class="comment">// 原因:在开发中很多参数都是固定的,此时就需要抽取这些参数.此时就用到了axios的全局配置</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://152.136.185.210:7878/api/m5&#x27;</span></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<p>常见的配置选项：</p>
<p><a href="https://imgchr.com/i/s9MJJO"><img src="https://s3.ax1x.com/2021/01/03/s9MJJO.png" alt="s9MJJO.png"></a></p>
<h4 id="4-axios实例"><a href="#4-axios实例" class="headerlink" title="4. axios实例"></a>4. axios实例</h4><p>​        前面的代码都是在使用全局的axios和对应的配置在进行网络请求，在现实中是不会这样做的。因为有可能每个功能需要访问的服务端地址不一样，这样就需要创建出不同的axios实例来处理不同的需求等等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.创建axios实例</span></span><br><span class="line"><span class="keyword">const</span> instance1 = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;http://152.136.185.210:7878/api/m5&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当出现需要访问的服务端地址不同时,此时就在创建一个新的实例即可</span></span><br><span class="line"><span class="keyword">const</span> instance1 = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;http://222.111.33.33:8000&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)js</span><br></pre></td></tr></table></figure>


<h4 id="5-网络模块封装的重要性"><a href="#5-网络模块封装的重要性" class="headerlink" title="5. 网络模块封装的重要性"></a><font color="red">5. 网络模块封装的重要性</font></h4><p><strong><font color="deeppink">具体怎么一步步实现去看BV15741177Eh?p=146</font></strong></p>
<p>​        在选择使用网络模块时,一定要对其封装后再使用。原因是第三方的网络模块是有可能出现一些bug或者突然间不再维护。此时就得更换所选用的第三方模块。此时模块的封装就显得尤为重要。封装或进行模块的切换就变得容易许多。</p>
<p>​        封装方法：<br>​        首先在src文件夹下创建一个network文件用于存放网络层的封装。然后在内部创建对应模块的封装js文件。</p>
<p>​        然后在内部想方法让其return出去一个promise对象即可。在使用时直接调用then和catch方法去做回调。当第三方库出现问题后直接修改该文件,将改用的另一种第三方库也返回一个promise对象即可。</p>
<p>src/network/request.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://152.136.185.210:7878/api/m5&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.axios拦截器interceptors</span></span><br><span class="line">  <span class="comment">// 2.1.请求拦截的作用</span></span><br><span class="line">  <span class="comment">// 如果是axios调用interceptors则表示全局拦截即谁调用interceptors就会在那个作用域拦截</span></span><br><span class="line">  <span class="comment">// 这里是instance调用的interceptors则表示这个模块内的拦截</span></span><br><span class="line">  <span class="comment">// request表示请求的拦截   response表示响应的拦截 </span></span><br><span class="line">  instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在请求成功的拦截中经常进行以下操作</span></span><br><span class="line">    <span class="comment">// 1.比如config中的一些信息不符合服务器的要求</span></span><br><span class="line">    <span class="comment">// 2.比如每次发送网络请求时, 都希望在界面中显示一个请求的图标</span></span><br><span class="line">    <span class="comment">// 3.某些网络请求(比如登录(token)), 必须携带一些特殊的信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(config)  <span class="comment">// 这个config对象内存储的就是发送请求的配置信息</span></span><br><span class="line">    <span class="comment">// 记住拦截后要使用return config放行,不然后续就被禁止了</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2.响应拦截</span></span><br><span class="line">  instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(res);  // 这个res就是服务器返回的具体数据信息</span></span><br><span class="line">    <span class="comment">// 记住拦截后要使用return放行,不然后续就被禁止了</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3.发送真正请求</span></span><br><span class="line">  <span class="keyword">return</span> instance(config) <span class="comment">// 这里instance调用后可以使用then和catch方法,证明在源码中他返回的是一个promise对象,直接把他return出去,使用后就可以直接调用then和catch方法去做回调.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当第三方库出现问题后直接修改该文件,将改用的另一种第三方库也返回一个promise对象即可.</span></span><br></pre></td></tr></table></figure>
<p>此时在使用时就这样使用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&#x27;./network/request.js&#x27;</span></span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="6-axios拦截器的使用"><a href="#6-axios拦截器的使用" class="headerlink" title="6. axios拦截器的使用"></a>6. axios拦截器的使用</h4><p> axios拦截器包括四种拦截器：</p>
<ul>
<li>请求成功与失败的拦截<br>需要拦截的axios实例.interceptors.request.use()<br>内部参数为两个函数第一个为成功的函数第二个为失败的函数</li>
<li>响应成功与失败的拦截<br>需要拦截的axios实例.interceptors.response.use()</li>
</ul>
<p>具体代码请看上一步的网络模块封装中。</p>
<h5 id="请求成功与失败的拦截"><a href="#请求成功与失败的拦截" class="headerlink" title="请求成功与失败的拦截"></a>请求成功与失败的拦截</h5><p>如果是axios调用interceptors则表示全局拦截即谁调用interceptors就会在那个作用域拦截<br>这里是instance调用的interceptors则表示这个模块内的拦截<br>request表示请求的拦截   response表示响应的拦截 </p>
<p>在请求成功的拦截中经常进行以下操作<br> 1.比如config中的一些信息不符合服务器的要求<br> 2.比如每次发送网络请求时, 都希望在界面中显示一个请求的图标<br> 3.某些网络请求(比如登录(token)), 必须携带一些特殊的信息</p>
<p>记住拦截后要使用return config放行,不然后续就被禁止了</p>
<p>这个config对象内存储的就是发送请求的配置信息</p>
<p>请求拦截中的config对象</p>
<p><a href="https://imgchr.com/i/s9MGFK"><img src="https://s3.ax1x.com/2021/01/03/s9MGFK.png" alt="s9MGFK.png"></a></p>
<h5 id="响应成功与失败的拦截"><a href="#响应成功与失败的拦截" class="headerlink" title="响应成功与失败的拦截"></a>响应成功与失败的拦截</h5><p>这个res就是服务器返回的具体数据信息</p>
<p>记住拦截后要使用return放行,不然后续就被禁止了（比如后续的then操作）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>01_初识Vue</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/01-%E5%88%9D%E8%AF%86Vue/</url>
    <content><![CDATA[<h2 id="Vue渐进式的框架-声明式编程"><a href="#Vue渐进式的框架-声明式编程" class="headerlink" title="Vue渐进式的框架(声明式编程)"></a>Vue渐进式的框架(声明式编程)</h2><h3 id="什么是渐进式"><a href="#什么是渐进式" class="headerlink" title="什么是渐进式"></a>什么是渐进式</h3><p>​        渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验。</p>
<p>​        或者如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统。</p>
<p>​        比如Core+Vue-router+Vuex，也可以满足你各种各样的需求。</p>
<a id="more"></a>



<p><strong>JavaScript是命令式编程，Vue是声明式编程</strong></p>
<h3 id="Vue有很多特点和Web开发中常见的高级功能"><a href="#Vue有很多特点和Web开发中常见的高级功能" class="headerlink" title="Vue有很多特点和Web开发中常见的高级功能"></a>Vue有很多特点和Web开发中常见的高级功能</h3><p>解耦视图和数据</p>
<p>可复用的组件</p>
<p>前端路由技术</p>
<p>状态管理</p>
<p>虚拟DOM</p>
<h3 id="安装Vue"><a href="#安装Vue" class="headerlink" title="安装Vue"></a>安装Vue</h3><ul>
<li>CDN引入</li>
<li>下载引入</li>
<li>npm安装</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
<p>16</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>06_Vue-router路由插件</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/06-Vue-router%E8%B7%AF%E7%94%B1%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1. 什么是路由?"></a>1. 什么是路由?</h2><h3 id="1-1-认识路由"><a href="#1-1-认识路由" class="headerlink" title="1.1 认识路由"></a>1.1 认识路由</h3><p>路由(routing)就是通过互联的网络把信息从源地址传输到目的地址的活动</p>
<ul>
<li>路由器提供了两种机制: 路由和转送.<ul>
<li>路由是决定数据包从<strong>来源</strong>到<strong>目的地</strong>的路径.</li>
<li>转送将<strong>输入端</strong>的数据转移到合适的<strong>输出端</strong>.</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li>路由中有一个非常重要的概念叫路由表.<ul>
<li>路由表本质上就是一个映射表, 决定了数据包的指向</li>
</ul>
</li>
</ul>
<p><a href="https://imgchr.com/i/s9ikad"><img src="https://s3.ax1x.com/2021/01/03/s9ikad.png" alt="s9ikad.png"></a></p>
<h3 id="1-2-前端路由的发展"><a href="#1-2-前端路由的发展" class="headerlink" title="1.2 前端路由的发展"></a>1.2 前端路由的发展</h3><h4 id="1-2-1-后端路由-后端渲染"><a href="#1-2-1-后端路由-后端渲染" class="headerlink" title="1.2.1 后端路由(后端渲染)"></a><font color="red">1.2.1 后端路由(后端渲染)</font></h4><h5 id="后端路由简介"><a href="#后端路由简介" class="headerlink" title="后端路由简介"></a>后端路由简介</h5><p>​        早期在开发网页时是通过jsp(Java Server Pages)/php开发的。（没有AJAX）<br>​        通常是浏览器将url发送到服务器，浏览器拿到以后进行解析，然后将其解析出对应的页面，在后端就用jsp将页面写好(html+css+java(java用来获取数据并将其动态渲染在页面))。然后将该页面发送到浏览器（仅发送html+css）。<font color="blue">这种方式就是后端渲染（服务端渲染）。</font>当用户点击跳转页面时，又会重复上述操作，再次将后端写好的页面发送到浏览器端。<font color="deeppink"><strong>总结：服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示。</strong></font></p>
<ul>
<li><p>一个页面有自己对应的网址, 也就是URL.</p>
</li>
<li><p>URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理.</p>
</li>
<li><p>Controller进行各种处理, 最终生成HTML或者数据, 返回给前端.</p>
</li>
<li><p>这就完成了一个IO操作.</p>
<p>​    此时，在后端总就存在一个类似于映射表。该映射表存储的就是每个url所对应的页面，<font color="red">这种映射关系就叫做后端路由</font>。</p>
</li>
</ul>
<h5 id="后端路由的优点"><a href="#后端路由的优点" class="headerlink" title="后端路由的优点:"></a><strong><font color="red">后端路由的优点:</font></strong></h5><p>​        这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化.</p>
<h5 id="后端路由的缺点"><a href="#后端路由的缺点" class="headerlink" title="后端路由的缺点:"></a><strong><font color="red">后端路由的缺点:</font></strong></h5><ul>
<li><p>一种情况是整个页面的模块由后端人员来编写和维护的.</p>
</li>
<li><p>另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码.</p>
</li>
<li><p>而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情.（耦合性太高）</p>
</li>
</ul>
<p><a href="https://imgchr.com/i/s9iPqe"><img src="https://s3.ax1x.com/2021/01/03/s9iPqe.png" alt="s9iPqe.png"></a></p>
<h4 id="1-2-2-前后端分离（前端渲染）"><a href="#1-2-2-前后端分离（前端渲染）" class="headerlink" title="1.2.2 前后端分离（前端渲染）"></a><font color="red">1.2.2 前后端分离（前端渲染）</font></h4><h5 id="前后端分离简介"><a href="#前后端分离简介" class="headerlink" title="前后端分离简介"></a>前后端分离简介</h5><p>​        由于AJAX的出现，后端只负责提供数据，不负责任何阶段的内容。</p>
<p>​        通常是浏览器将url发送到静态资源服务器（内部存储各个不同页面对应的一套html+css+js），浏览器从静态服务器拿到html+css+js，浏览器直接渲染html和css，并且js代码在浏览器中执行。在js中的<font color="blue">AJAX请求即API接口</font>，然后从提供接口的服务器中获得数据，然后按照其他的js代码将其插入到DOM树中。</p>
<p><font color="red">前端渲染</font>：浏览器中显示网页中大部分内容，都是由前端写的js代码在浏览器中执行，最终渲染出来的网页。</p>
<p><a href="https://imgchr.com/i/s9iFVH"><img src="https://s3.ax1x.com/2021/01/03/s9iFVH.png" alt="s9iFVH.png"></a></p>
<h5 id="前后端分离优点"><a href="#前后端分离优点" class="headerlink" title="前后端分离优点"></a><font color="red">前后端分离优点</font></h5><ul>
<li><p>前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上.</p>
</li>
<li><p><font color="cornflowerblue">并且当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可.</font></p>
</li>
</ul>
<h4 id="1-2-3-SPA-单页面富应用-阶段-（前端路由）"><a href="#1-2-3-SPA-单页面富应用-阶段-（前端路由）" class="headerlink" title="1.2.3 SPA(单页面富应用)阶段  （前端路由）"></a><font color="red">1.2.3 SPA(单页面富应用)阶段  （前端路由）</font></h4><h5 id="SPA简介"><a href="#SPA简介" class="headerlink" title="SPA简介"></a>SPA简介</h5><p>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由<br>也就是前端来维护一套路由规则</p>
<p><font color="blue"><strong>整个网站只有一个html页面</strong></font></p>
<p>​        浏览器将url发送到静态资源服务器（之前内部存储的是不同页面有对应的一套html+css+js<strong>现在只有一个html一个css和一个js</strong>），浏览器从静态服务器拿到<strong>全部的html+css+js资源</strong>，当用户点击时，url发生改变，但是页面不会跳转而是会向<strong>前端路由</strong>中查找url对应的组件将页面进行更改渲染。</p>
<p>此时前端路由就是该功能的支撑：<font color="red">前端路由会映射url与其对应组件的关系。</font></p>
<p><a href="https://imgchr.com/i/s9iVPI"><img src="https://s3.ax1x.com/2021/01/03/s9iVPI.png" alt="s9iVPI.png"></a></p>
<p><font color="deeppink"><strong>改变url不会刷新页面向服务器发送请求的几种方式：</strong></font></p>
<ul>
<li>改变location.hash</li>
<li>h5中提出的history.pushState({},’’,’url’)    将这些url压入到栈中(浏览器历史记录)    使用history.back()会回退一次历史记录    使用history.forward()会前进一次历史记录</li>
<li>history.replaceState({},’’,’url’)   这种方式是直接替换url不会保存浏览历史记录</li>
<li>history.go(num)配合history.pushState使用，传入的数字为负数是回退的记录个数，正数是前进几个记录</li>
</ul>
<h2 id="2-vue-router"><a href="#2-vue-router" class="headerlink" title="2. vue-router"></a>2. vue-router</h2><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h3><p>第一步：安装</p>
<p>npm install vue-router –save（在使用脚手架创建项目时选用过，就不用再安装了）</p>
<p>第二步：在模块化工程中使用它（）</p>
<ol>
<li>通过Vue.use(插件)，安装插件</li>
<li>创建VueRouter对象，在该对象中使用其routes属性设置路由的映射关系（他是一个数组，内部存入一个一个对象）使用path属性设置对应的组件路径，使用component属性设置对应的组件名称</li>
<li>将router对象挂载在Vue实例中</li>
<li>使用路由: 通过&lt;router-link&gt;（显示标签，to属性表示要显示的组件）和&lt;router-view&gt;（占位符）</li>
<li>修改路由的默认值（使用redirect重定向）和history模式（默认是改变hash）（在路由的配置中设置mode: “history”）</li>
<li><ol>
<li> router-link的tag属性改变该标签的渲染模式（默认是a标签）</li>
<li> replace属性,将其设置为replace(即没有历史记录)</li>
<li> 当router-link处于活跃的状态(被点击后)则该标签会被加上两个class属性即router-link-exact-active和router-link-active。改变router-link-active的写法就使用active-class属性改为自己想要的值。或者在路由的配置文件中设置linkActiveClass: ‘active’统一设置所有的router-link-active的写法</li>
</ol>
</li>
<li>不使用router-link使用html标签来实现对应的功能：使用this.$router.push或this.$router.replace实现点击后的页面变化功能。<br>注意此时会出现连续点击报错问题，此时就添加一层判断即可。</li>
</ol>
<ul>
<li>在index.js文件中注册并配置路由：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../components/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../components/About.vue&#x27;</span></span><br><span class="line"><span class="comment">// 1.通过Vue.use(插件),安装插件</span></span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="comment">// 2.创建VueRouter对象，并配置路由</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// redirect重定向</span></span><br><span class="line">    redirect: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 配置路由和组件之间的应用关系</span></span><br><span class="line">  routes,</span><br><span class="line">  <span class="comment">// 使用history模式</span></span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="comment">// 使用linkActiveClas统一设置所有的router-link-active的写法</span></span><br><span class="line">  linkActiveClass: <span class="string">&#x27;active&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3.将router对象传入Vue实例中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<ul>
<li>在App.vue文件中使用：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用tag将渲染模式变为button --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用active-class修改router-link-active的写法 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用html标签代替router-link写法 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;homeClick&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;aboutClick&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 使用this.$router.push或this.$router.replace实现</span></span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">homeClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(&#x27;111&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&#x27;/home&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.replace(&#x27;/home&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 处理连续点击报错问题</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(<span class="built_in">this</span>.$route.path !== <span class="string">&#x27;/home/news&#x27;</span>)&#123;   </span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/home/news&#x27;</span>)  </span></span><br><span class="line">      &#125; </span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">aboutClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(&#x27;222&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&#x27;/about&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.replace(&#x27;/about&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(<span class="built_in">this</span>.$route.path !== <span class="string">&#x27;/about&#x27;</span>)&#123;   </span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/about&#x27;</span>)  </span></span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="2-2-动态路由"><a href="#2-2-动态路由" class="headerlink" title="2.2 动态路由"></a>2.2 动态路由</h3><p>案例进入到用户界面后再url后加上用户对应的信息。</p>
<p>实现：首先在user组件中设置对应界面，然后在路由配置中添加该页面的配置，其中path属性值设置为“/user/:abc”其中:abc表示要动态显示的路径。然后在App.vue中设置router-link，将to属性动态绑定为：”‘/user/‘+userId”（<strong>此时就把userId这个数据携带着传递到了user组件中</strong>（$route.params.abc））。当要在user组件显示App.vue中的数据时使用$route.params.abc这里的abc与配置路由时的abc是对应的。</p>
<p>$route.params是一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。<br>在这里打印$route.params的结果是{abc: “zhangsan”}。</p>
<p>注意：$router与$route</p>
<ul>
<li><p><strong>this.$router</strong></p>
<p>表示router 实例。</p>
</li>
<li><p><strong>this.$route</strong></p>
<p>当前激活的路由信息对象。这个属性是只读的，里面的属性是 immutable (不可变) 的，不过你可以 watch (监测变化) 它。</p>
</li>
</ul>
<p>路由配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../components/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../components/About.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;../components/User.vue&#x27;</span></span><br><span class="line"><span class="comment">// 1.通过Vue.use(插件),安装插件，此时原码会指向Router.install去安装该插件</span></span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="comment">// 2.创建VueRouter对象</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    redirect: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 配置动态路由,此时就相当于在$route.params中添加了一个属性名为abc</span></span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/user/:abc&#x27;</span>,</span><br><span class="line">    component: User</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 配置路由和组件之间的应用关系</span></span><br><span class="line">  routes,</span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  linkActiveClass: <span class="string">&#x27;active&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3.将router对象传入Vue实例中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<p>App.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此时就携带着userId这个数据传递给了$route.params.abc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#x27;/user/&#x27;+userId&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> &gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      userId: <span class="string">&#x27;zhangsan&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;lisi&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.active</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#bfa</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>User.vue:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是用户界面<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是&#123;&#123;userName&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是&#123;&#123;$route.params.abc&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;test&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&quot;User&quot;</span>,</span></span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">userName</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.$route.params.abc</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.params)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>  <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2-3-路由懒加载"><a href="#2-3-路由懒加载" class="headerlink" title="2.3 路由懒加载"></a>2.3 路由懒加载</h3><h4 id="2-3-1-使用懒加载的原因"><a href="#2-3-1-使用懒加载的原因" class="headerlink" title="2.3.1 使用懒加载的原因"></a>2.3.1 使用懒加载的原因</h4><ul>
<li><p>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。</p>
</li>
<li><p>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了</p>
</li>
</ul>
<h4 id="2-3-2-路由懒加载都做了什么"><a href="#2-3-2-路由懒加载都做了什么" class="headerlink" title="2.3.2 路由懒加载都做了什么"></a>2.3.2 路由懒加载都做了什么</h4><ul>
<li><p>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块.</p>
</li>
<li><p>只有在这个路由被访问到的时候, 才加载对应的组件</p>
</li>
</ul>
<p>​        之前不进行路由懒加载时：在将项目进行打包后，js文件会有三个。其中包括<strong>appxxx.js</strong>（项目逻辑代码）、<strong>mainfestxxx.js（</strong>底层支撑，例如es6转es5，模块化转换等）和<strong>venderxxx.js</strong>（第三方相关，例如vue，vue-router）。<br>​        当项目开发时，<strong>appxxx.js</strong>（项目逻辑代码）这个文件中的代码会越来越大，当用户第一次访问时会一次性的将上述的三个文件请求到本地。此时会出现界面空白的现象，使得用户体验差。<br>此时就需要用到路由懒加载就会将每个路由都分别打包到不同的js文件中，当用户访问时，仅会将需要的对应文件请求到本地。</p>
<h4 id="2-3-3-路由懒加载使用"><a href="#2-3-3-路由懒加载使用" class="headerlink" title="2.3.3 路由懒加载使用"></a>2.3.3 路由懒加载使用</h4><ul>
<li><p>方式一: 结合Vue的异步组件和Webpack的代码分析<br>nconst Home = resolve =&gt; { require.ensure([‘../components/Home.vue’], () =&gt; { resolve(require(‘../components/Home.vue’)) })};</p>
</li>
<li><p>方式二: AMD写法<br>const About = resolve =&gt; require([‘../components/About.vue’], resolve);</p>
</li>
<li><p><font color="red"><strong>方式三</strong></font>: 在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割</p>
<p>const Home = () =&gt; import(‘../components/Home.vue’)</p>
</li>
</ul>
<h3 id="2-4-vue-router嵌套路由"><a href="#2-4-vue-router嵌套路由" class="headerlink" title="2.4. vue-router嵌套路由"></a>2.4. vue-router嵌套路由</h3><p>第一步：创建子组件，子组件正常编写。</p>
<p><a href="https://imgchr.com/i/s9iAIA"><img src="https://s3.ax1x.com/2021/01/03/s9iAIA.png" alt="s9iAIA.png"></a></p>
<p>第二步：在父组件中使用router-link标签将子组件挂载，并使用router-view标签处理显示位置。</p>
<p><a href="https://imgchr.com/i/s9VHr6"><img src="https://s3.ax1x.com/2021/01/03/s9VHr6.png" alt="s9VHr6.png"></a></p>
<p>第三步：在路由配置文件中使用children属性配置子路由。<br>        <font color="red">在这里注意写路径时前面不要加斜杠。</font></p>
<p><a href="https://imgchr.com/i/s9VbqK"><img src="https://s3.ax1x.com/2021/01/03/s9VbqK.png" alt="s9VbqK.png"></a></p>
<p>第四步：设置嵌套路由的默认选项。</p>
<p><a href="https://imgchr.com/i/s9VLVO"><img src="https://s3.ax1x.com/2021/01/03/s9VLVO.png" alt="s9VLVO.png"></a></p>
<h3 id="2-5-vue-router参数传递"><a href="#2-5-vue-router参数传递" class="headerlink" title="2.5. vue-router参数传递"></a>2.5. vue-router参数传递</h3><h4 id="2-5-1-传递参数主要有两种方式"><a href="#2-5-1-传递参数主要有两种方式" class="headerlink" title="2.5.1 传递参数主要有两种方式"></a>2.5.1 传递参数主要有两种方式</h4><p>params(parameter参数)和query</p>
<ul>
<li>**params的类型:**（适用于数据少的时候）<br>配置路由格式: /router/:id<br>传递的方式: 在path后面跟上对应的值<br>传递后形成的路径: /router/123, /router/abc</li>
</ul>
<p><a href="https://imgchr.com/i/s9V7Kx"><img src="https://s3.ax1x.com/2021/01/03/s9V7Kx.png" alt="s9V7Kx.png"></a></p>
<ul>
<li>**query的类型:**（适用于数据多的时候）<br>配置路由格式: /router, 也就是普通配置<br>传递的方式: 对象中使用query的key作为传递方式<br>传递后形成的路径: /router?id=123, /router?id=abc</li>
</ul>
<p><a href="https://imgchr.com/i/s9Vox1"><img src="https://s3.ax1x.com/2021/01/03/s9Vox1.png" alt="s9Vox1.png"></a></p>
<p><font color="red">params与query的区别:</font><br>query要使用path来引入，params要使用name来引入，接受参数类似，分别是this.$route.query.name和this.$route.params.name</p>
<p><font color="red"><strong>URL的组成：协议(scheme)+服务器地址(host)+端口(默认是80不写)+路径(path)+?查询(query)+#片段hash值(fragment)</strong></font></p>
<p><a href="https://imgchr.com/i/s9ZBdO"><img src="https://s3.ax1x.com/2021/01/03/s9ZBdO.png" alt="s9ZBdO.png"></a></p>
<h5 id="传递参数的两种方式"><a href="#传递参数的两种方式" class="headerlink" title="传递参数的两种方式"></a><font color="cornflowerblue">传递参数的两种方式</font></h5><ul>
<li>方式一:  使用&lt;router-link&gt;</li>
</ul>
<p><a href="https://imgchr.com/i/s9Z6Wd"><img src="https://s3.ax1x.com/2021/01/03/s9Z6Wd.png" alt="s9Z6Wd.png"></a></p>
<ul>
<li>方式二:  <strong>使用JavaScript代码</strong>(不使用router-link使用button并监听点击)<br>注意这里也会出现连续点击报错问题，添加一层判断即可</li>
</ul>
<p><a href="https://imgchr.com/i/s9ZsFe"><img src="https://s3.ax1x.com/2021/01/03/s9ZsFe.png" alt="s9ZsFe.png"></a></p>
<h5 id="获取参数方式"><a href="#获取参数方式" class="headerlink" title="获取参数方式:"></a><font color="cornflowerblue">获取参数方式:</font></h5><ul>
<li>获取参数通过$route对象获取的.<ul>
<li>在使用了 vue-router 的应用中，路由对象会被注入每个组件中，赋值为 this.$route ，并且当路由切换时，路由对象会被更新</li>
</ul>
</li>
<li>通过$route获取传递的信息如下:</li>
</ul>
<p><a href="https://imgchr.com/i/s9ZDoD"><img src="https://s3.ax1x.com/2021/01/03/s9ZDoD.png" alt="s9ZDoD.png"></a></p>
<h4 id="2-5-2-route和-router的区别"><a href="#2-5-2-route和-router的区别" class="headerlink" title="2.5.2 $route和$router的区别"></a>2.5.2 $route和$router的区别</h4><ul>
<li><p>$router就是VueRouter实例。想要导航到不同URL，则使用$router.push方法</p>
</li>
<li><p>$route为配置的路由中，当前处于活跃的路由（router跳转的路由对象）。里面可以获取name、path、query、params等 </p>
</li>
</ul>
<p><a href="https://imgchr.com/i/s9ZyJH"><img src="https://s3.ax1x.com/2021/01/03/s9ZyJH.png" alt="s9ZyJH.png"></a></p>
<p><font color="red">$route和$router都是通过添加到vue的原型中的，所以所有vue的实例都可以访问到$route和$router。</font></p>
<h3 id="2-6-vue-router导航守卫"><a href="#2-6-vue-router导航守卫" class="headerlink" title="2.6. vue-router导航守卫"></a>2.6. vue-router导航守卫</h3><p><font color="deeppink"><strong>导航守卫用于在路由中来回跳转时调用的回调函数。</strong></font></p>
<h4 id="2-6-1-首先了解几个生命周期函数"><a href="#2-6-1-首先了解几个生命周期函数" class="headerlink" title="2.6.1 首先了解几个生命周期函数"></a><font color="red"><strong>2.6.1 首先了解几个生命周期函数</strong></font></h4><p>created回调函数：在组件被创建后会被调用<br>mounted回调函数：当组件中的模板被挂载到DOM中时被调用<br>updated回调函数：当界面发生更新时被调用<br>destroyed回调函数：当组件被销毁时被调用</p>
<h4 id="2-6-2-案例需求：当点击跳转到不同的界面时，页面的title会随之改变。"><a href="#2-6-2-案例需求：当点击跳转到不同的界面时，页面的title会随之改变。" class="headerlink" title="2.6.2 案例需求：当点击跳转到不同的界面时，页面的title会随之改变。"></a><strong>2.6.2 案例需求：当点击跳转到不同的界面时，页面的title会随之改变。</strong></h4><p>实现方案一：</p>
<p>利用生命周期的created回调函数实现。（document.title = ‘关于’）</p>
<p>问题：实现时要更改多个页面中的代码</p>
<p>实现方案二：</p>
<p>使用vue-router全局导航守卫<br>        router.beforeEach方法（被称为前置守卫即钩子<font color="red">在跳转前回调</font>），参数为一个函数，该函数中有三个参数，分别是to(route类型)、from(route类型)和next(函数类型)。使用该方法时内部必须调用next函数。不调用会导致点击后再也无法跳转。可以在路由中添加一个meta属性**<font color="cornflowerblue">meta表示元数据（描述数据的数据）</font>**，将数据保存在该对象中。</p>
<p><a href="https://imgchr.com/i/s9nPqx"><img src="https://s3.ax1x.com/2021/01/03/s9nPqx.png" alt="s9nPqx.png"></a></p>
<p><a href="https://imgchr.com/i/s9nCs1"><img src="https://s3.ax1x.com/2021/01/03/s9nCs1.png" alt="s9nCs1.png"></a></p>
<p><strong><font color="red">注意：to是一个对象，其中有一个matched数组，包含当前路由的所有嵌套路径片段的路由记录</font></strong></p>
<p><a href="https://imgchr.com/i/s9n0e0"><img src="https://s3.ax1x.com/2021/01/03/s9n0e0.png" alt="s9n0e0.png"></a></p>
<h4 id="2-6-3-导航守卫的补充"><a href="#2-6-3-导航守卫的补充" class="headerlink" title="2.6.3 导航守卫的补充"></a>2.6.3 导航守卫的补充</h4><ul>
<li>router.afterFach    <font color="red">在跳转后回调</font><br>需要传入一个函数，该函数有两个参数：to和from。因为他是在跳转后回调所以就没有next参数。</li>
</ul>
<p>router.beforeEach和router.afterFach被称为<font color="blue">全局守卫</font>，</p>
<ul>
<li><font color="deeppink"><strong>全局守卫</strong></font></li>
</ul>
<p><a href="https://imgchr.com/i/s9n9MR"><img src="https://s3.ax1x.com/2021/01/03/s9n9MR.png" alt="s9n9MR.png"></a></p>
<p><a href="https://imgchr.com/i/s9nSz9"><img src="https://s3.ax1x.com/2021/01/03/s9nSz9.png" alt="s9nSz9.png"></a></p>
<ul>
<li><font color="deeppink"><strong>组件内守卫</strong></font></li>
</ul>
<p><a href="https://imgchr.com/i/s9nyYF"><img src="https://s3.ax1x.com/2021/01/03/s9nyYF.png" alt="s9nyYF.png"></a></p>
<p><a href="https://imgchr.com/i/s9n6W4"><img src="https://s3.ax1x.com/2021/01/03/s9n6W4.png" alt="s9n6W4.png"></a></p>
<ul>
<li><font color="deeppink"><strong>路由独享守卫</strong></font></li>
</ul>
<p><a href="https://imgchr.com/i/s9ngSJ"><img src="https://s3.ax1x.com/2021/01/03/s9ngSJ.png" alt="s9ngSJ.png"></a></p>
<p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">路由守卫官方文档</a></p>
<p><a href="https://www.cnblogs.com/johnjackson/p/11044658.html">钩子与回调的区别</a></p>
<p>钩子函数在捕获消息的第一时间就执行，而回调函数是捕获结束时，最后一个被执行的。</p>
<h3 id="2-7-keep-alive"><a href="#2-7-keep-alive" class="headerlink" title="2.7. keep-alive"></a>2.7. keep-alive</h3><h4 id="2-7-1-首先理解Vue生命周期"><a href="#2-7-1-首先理解Vue生命周期" class="headerlink" title="2.7.1 首先理解Vue生命周期"></a><font color="red">2.7.1 首先理解Vue生命周期</font></h4><p><a href="https://www.cnblogs.com/caoyi/p/11356500.html">Vue生命周期详解</a></p>
<p><a href="https://imgchr.com/i/s9n2l9"><img src="https://s3.ax1x.com/2021/01/03/s9n2l9.png" alt="s9n2l9.png"></a></p>
<h4 id="2-7-2-案例需求："><a href="#2-7-2-案例需求：" class="headerlink" title="2.7.2 案例需求："></a>2.7.2 案例需求：</h4><p>当在主页中点击消息列表，当切换到其他路由后，再回到主页路由后将其保留之前显示的消息列表。</p>
<ul>
<li>原因：当切换路由会之前的组件会被销毁，所以在回到之前的路由时会重新创建一个新的组件。</li>
</ul>
<ul>
<li><font color="red">解决方案：使用keep-alive配合守卫</font><br>直接使用keep-alive无法完成是因为存在重定向。<pre><code>    首先在App.vue中使用keep-alive将router-view包裹，然后把路由配置中的默认路由删除，再配置Home.vue文件。其中在data中放入一个变量用来存储每次切换时首页的路径，然后使用beforeRouteLeave守卫回调更改切换前首页路径状态并更改data的值。当切换回首页时，由于首页依旧存活，可以使用activated（组件活跃回调）将路径改为data的值。</code></pre>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是首页,哈哈哈<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home/news&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home/message&quot;</span>&gt;</span>消息<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&quot;Vue&quot;</span>,</span></span><br><span class="line">    data ()&#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        path: <span class="string">&#x27;/home/news&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 使用created生命周期回调函数解决问题</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// created() &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   document.title = &#x27;首页&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line">    /* created() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;home created&quot;</span>),</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/home/news&#x27;</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;home destroyed&quot;</span>)</span></span><br><span class="line">    &#125; */</span><br><span class="line"><span class="javascript">    <span class="comment">// 当切换回首页时，由于首页依旧存活，可以使用activated（组件活跃回调）将路径改为data的值。</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">activated</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.push(<span class="built_in">this</span>.path)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    /* deactivated() &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// deactivated记录的是活跃的路由</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.path)</span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.path = this.$route.path</span></span></span><br><span class="line">    &#125;, */</span><br><span class="line"><span class="javascript">    <span class="comment">// 使用beforeRouteLeave守卫回调更改切换前首页路径状态并更改data的值</span></span></span><br><span class="line"><span class="javascript">    beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.path)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.path = <span class="built_in">this</span>.$route.path</span></span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>  <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="2-7-3-keep-alive总结"><a href="#2-7-3-keep-alive总结" class="headerlink" title="2.7.3 keep-alive总结"></a>2.7.3 keep-alive总结</h4><p>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：</p>
<p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。keep-alive会缓存，生命周期不会重新执行</p>
<p>它们有两个非常重要的属性:</p>
<ul>
<li><p>pinclude - 字符串或正则表达，只有匹配的组件会被缓存</p>
</li>
<li><p>pexclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</p>
</li>
</ul>
<p><strong>activated和deactivated</strong>这两个回调是<strong>只有在当组件在keep-alive中时（保持了状态）</strong>（否则执行的就是销毁回调了），当组件处于活跃中时调用前者，不活跃时调用后者。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue实现悬浮窗拖拽和靠边隐藏</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/%E6%8B%96%E6%8B%BD/%E9%9D%A0%E8%BE%B9%E9%9A%90%E8%97%8F/vue/10-vue%E4%B9%8B%E6%8B%96%E6%8B%BD%E7%BB%84%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="vue实现悬浮窗拖拽和靠边隐藏"><a href="#vue实现悬浮窗拖拽和靠边隐藏" class="headerlink" title="vue实现悬浮窗拖拽和靠边隐藏"></a>vue实现悬浮窗拖拽和靠边隐藏</h2><h3 id="预览"><a href="#预览" class="headerlink" title="预览"></a>预览</h3><p><img src="https://img-blog.csdnimg.cn/20201123134935741.gif#pic_center"></p>
<h3 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h3><a id="more"></a>

<p>Drag.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;outBox&quot;</span>&gt;</span></span><br><span class="line">    &lt;div</span><br><span class="line">      :class=&quot;[&#x27;suspendBox&#x27;, &#123; move: !canDrag &#125;]&quot;</span><br><span class="line">      :style=&quot;&#123;top:top+&#x27;px&#x27;,left:left+&#x27;px&#x27;&#125;&quot;</span><br><span class="line">      @mousedown=&quot;start&quot;</span><br><span class="line">      @mousemove=&quot;move&quot;</span><br><span class="line">      @mouseup=&quot;stop&quot;</span><br><span class="line">      @mouseenter=&quot;enter&quot;</span><br><span class="line">      @mouseleave=&quot;leave&quot;</span><br><span class="line">    &gt;</span><br><span class="line">      <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  props:&#123;</span><br><span class="line"><span class="javascript">    ableMove: &#123;<span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">true</span>&#125;,  <span class="comment">//是否可移动</span></span></span><br><span class="line"><span class="javascript">    ableHide: &#123;<span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">true</span>&#125;,  <span class="comment">//是否靠边隐藏</span></span></span><br><span class="line"><span class="javascript">    hoverShow: &#123;<span class="attr">type</span>: <span class="built_in">Boolean</span>, <span class="attr">default</span>: <span class="literal">true</span>&#125;,  <span class="comment">//图标隐藏时 鼠标悬浮即展示，否则点击展示</span></span></span><br><span class="line"><span class="javascript">    distance: &#123;<span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">5</span>&#125;,  <span class="comment">//距离边界多少px就隐藏</span></span></span><br><span class="line"><span class="javascript">    defaultX: &#123;<span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">1</span>&#125;,  <span class="comment">//初始横坐标百分比</span></span></span><br><span class="line"><span class="javascript">    defaultY: &#123;<span class="attr">type</span>: <span class="built_in">Number</span>, <span class="attr">default</span>: <span class="number">0.1</span>&#125;  <span class="comment">//初始纵坐标百分比</span></span></span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      canDrag: <span class="literal">false</span>,</span></span><br><span class="line"><span class="javascript">      isClick: <span class="literal">true</span>,</span></span><br><span class="line">      x0: 0,</span><br><span class="line">      y0: 0,</span><br><span class="line"><span class="javascript">      top: <span class="literal">null</span>,</span></span><br><span class="line"><span class="javascript">      left: <span class="literal">null</span></span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="comment">// 窗口大小变化时 位置随之变化</span></span></span><br><span class="line"><span class="javascript">    <span class="built_in">window</span>.onresize = <span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.left = (box.offsetWidth - img.offsetWidth) * <span class="built_in">this</span>.defaultX;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.top = (box.offsetHeight - img.offsetHeight) * <span class="built_in">this</span>.defaultY;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.hide()</span></span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> img = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.suspendBox&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="keyword">let</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.outBox&quot;</span>);</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.left = (box.offsetWidth - img.offsetWidth) * <span class="built_in">this</span>.defaultX;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.top = (box.offsetHeight - img.offsetHeight) * <span class="built_in">this</span>.defaultY;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.hide()</span></span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">start</span>(<span class="params">e</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      e.preventDefault();   <span class="comment">//阻止默认的拖拽</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (e.button == <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.canDrag = <span class="built_in">this</span>.ableMove;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.isClick = <span class="literal">true</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> img = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.suspendBox&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 计算点击时鼠标在元素的位置</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.x0 = e.clientX - img.offsetLeft;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.y0 = e.clientY - img.offsetTop;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">move</span>(<span class="params">e</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="built_in">this</span>.canDrag == <span class="literal">true</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.isClick = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> img = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.suspendBox&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.outBox&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (</span></span><br><span class="line">          img.offsetLeft &lt; 0 ||</span><br><span class="line">          img.offsetTop &lt; 0 ||</span><br><span class="line">          img.offsetLeft &gt; box.offsetWidth - img.offsetWidth ||</span><br><span class="line">          img.offsetTop &gt; box.offsetHeight - img.offsetHeight</span><br><span class="line">        ) &#123;</span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="literal">false</span>;</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.left = e.clientX - <span class="built_in">this</span>.x0;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.top = e.clientY - <span class="built_in">this</span>.y0;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">stop</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.canDrag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.show();</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">enter</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="built_in">this</span>.hoverShow) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.show();</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">leave</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.canDrag = <span class="literal">false</span>;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.hide();</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">show</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> img = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.suspendBox&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">let</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.outBox&quot;</span>);</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (img.offsetLeft &lt; <span class="number">0</span>) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.left = <span class="number">0</span>;</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (img.offsetLeft &gt; box.offsetWidth - img.offsetWidth) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.left = box.offsetWidth - img.offsetWidth</span></span><br><span class="line"><span class="javascript">      &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.isClick)&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.clickEvent()</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">hide</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span> (<span class="built_in">this</span>.ableHide) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> img = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.suspendBox&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> box = <span class="built_in">document</span>.querySelector(<span class="string">&quot;.outBox&quot;</span>);</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span> (!<span class="built_in">this</span>.canDrag &amp;&amp; img.offsetLeft &lt; <span class="built_in">this</span>.distance) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.left = -img.offsetWidth * <span class="number">2</span> / <span class="number">3</span>;</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!<span class="built_in">this</span>.canDrag &amp;&amp; img.offsetLeft &gt; box.offsetWidth - img.offsetWidth - <span class="built_in">this</span>.distance) &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.left = box.offsetWidth - img.offsetWidth / <span class="number">3</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">clickEvent</span>(<span class="params"></span>)</span> &#123;      <span class="comment">//悬浮窗的点击事件</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(&quot;悬浮窗的点击事件&quot;);</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.outBox</span> &#123;</span></span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  position: absolute;</span><br><span class="line">  overflow: hidden;</span><br><span class="line"><span class="css">  <span class="selector-tag">z-index</span><span class="selector-pseudo">:100</span>;</span></span><br><span class="line">  pointer-events: none;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.suspendBox</span> &#123;</span></span><br><span class="line">  position: absolute;</span><br><span class="line">  pointer-events: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="css"><span class="selector-class">.move</span> &#123;</span></span><br><span class="line">  transition: 0.3s linear;</span><br><span class="line"><span class="css">  <span class="selector-tag">-moz-transition</span>: 0.3<span class="selector-tag">s</span> <span class="selector-tag">linear</span>; <span class="comment">/* Firefox 4 */</span></span></span><br><span class="line"><span class="css">  <span class="selector-tag">-webkit-transition</span>: 0.3<span class="selector-tag">s</span> <span class="selector-tag">linear</span>; <span class="comment">/* Safari 和 Chrome */</span></span></span><br><span class="line"><span class="css">  <span class="selector-tag">-o-transition</span>: 0.3<span class="selector-tag">s</span> <span class="selector-tag">linear</span>; <span class="comment">/* Opera */</span></span></span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>



<h3 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h3><h4 id="1-新建上述组件"><a href="#1-新建上述组件" class="headerlink" title="1.新建上述组件"></a>1.新建上述组件</h4><p>(点击事件可写在clickEvent方法里)</p>
<h4 id="2-在父组件中引入即可"><a href="#2-在父组件中引入即可" class="headerlink" title="2.在父组件中引入即可"></a>2.在父组件中引入即可</h4><p>例如<br>father.vue</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;father&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Drag</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">img</span> <span class="attr">width</span>=<span class="string">&quot;50px&quot;</span> <span class="attr">height</span>=<span class="string">&quot;50px&quot;</span> <span class="attr">src</span>=<span class="string">&quot;../assets/logo.png&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">Drag</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">p</span> <span class="attr">v-for</span>=<span class="string">&quot;index in 10&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span>&gt;</span>其余内容<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Drag <span class="keyword">from</span> <span class="string">&quot;./Drag&quot;</span>;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123;</span><br><span class="line">    Drag,</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.father</span> &#123;</span></span><br><span class="line">  margin: auto;</span><br><span class="line">  position: relative;</span><br><span class="line">  width: 500px;</span><br><span class="line">  height: 600px;</span><br><span class="line">  background-color: cyan;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<p>注意点：图片可自行更改<br>father样式可自行更改，不过Drag组件的父元素必须是定位元素，即要有position:relative/absolute/fixed…</p>
<h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><p>参数见child.vue里的props</p>
<p><a href="https://blog.csdn.net/weixin_48346852/article/details/109989808">vue实现悬浮窗拖拽和靠边隐藏</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
        <category>拖拽</category>
        <category>靠边隐藏</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>拖拽</tag>
        <tag>靠边隐藏</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之nextTick</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/nextTick/vue/12-vue%E4%B9%8BnextTick/</url>
    <content><![CDATA[<h1 id="nextTick的使用和原理"><a href="#nextTick的使用和原理" class="headerlink" title="nextTick的使用和原理"></a>nextTick的使用和原理</h1><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><p>这道题及考察使用，有考察原理，nextTick在开发过程中应用的也较少，原理上和vue异步更新有密切关系，对于面试者考查很有区分度，如果能够很好回答此题，对面试效果有极大帮助。</p>
<h3 id="答题思路"><a href="#答题思路" class="headerlink" title="答题思路"></a>答题思路</h3><ol>
<li>nextTick是做什么的?</li>
<li>为什么需要它呢?</li>
<li>开发时何时使用它?抓抓头，想想你在平时开发中使用它的地方</li>
<li>下面介绍一下如何使用nextTick</li>
<li>原理解读，结合异步更新和nextTick生效方式，会显得你格外优秀</li>
</ol>
<a id="more"></a>

<h3 id="回答范例"><a href="#回答范例" class="headerlink" title="回答范例:"></a>回答范例:</h3><p>nextTick是等待下一次DOM更新刷新的工具方法。（其实一句话就可以把$nextTick这个东西讲明白：就是你放在 $ nextTick 当中的操作不会立即执行，而是等数据更新、DOM更新完成之后再执行，这样我们拿到的肯定就是最新的了。<br>再准确一点来讲就是 $nextTick方法将回调延迟到下次DOM更新循环之后执行。（看不懂这句人话的，可以看上面）</p>
<p>Vue有个异步更新策略，意思是如果数据变化，Vue不会立刻更新DOM，而是开启一个队列，把组件更新函数保存在队列中，在同一事件循环中发生的所有数据变更会异步的批量更新。这一策略导致我们对数据的修改不会立刻体现在DOM上，此时如果想要获取更新后的DOM状态，就需要使用nextTick。</p>
<p>开发时，有两个场景我们会用到nextTick</p>
<p>created中想要获取DOM时;<br>响应式数据变化后获取DOM更新后的状态，比如希望获取列表更新后的高度。<br>nextTick类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">nextTick</span>(<span class="params">callback?: () =&gt; <span class="keyword">void</span></span>): <span class="title">Promise</span>&lt;<span class="title">void</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>所以我们只需要在传入的回调函数中访问最新DOM状态即可，或者我们可以await nextTick()方法返回的Promise之后做这件事。</p>
<p>在Vue内部，nextTick之所以能够让我们看到DOM更新后的结果，是因为我们传入的callback会被添加到队列刷新函数(flushSchedulerQueue)的后面，这样等队列内部的更新函数都执行完毕，所有DOM操作也就结束了，callback自然能够获取到最新的DOM值。<br>我们可以看一下官方的案例：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> &#123; nextTick &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      count: 0</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">async</span> <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.count++</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// DOM 还未更新</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;counter&#x27;</span>).textContent) <span class="comment">// 0</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="keyword">await</span> nextTick()</span></span><br><span class="line"><span class="javascript">      <span class="comment">// DOM 此时已经更新</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">document</span>.getElementById(<span class="string">&#x27;counter&#x27;</span>).textContent) <span class="comment">// 1</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;counter&quot;</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>&#123;&#123; count &#125;&#125;<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>给了一个count，想要在界面中绑定展示。一开始是0，如果用户点了increment，希望这个count能够++，我们希望界面中能够变成1，可是在紧接着的console.log中你会发现它并没有更新，结果仍然为0，并不是1，那么怎么输出1呢？await nextTick()，后面再输出结果就是1了。为什么会这样呢？这就是nextTick()带给我们最关键的东西了。说白了，就是nextTick()会返回一个promise，未来在异步的方式再来调用我们这行代码。也就是说nextTick()下的console.log将来执行的时候我们的DOM已经更新了。还有一种方式就是nextTick()中间加一个回调函数，在回调函数中输出我们的console.log里面的那一行代码。这样也是可以的。</p>
<p>具体地源码分析可以看<a href="https://cloud.tencent.com/developer/article/1633546">面试题：Vue中$nextTick原理：</a>讲的很清晰<br>总结一下：就是 $nextTick将回调函数放到微任务或者宏任务当中以延迟它地执行顺序；</p>
<p>重要的是理解源码中它的三个参数的意思：</p>
<p>callback：我们要执行的操作，可以放在这个函数当中，我们没执行一次$nextTick就会把回调函数放到一个异步队列当中；<br>pending：标识，用以判断在某个事件循环中是否为第一次加入，第一次加入的时候才触发异步执行的队列挂载<br>timerFunc：用来触发执行回调函数，也就是Promise.then或MutationObserver或setImmediate 或setTimeout的过程<br>理解之后，在看整个$nextTick里面的执行过程，其实就是把一个个 $nextTick中的回调函数压入到callback队列当中，然后根据事件的性质等待执行，轮到它执行的时候，就执行一下，然后去掉callback队列中相应的事件。</p>
<h2 id="面试版"><a href="#面试版" class="headerlink" title="面试版"></a>面试版</h2><h3 id="说说nextTick吧"><a href="#说说nextTick吧" class="headerlink" title="说说nextTick吧"></a>说说nextTick吧</h3><p>nextTick：在下次DOM更新循环结束之后执行延迟回调。</p>
<h3 id="nextTick知道吗？"><a href="#nextTick知道吗？" class="headerlink" title="nextTick知道吗？"></a>nextTick知道吗？</h3><p>这句话扩展开来说，就是由于Vue中DOM更新是「异步执行」的，即修改数据时，视图不会立即更新，而是会监听数据变化，并缓存在同一事件循环中，等同一数据循环中的所有数据变化完成之后，再统一进行视图更新。经常我们会在还未更新的时候就使用了某个元素，这样是拿不到变更后的dom的,所以为了确保能够得到更新后的DOM,所以设置了nextTick()方法。在修改数据之后立即使用这个方法，获取更新后的DOM。简单概括，vue中的nextTick主要用于处理数据动态变化后，DOM还未及时更新的问题，用nextTick可以获取数据更新后最新dom的变化。</p>
<h3 id="在项目中什么时候用呢"><a href="#在项目中什么时候用呢" class="headerlink" title="在项目中什么时候用呢?"></a>在项目中什么时候用呢?</h3><p>比如，当我们需要在生命周期的created()函数进行一些DOM操作的时候一定、要把相关代码放在Vue.nextTick()的回调函数中。原因:在created钩子函数中，DOM还未进行任何渲染，此时进行DOM操作是没用的，所以如果要在这里操作dom,一定要将相关js代码放进<br>Vue.nextTick回调函数中。又或者，在数据变化后要执行某个动作，而这个动作需要使用随数据变化而改变的DOM结构的时候，也需要把相关逻辑写入Vue.nextTick ()回调函数中。</p>
<h3 id="nextTick既然把它传入的方法变成微任务了，那它和其它微任务的执行顺序是怎样的呢？"><a href="#nextTick既然把它传入的方法变成微任务了，那它和其它微任务的执行顺序是怎样的呢？" class="headerlink" title="$nextTick既然把它传入的方法变成微任务了，那它和其它微任务的执行顺序是怎样的呢？"></a>$nextTick既然把它传入的方法变成微任务了，那它和其它微任务的执行顺序是怎样的呢？</h3><p>这简单来说就是谁先挂载Promise对象的问题，在调用 $nextTick方法时就会将其闭包内部维护的执行队列挂载到Promise对象，在数据更新时Vue内部首先就会执行 $nextTick方法，之后便将执行队列挂载到了Promise对象上，其实在明白Js的Event Loop模型后，将数据更新也看做一个 $nextTick方法的调用，并且明白 $nextTick方法会一次性执行所有推入的回调，就可以明白执行顺序的问题了。</p>
<h3 id="nextTick和nextTick区别"><a href="#nextTick和nextTick区别" class="headerlink" title="$nextTick和nextTick区别"></a>$nextTick和nextTick区别</h3><p>$ nextTick和nextTick区别就是nextTick多了一个context参数，用来指定上下文。但两个的本质是一样的，$nextTick是实例方法，nextTick是类的静态方法而已；实例方法的一个好处就是，自动给你绑定为调用实例的this罢了。</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
        <category>nextTick</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>vue实现自由拖拽</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/%E6%8B%96%E6%8B%BD/vue/09-vue%E4%B9%8B%E6%8B%96%E6%8B%BD/</url>
    <content><![CDATA[<h2 id="vue实现自由拖拽"><a href="#vue实现自由拖拽" class="headerlink" title="vue实现自由拖拽"></a>vue实现自由拖拽</h2><p>给div绑定一个自定义指令 v-drag</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;drag-box&quot;</span> <span class="attr">v-drag</span> <span class="attr">id</span>=<span class="string">&quot;drag&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;isShowDrag&quot;</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">Button</span> <span class="attr">type</span>=<span class="string">&quot;primary&quot;</span> @<span class="attr">click.stop</span>=<span class="string">&quot;isShowDrag = false&quot;</span>&gt;</span>关闭<span class="tag">&lt;/<span class="name">Button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>给div设置绝对定位，以及父元素相对定位</p>
<a id="more"></a>

<figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.drag-box</span> &#123;</span><br><span class="line">	<span class="attribute">position</span>:absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">left</span>: <span class="number">100px</span>;<span class="attribute">width</span>:<span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100px</span>;</span><br><span class="line">	<span class="attribute">background</span>: <span class="number">#fff</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">5px</span>;</span><br><span class="line">	<span class="attribute">box-shadow</span>: <span class="number">6</span> <span class="number">4px</span>12px <span class="built_in">rgba</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,.<span class="number">15</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写自定义指令</p>
<p><a href="https://imgse.com/i/xbOeUg"><img src="https://s1.ax1x.com/2022/11/03/xbOeUg.png" alt="xbOeUg.png"></a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">directives: &#123;</span><br><span class="line">        drag: &#123;</span><br><span class="line">            <span class="comment">// 指令的定义</span></span><br><span class="line">            bind: <span class="function"><span class="keyword">function</span>(<span class="params">el</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">let</span> oDiv = el;  <span class="comment">// 获取当前元素</span></span><br><span class="line">                oDiv.onmousedown = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                    <span class="built_in">console</span>.log(<span class="string">&#x27;onmousedown&#x27;</span>)</span><br><span class="line">                    <span class="comment">// 算出鼠标相对元素的位置</span></span><br><span class="line">                    <span class="keyword">let</span> disX = e.clientX - oDiv.offsetLeft;</span><br><span class="line">                    <span class="keyword">let</span> disY = e.clientY - oDiv.offsetTop;</span><br><span class="line">                    <span class="built_in">document</span>.onmousemove = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="comment">// 用鼠标的位置减去鼠标相对元素的位置，得到元素的位置</span></span><br><span class="line">                        <span class="keyword">let</span> left = e.clientX - disX;</span><br><span class="line">                        <span class="keyword">let</span> top = e.clientY - disY;</span><br><span class="line">                        oDiv.style.left = left + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                        oDiv.style.top = top + <span class="string">&#x27;px&#x27;</span>;</span><br><span class="line">                    &#125;;</span><br><span class="line">                    <span class="built_in">document</span>.onmouseup = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">                        <span class="built_in">document</span>.onmousemove = <span class="literal">null</span>;</span><br><span class="line">                        <span class="built_in">document</span>.onmouseup = <span class="literal">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><a href="https://www.jianshu.com/p/fa643daa2c41?u_atoken=3f091e96-0f2f-4643-aa1a-4ff4c0234a51&u_asession=01S_CDPqiKvP2btpaigKc9RztiDD_yVrfnx5nbfXMUszTgymuAChTJHArD9KppQqYGX0KNBwm7Lovlpxjd_P_q4JsKWYrT3W_NKPr8w6oU7K_0C26HBGSPUHOkZyzwKg6_7TzbK64jWsJYZqMKGduDQWBkFo3NEHBv0PZUm6pbxQU&u_asig=05ZzWZXByCBXe3TS4C2roTfmxf20o_fqS3o2gh5KnLPdaxQlwb4r3BgnKkBhcsVQOfhRpPAArd4OEQ7YTVH9NvIkR-wMFm5dZkuXmarEIJ20HQaTX82FgeWiMsj7NR3CnyuAjwU_SiSrAju2jRr4KtfHXf_QYOT2m-1W-g2lRPgXD9JS7q8ZD7Xtz2Ly-b0kmuyAKRFSVJkkdwVUnyHAIJzeIDpkanYkVf6KuiHzJ_yuzxjte2xFxGj5ibZ5017NqwRZfeyxQBxz7loGfMAdy0Tu3h9VXwMyh6PgyDIVSG1W_BISsGnvPUsmM5uKOpbPj7uWWbjI0_TupL4F2_6J0FDUVDfexsb39cNmWxstNtBrNd9MeaDwNw9R6KQF2C9pDKmWspDxyAEEo4kbsryBKb9Q&u_aref=IZ1WOKznwrVeGZB6rcDG3YiOl2Y=">vue中实现div自由拖拽</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
        <category>拖拽</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>拖拽</tag>
      </tags>
  </entry>
  <entry>
    <title>01_HTML基础</title>
    <url>/HTML/%E7%AC%94%E8%AE%B0/HTML+CSS/01_HTML%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="1-什么是网页"><a href="#1-什么是网页" class="headerlink" title="1. 什么是网页"></a>1. 什么是网页</h3><p>HTML文件 + CSS文件 + JS文件 (W3C标准)</p>
<ul>
<li>HTML文件作用：给网页提供结构</li>
<li>CSS文件作用：美化布局网页</li>
<li>JS文件作用：给网页提供行为</li>
</ul>
<h3 id="2-什么是HTML"><a href="#2-什么是HTML" class="headerlink" title="2. 什么是HTML"></a>2. 什么是HTML</h3><p><font color="deeppink">超文本标记语言(Hyper Text Markup Language)</font></p>
<p>超文本：文字、图片、动画、音频、视频、超链接和程序等等</p>
<p>特点：简单、通用性、与平台无关</p>
<p><font color="blue">HTML不是一种编程语言</font></p>
<a id="more"></a>

<h3 id="3-HTML语法规范"><a href="#3-HTML语法规范" class="headerlink" title="3. HTML语法规范"></a>3. HTML语法规范</h3><ul>
<li>HTML中不区分大小写，但一般用小写</li>
<li>注释不能嵌套</li>
<li>HTML标签必须结构完整（要么成对出现，要么是自结束标签）</li>
<li>HTML标签可以嵌套但不能交叉嵌套</li>
<li>HTML标签中的属性必须有值，且值必须加引号</li>
</ul>
<h3 id="4-什么是语义化，为什么要语义化"><a href="#4-什么是语义化，为什么要语义化" class="headerlink" title="4. 什么是语义化，为什么要语义化"></a><font color="red">4. 什么是语义化，为什么要语义化</font></h3><h4 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a><strong>HTML语义化</strong></h4><p>HTML的语义化总结为： 用最恰当的标签来标记内容。</p>
<p>该如何理解呢？比如需要加入一个标题，这个标题的字体比正文的要大写，还要加粗。能够实现这种效果的方法有很多，比如用CSS样式进行渲染。这样的效果看起来像是一个标题，但是他对浏览器来说，只是一个被渲染过的文本，无法知道他是一个标题。若要让浏览器知道他是一个标题，应该用hx标签来进行标记。从这个例子可以总结出： 语义化的HTML文档，不关心内容的显示效果。 说的通俗一点： 标题脱了CSS这层外衣，它还是一个标题。</p>
<h4 id="HTML语义化的原因"><a href="#HTML语义化的原因" class="headerlink" title="HTML语义化的原因"></a><strong>HTML语义化的原因</strong></h4><ul>
<li>即使在没有CSS样式的条件下，也能很好地呈现出内容结构、代码结构；</li>
<li>语义化HTML会使HTML结构变的清晰，有利于维护代码和添加样式；</li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li>
<li>提升搜索引擎优化(SEO)的效果。和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li>
<li>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li>
<li>通常语义化HTML会使代码变的更少，使页面加载更快。</li>
</ul>
<h4 id="在写HTML代码时应该注意"><a href="#在写HTML代码时应该注意" class="headerlink" title="在写HTML代码时应该注意"></a><strong>在写HTML代码时应该注意</strong></h4><ul>
<li>尽可能少的使用无语义的标签div和span；</li>
<li>在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li>
<li>不要使用纯样式标签，如：b、font、u等，改用css设置。</li>
<li>需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li>
<li>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li>
<li>表单域要用fieldset标签包起来，并用legend标签说明表单的用途；</li>
<li>每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。</li>
</ul>
<h4 id="HTML5新增了哪些语义标签"><a href="#HTML5新增了哪些语义标签" class="headerlink" title="HTML5新增了哪些语义标签"></a><strong>HTML5新增了哪些语义标签</strong></h4><p>在HTML 5出来之前，我们用<code>div</code>来表示页面章节，但是这些<code>div</code>都没有实际意义。（即使我们用css样式的id和class形容这块内容的意义）。这些标签只是我们提供给浏览器的指令，只是定义一个网页的某些部分。但现在，那些之前没“意义”的标签因为因为html5的出现消失了，这就是我们平时说的“语义”。 </p>
<h5 id="html5的布局"><a href="#html5的布局" class="headerlink" title="html5的布局"></a><strong>html5的布局</strong></h5><p>嗯，如上图那个页面结构没有一个div，都是采用html5语义标签（用哪些标签，关键取决于你的设计目标）。</p>
<p>但是也不要因为html5新标签的出现，而随意用之，错误的使用肯定会事与愿违。所以有些地方还是要用div的，就是因为div没有任何意义的元素，他只是一个标签，仅仅是用来构建外观和结构。因此是最适合做容器的标签。</p>
<p>W3C定义了这些语义标签，不可能完全符合我们有时的设计目标，就像制定出来的法律不可能流传100年都不改变，更何况它才制定没多久，不可能这些语义标签对所以设计目标的适应。只是一定程度上的“通用”，我们的目标是让爬虫读懂重要的东西就够了。</p>
<p>结论：不能因为有了HTML 5标签就弃用了div，每个事物都有它的独有作用的。</p>
<p>节点元素标签因使用的地方不同，我将他们分为：节元素标签、文本元素标签、分组元素标签分开来讲解HTML5中新增加的语义化标签和使用总结。</p>
<h5 id="header元素"><a href="#header元素" class="headerlink" title="header元素"></a>header元素</h5><p>header 元素代表“网页”或“section”的页眉。<br>通常包含<code>h1-h6</code>元素或<code>hgroup</code>，作为整个页面或者一个内容块的标题。也可以包裹一节的目录部分，一个搜索框，一个<code>nav</code>，或者任何相关logo。</p>
<p>整个页面没有限制header元素的个数，可以拥有多个，可以为每个内容块增加一个header元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;header&gt;</span><br><span class="line">    &lt;hgroup&gt;</span><br><span class="line">        &lt;h1&gt;网站标题&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;h1&gt;网站副标题&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;hgroup&gt;</span><br><span class="line">&lt;&#x2F;header&gt;</span><br></pre></td></tr></table></figure>
<p><strong>header的示例代码</strong></p>
<p>header使用注意：</p>
<ul>
<li>可以是“网页”或任意“section”的头部部分；</li>
<li>没有个数限制。</li>
<li>如果hgroup或h1-h6自己就能工作的很好，那就不要用header。</li>
</ul>
<h5 id="footer元素"><a href="#footer元素" class="headerlink" title="footer元素"></a>footer元素</h5><p><code>footer</code>元素代表“网页”或“section”的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。如果<code>footer</code>元素包含了整个节，那么它们就代表附录，索引，提拔，许可协议，标签，类别等一些其他类似信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;footer&gt;</span><br><span class="line">    COPYRIGHT@小北</span><br><span class="line">&lt;&#x2F;footer&gt;</span><br></pre></td></tr></table></figure>
<p><strong><code>footer</code>的示例代码</strong></p>
<p>footer使用注意：</p>
<ul>
<li>可以是“网页”或任意“section”的底部部分；</li>
<li>没有个数限制，除了包裹的内容不一样，其他跟header类似。</li>
</ul>
<h5 id="hgroup元素"><a href="#hgroup元素" class="headerlink" title="hgroup元素"></a>hgroup元素</h5><p><code>hgroup</code>元素代表“网页”或“section”的标题，当元素有多个层级时，该元素可以将<code>h1</code>到<code>h6</code>元素放在其内，譬如文章的主标题和副标题的组合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;hgroup&gt;</span><br><span class="line">    &lt;h1&gt;这是一篇介绍HTML 5语义化标签和更简洁的结构&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h2&gt;HTML 5&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;&#x2F;hgroup&gt;</span><br></pre></td></tr></table></figure>
<p><strong><code>hgroup</code>示例代码</strong></p>
<p>hgroup使用注意：</p>
<ul>
<li>如果只需要一个h1-h6标签就不用hgroup</li>
<li>如果有连续多个h1-h6标签就用hgroup</li>
<li>如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签</li>
</ul>
<h5 id="nav元素"><a href="#nav元素" class="headerlink" title="nav元素"></a><strong>nav元素</strong></h5><p><code>nav</code>元素代表页面的导航链接区域。用于定义页面的<strong>主要导航部分</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;HTML 5&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;CSS3&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;JavaScript&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure>
<p><strong><code>nav</code>实例</strong></p>
<p>但是我在有些时候却情不自禁的想用它，譬如：侧边栏上目录，面包屑导航，搜索样式，或者下一篇上一篇文章，但是事实上规范上说nav只能用在页面主要导航部分上。页脚区域中的链接列表，虽然指向不同网站的不同区域，譬如服务条款，版权页等，这些footer元素就能够用了。</p>
<p>nav使用注意：</p>
<ul>
<li>用在整个页面主要导航部分上，不合适就不要用nav元素；</li>
</ul>
<h5 id="aside元素"><a href="#aside元素" class="headerlink" title="aside元素"></a><strong>aside元素</strong></h5><p><code>aside</code>元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。（特殊的section）</p>
<p>在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;article&gt;</span><br><span class="line">    &lt;p&gt;内容&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;aside&gt;</span><br><span class="line">        &lt;h1&gt;作者简介&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;小北，前端一枚&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;aside&gt;</span><br><span class="line">&lt;&#x2F;article&gt;</span><br></pre></td></tr></table></figure>
<p><strong><code>aside</code>实例</strong></p>
<p>aside使用总结：</p>
<ul>
<li>aside在article内表示主要内容的附属信息，</li>
<li>在article之外则可做侧边栏，没有article与之对应，最好不用。</li>
<li>如果是广告，其他日志链接或者其他分类导航也可以用</li>
</ul>
<h5 id="section元素"><a href="#section元素" class="headerlink" title="section元素"></a>section元素</h5><p><code>section</code>元素代表文档中的“节”或“段”，“段”可以是指一篇文章里按照主题的分段；“节”可以是指一个页面里的分组。</p>
<p>section通常还带标题，虽然html5中section会自动给标题h1-h6降级，但是最好手动给他们降级。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">    &lt;h1&gt;section是啥？&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;article&gt;</span><br><span class="line">        &lt;h2&gt;关于section&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;section的介绍&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;section&gt;</span><br><span class="line">            &lt;h3&gt;关于其他&lt;&#x2F;h3&gt;</span><br><span class="line">            &lt;p&gt;关于其他section的介绍&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;section&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
<p><strong><code>section</code>示例代码</strong></p>
<p>section使用注意：</p>
<p>一张页面可以用section划分为简介、文章条目和联系信息。不过在文章内页，最好用article。section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。</p>
<ul>
<li>表示文档中的节或者段；</li>
<li>article、nav、aside可以理解为特殊的section，所以如果可以用article、nav、aside就不要用section，没实际意义的就用div</li>
</ul>
<h5 id="article元素"><a href="#article元素" class="headerlink" title="article元素"></a>article元素</h5><p><code>article</code>元素最容易跟<code>section</code>和<code>div</code>容易混淆，其实<code>article</code>代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。譬如论坛的帖子，博客上的文章，一篇用户的评论，一个互动的widget小工具。（特殊的section）</p>
<p>除了它的内容，<code>article</code>会有一个标题（通常会在<code>header</code>里），会有一个<code>footer</code>页脚。我们举几个例子介绍一下article，好更好区分article、section、div</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;article&gt;</span><br><span class="line">    &lt;h1&gt;一篇文章&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;文章内容..&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;footer&gt;</span><br><span class="line">        &lt;p&gt;&lt;small&gt;版权：html5jscss网所属，作者：小北&lt;&#x2F;small&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;article&gt;</span><br></pre></td></tr></table></figure>
<p><strong>一篇简单文章的article示例代码</strong></p>
<p>上例是最好简单的article标签使用情况，如果在article内部再嵌套article，那就代表内嵌的article是与它外部的内容有关联的，如博客文章下面的评论，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;article&gt;</span><br><span class="line"></span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;h1&gt;一篇文章&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;&lt;time pubdate datetime&#x3D;&quot;2012-10-03&quot;&gt;2012&#x2F;10&#x2F;03&lt;&#x2F;time&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;header&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;文章内容..&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;article&gt;</span><br><span class="line">        &lt;h2&gt;评论&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">        &lt;article&gt;</span><br><span class="line">            &lt;header&gt;</span><br><span class="line">                &lt;h3&gt;评论者: XXX&lt;&#x2F;h3&gt;</span><br><span class="line">                &lt;p&gt;&lt;time pubdate datetime&#x3D;&quot;2012-10-03T19:10-08:00&quot;&gt;~1 hour ago&lt;&#x2F;time&gt;&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;&#x2F;header&gt;</span><br><span class="line">            &lt;p&gt;哈哈哈&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">        &lt;article&gt;</span><br><span class="line">            &lt;header&gt;</span><br><span class="line">                &lt;h3&gt;评论者: XXX&lt;&#x2F;h3&gt;</span><br><span class="line">                &lt;p&gt;&lt;time pubdate datetime&#x3D;&quot;2012-10-03T19:10-08:00&quot;&gt;~1 hour ago&lt;&#x2F;time&gt;&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;&#x2F;header&gt;</span><br><span class="line">            &lt;p&gt;哈？哈？哈？&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;article&gt;</span><br></pre></td></tr></table></figure>
<p><strong>文章里的评论，一个article嵌套article来表示的实例</strong></p>
<p>article内部嵌套article，有可能是评论或其他跟文章有关联的内容。那article内部嵌套section一般是什么情况呢。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;article&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h1&gt;前端技术&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;前端技术有那些&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;section&gt;</span><br><span class="line">        &lt;h2&gt;CSS&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p&gt;样式..&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line"></span><br><span class="line">    &lt;section&gt;</span><br><span class="line">        &lt;h2&gt;JS&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p&gt;脚本&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;article&gt;</span><br></pre></td></tr></table></figure>
<p><strong>文章里的章节，一个article里的section实例</strong></p>
<p>因为文章内section部分虽然也是独立的部分，但是它门只能算是<em>组成整体的一部分</em>，从属关系，article是大主体，section是构成这个大主体的一部分。本网站的全部文章都是article嵌套一个个section章节，这样能让浏览器更容易区分各个章节所包括的内容。</p>
<p>那section内部嵌套article又有哪些情况呢，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;h1&gt;介绍: 网站制作成员配备&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;article&gt;</span><br><span class="line">        &lt;h2&gt;设计师&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p&gt;设计网页的...&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">    &lt;article&gt;</span><br><span class="line">        &lt;h2&gt;程序员&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p&gt;后台写程序的..&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">    &lt;article&gt;</span><br><span class="line">        &lt;h2&gt;前端工程师&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p&gt;给楼上两位打杂的..&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
<p><strong>一个section里的article实例</strong></p>
<p>设计师、程序员、前端工程师都是一个独立的整体，他们组成了网站制作基本配备，当然还有其他成员~~。设计师、程序员、前端工程师就像article，是一个个独立的整体，而section将这些自成一体的article包裹，就组成了一个团体。</p>
<p>article和section和例子就例举这么多了，具体情况具体分析，不易深究。漏了<code>div</code>d，其实<code>div</code>就是只是想用来把元素组合或者给它们加样式时使用。</p>
<p>article使用注意：</p>
<ul>
<li>自身独立的情况下：用article</li>
<li>是相关内容：用section</li>
<li>没有语义的：用div</li>
</ul>
<h4 id="HTML5其他结构元素标签"><a href="#HTML5其他结构元素标签" class="headerlink" title="HTML5其他结构元素标签"></a><strong>HTML5其他结构元素标签</strong></h4><p>HTML5节元素标签包括<code>body article nav aside section header footer hgroup </code>，还有<code>h1-h6 address</code>。</p>
<ul>
<li><code>address</code>代表区块容器，必须是作为联系信息出现，邮编地址、邮件地址等等,一般出现在footer。</li>
<li><code>h1-h6</code>因为hgroup，section和article的出现，h1-h6定义也发生了变化，允许一张页面出现多个h1。</li>
</ul>
<h3 id="5-图片的格式"><a href="#5-图片的格式" class="headerlink" title="5. 图片的格式"></a>5. 图片的格式</h3><ul>
<li>JPEG(JPG)：支持颜色较多，图片可压缩，但不支持透明（一般用来保存照片等颜色丰富的图片）</li>
<li>GIF：支持颜色少，只支持简单透明，支持动态图（用来保存图片颜色单一或动图）</li>
<li>PNG：支持颜色多，支持复杂透明。（用来保存颜色复杂的透明图片）</li>
<li>Webp：这种格式是谷歌推出的专门用来表示网页中图片的一种格式，它具备其他图片格式的所有优点，而且文件还特别小。缺点是兼容性差。</li>
<li>base64：将图片使用base64编码，这样可以将图片转换为字符，通过字符的形式来引入图片，一般都是一些需要和网页一起加载的图片才会使用base64，他不是一种格式，任何格式的图片都可以转化为base64的形式。</li>
</ul>
<p><font color="deeppink">使用原则：效果不同使用效果好的，效果一致使用小的。</font></p>
<h3 id="6-实体（转义字符）"><a href="#6-实体（转义字符）" class="headerlink" title="6. 实体（转义字符）"></a>6. 实体（转义字符）</h3><p>在HTML中，一些 ‘&lt;’ 和 ‘&gt;’ 这样的特殊字符是不能直接使用的需要使用一些特殊的符号来表示这些字符,这些特殊的符号我们称为实体。</p>
<p>用法：&amp; + 实体名字 + ；</p>
<p>例如：&gt;    &amp;lt;    &gt;    &amp;gt;    空格    &amp;nbsp;    版权符号    &amp;copy;</p>
<h3 id="7-文档声明"><a href="#7-文档声明" class="headerlink" title="7. 文档声明"></a>7. 文档声明</h3><p>&lt;!DOCTYPE html&gt;<br><font color="deeppink">该标签写在html标签外</font></p>
<p>表示该网页的文档类型，并且告诉浏览器渲染模式。如果不设置则会导致浏览器进入怪异模式（怪异盒模型即border-box）</p>
<p>标准模式，近乎标准模式，怪异模式</p>
<ul>
<li>在ie9以上三种模式在渲染方面几乎没有区别</li>
<li>在ie7,8,9中理论上存在怪异模式，但实际上只有标准模式</li>
<li>在ie6以下，只有怪异模式</li>
</ul>
<h4 id="标准模式与怪异模式区别"><a href="#标准模式与怪异模式区别" class="headerlink" title="标准模式与怪异模式区别"></a><font color="red">标准模式与怪异模式区别</font></h4><p>1）盒模型：IE下标准模式为：content+padding+border+margin。怪异模式下为：content+margin(padding,border包含在content宽高中)</p>
<p>2）怪异模式中IE6/7/8都不识别！important声明</p>
<p>3）设置行内元素宽高，标准模式下不生效，怪异模式下生效</p>
<p>4）margin:0 auto,在标准模式下会水平居中，怪异模式下不会。</p>
<h3 id="8-meta标签"><a href="#8-meta标签" class="headerlink" title="8. meta标签"></a>8. meta标签</h3><p>&lt;meta charset=”utf-8”&gt;</p>
<p>字符集设置如果不设置浏览器会使用默认的解码方式（中文系统下是GB2312）进行解码，有可能出现乱码，所以使用meta标签声明该网页使用的编码格式。</p>
<p><font color="deeppink">编码方式是由编译器决定的</font></p>
]]></content>
      <categories>
        <category>HTML</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>attribute与property</title>
    <url>/HTML/%E7%AC%94%E8%AE%B0/HTML+CSS/attribute%E4%B8%8Eproperty/</url>
    <content><![CDATA[<h3 id="1-什么是attribute，什么是property"><a href="#1-什么是attribute，什么是property" class="headerlink" title="1.什么是attribute，什么是property"></a>1.什么是attribute，什么是property</h3><p>​    html标签的预定义和自定义属性我们统称为attribute(attribute被节点的attributes属性统一管理且该属性是一个对象)<br>​    js原生对象的直接属性，我们统称为property(attributes就是一个节点的property)</p>
<h3 id="2-什么是布尔值属性，什么是非布尔值属性"><a href="#2-什么是布尔值属性，什么是非布尔值属性" class="headerlink" title="2.什么是布尔值属性，什么是非布尔值属性"></a>2.什么是布尔值属性，什么是非布尔值属性</h3><p>​    property的属性值为布尔类型的  我们统称为布尔值属性<br>​    property的属性值为非布尔类型的  我们统称为非布尔值属性</p>
<h3 id="3-attribute和property的同步关系"><a href="#3-attribute和property的同步关系" class="headerlink" title="3.attribute和property的同步关系"></a>3.attribute和property的同步关系</h3><p>​    非布尔值属性：实时同步<br>​    布尔值属性：<br>​        property永远都不会同步attribute<br>​        在没有动过property的情况下<br>​            attribute会同步property<br>​        在动过property的情况下<br>​            attribute不会同步property</p>
<h3 id="4-用户操作的是property"><a href="#4-用户操作的是property" class="headerlink" title="4.用户操作的是property"></a>4.用户操作的是property</h3><h3 id="5-浏览器认的是property"><a href="#5-浏览器认的是property" class="headerlink" title="5.浏览器认的是property"></a>5.浏览器认的是property</h3><p><a href="https://www.bilibili.com/video/BV1YW411T7Lj?p=1">参考尚硅谷</a></p>
]]></content>
      <categories>
        <category>HTML</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>记录一</title>
    <url>/%E7%AC%94%E8%AE%B0/%E5%B0%8F%E6%9C%AC%E6%9C%AC/%E8%AE%B0%E5%BD%95%E4%B8%80/</url>
    <content><![CDATA[<h3 id="布局-两列-圣杯-双飞翼-等高"><a href="#布局-两列-圣杯-双飞翼-等高" class="headerlink" title="布局(两列,圣杯,双飞翼,等高)"></a>布局(两列,圣杯,双飞翼,等高)</h3><h3 id="垂直居中"><a href="#垂直居中" class="headerlink" title="垂直居中"></a>垂直居中</h3><p><a href="https://blog.csdn.net/weixin_37580235/article/details/82317240?depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3&utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-3#%E8%A1%8C%E5%86%85%E5%85%83%E7%B4%A0">div的水平垂直居中</a></p>
<h3 id="使用flex居中元素"><a href="#使用flex居中元素" class="headerlink" title="使用flex居中元素"></a>使用flex居中元素</h3><p>参照上个问题</p>
<h3 id="重绘重排-css3动画会触发吗"><a href="#重绘重排-css3动画会触发吗" class="headerlink" title="重绘重排(css3动画会触发吗)"></a>重绘重排(css3动画会触发吗)</h3><p><a href="https://github.com/Advanced-Frontend/Daily-Interview-Question/issues/24">重绘重排1</a></p>
<p><a href="https://github.com/chenjigeng/blog/issues/4">重绘重排2</a></p>
<a id="more"></a>

<h3 id="与-的区别"><a href="#与-的区别" class="headerlink" title="==与===的区别"></a>==与===的区别</h3><p>“===”叫做严格运算符，”==”叫做相等运算符。</p>
<p>严格运算符的运算规则如下，<br>(1)不同类型值<br>如果两个值的类型不同，直接返回false。<br>(2)同一类的原始类型值<br>同一类型的原始类型的值（数值、字符串、布尔值）比较时，值相同就返回true，值不同就返回false。<br>(3)同一类的复合类型值<br>两个复合类型（对象、数组、函数）的数据比较时，不是比较它们的值是否相等，而是比较它们是否指向同一个对象。<br>(4)undefined和null<br>undefined 和 null 与自身严格相等。</p>
<p>相等运算符在比较相同类型的数据时，与严格相等运算符完全一样。<br>在比较不同类型的数据时，相等运算符会先将数据进行类型转换，然后再用严格相等运算符比较。类型转换规则如下：<br>(1)原始类型的值<br>原始类型的数据会转换成数值类型再进行比较。<strong>字符串和布尔值都会转换成数值，所以题主的问题中会有第二个string输出。</strong><br>(2)对象与原始类型值比较<br>对象（这里指广义的对象，包括数值和函数）与原始类型的值比较时，对象转化成原始类型的值，再进行比较。<br>(3)undefined和null<br>undefined和null与其他类型的值比较时，结果都为false，它们互相比较时结果为true。<br>(4)相等运算符的缺点<br>相等运算符隐藏的类型转换，会带来一些违反直觉的结果。</p>
<h3 id="深浅拷贝区别-深拷贝的应用"><a href="#深浅拷贝区别-深拷贝的应用" class="headerlink" title="深浅拷贝区别(深拷贝的应用)"></a>深浅拷贝区别(深拷贝的应用)</h3><p><a href="https://segmentfault.com/a/1190000018874254">区别</a></p>
<p><strong>应用:</strong></p>
<ul>
<li><p>从服务器fetch到数据之后我将其存放在store中，通过props传递给界面，然后我需要对这堆数据进行修改，那涉及到的修改就一定有保存和取消，所以我们需要将这堆数据拷贝到其它地方。</p>
</li>
<li><p>当你想使用某个对象的值，在修改时不想修改原对象，那么可以用深拷贝弄一个新的内存对象。像es6的新增方法都是深拷贝，所以推荐使用es6语法。</p>
</li>
</ul>
<h3 id="js继承"><a href="#js继承" class="headerlink" title="js继承"></a>js继承</h3><p><a href="https://juejin.cn/post/6844903889553063949#comment">7中继承</a></p>
<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><p><a href="https://juejin.cn/post/6844903496253177863#heading-3">this详解</a></p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p><a href="https://juejin.cn/post/6844904161268482062">闭包详解</a></p>
<h3 id="vue父子传递"><a href="#vue父子传递" class="headerlink" title="vue父子传递"></a>vue父子传递</h3><h3 id="常见数据结构"><a href="#常见数据结构" class="headerlink" title="常见数据结构"></a>常见数据结构</h3><p><a href="https://blog.csdn.net/yeyazhishang/article/details/82353846">常见数据结构</a></p>
<h3 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h3><p><a href="https://www.jianshu.com/p/5e9ea25a1aae">二叉树详解1</a></p>
<p><a href="https://blog.csdn.net/Monster_ii/article/details/82115772?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">二叉树的前中后和层序遍历详解</a></p>
]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>小本本</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之获取元素宽高</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/13-vue%E4%B9%8B%E8%8E%B7%E5%8F%96%E5%85%83%E7%B4%A0%E5%AE%BD%E9%AB%98/</url>
    <content><![CDATA[<p>写在 页面 方法 部分</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ref</span>=<span class="string">&quot;init&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br></pre></td></tr></table></figure>

<p>这里的 offsetHeight 是返回元素的宽度（包括元素宽度、内边距和边框，不包括外边距）</p>
<p>let height= this.$refs.init.$el.offsetHeight;  </p>
<p>这里的offsetHeight可以替换，用来获取其他的属性</p>
<a id="more"></a>

<p>offsetWidth       //返回元素的宽度（包括元素宽度、内边距和边框，不包括外边距）</p>
<p>offsetHeight      //返回元素的高度（包括元素高度、内边距和边框，不包括外边距）</p>
<p>clientWidth        //返回元素的宽度（包括元素宽度、内边距，不包括边框和外边距）</p>
<p>clientHeight       //返回元素的高度（包括元素高度、内边距，不包括边框和外边距）</p>
<p>style.width         //返回元素的宽度（包括元素宽度，不包括内边距、边框和外边距）</p>
<p>style.height       //返回元素的高度（包括元素高度，不包括内边距、边框和外边距）</p>
<p>scrollWidth       //返回元素的宽度（包括元素宽度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与clientWidth相同</p>
<p>scrollHeigh       //返回元素的高度（包括元素高度、内边距和溢出尺寸，不包括边框和外边距），无溢出的情况，与clientHeight相同</p>
<p>除此之外，还可以获取带有单位的数值</p>
<p>let height = window.getComputedStyle(this.$refs.init).height; </p>
<p>这样获取的值是有单位的。</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>获取元素宽高</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之样式穿透</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/15-vue%E4%B9%8B%E6%A0%B7%E5%BC%8F%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<h2 id="vue样式穿透"><a href="#vue样式穿透" class="headerlink" title="vue样式穿透"></a>vue样式穿透</h2><h5 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h5><p>vue的style中设置scoped属性后，组件实现样式私有化。<br> 但是该组件又使用的其他组件库时(vant,elementui,自定义等)，该组件的style中的样式，优先级低，不生效，这个时候需要使用样式穿透(作用得更深)。</p>
<h5 id="一、scoped底层原理"><a href="#一、scoped底层原理" class="headerlink" title="一、scoped底层原理"></a>一、scoped底层原理</h5><ul>
<li>scoped是通过在DOM以及css中加上<code>data-v-xxx</code>唯一标识来实现样式私有化。</li>
</ul>
<p>1.加上scoped前</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">template</span>&gt;</span><br><span class="line">    &lt;div class=&quot;demo&quot;&gt;</span><br><span class="line">        样式穿透示例</span><br><span class="line">    &lt;/<span class="selector-tag">div</span>&gt;</span><br><span class="line">&lt;/<span class="selector-tag">template</span>&gt;</span><br><span class="line">&lt;<span class="selector-tag">style</span> &gt;</span><br><span class="line">    <span class="selector-class">.demo</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p><img src="https://s1.ax1x.com/2022/11/09/zSGmZT.png" alt="zSGmZT.png"></p>
<p>2.加上scoped后</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;</span><br><span class="line">    <span class="selector-class">.demo</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: <span class="built_in">rgba</span>(<span class="number">255</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0.5</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2022/11/09/zSGZLV.png"></p>
<p>通过图片可以看到scoped底层是通过在<code>DOM节点</code>中添加<code>data-v-xxx</code>，<code>CSS</code>中通过添加<code>[data-v-xxx]</code>属性过滤，提高优先级，来实现样式的私有化。</p>
<h5 id="二、为什么需要样式穿透"><a href="#二、为什么需要样式穿透" class="headerlink" title="二、为什么需要样式穿透"></a>二、为什么需要样式穿透</h5><p>看一个场景实例：子组件根元素颜色为<code>红色</code>，非根元素为<code>蓝色</code>。<br> 父子两个组件<code>style</code>都使用<code>scoped</code>属性，在不修改子组件的前提下，在父组件上修改子组件的颜色为<code>绿色</code>。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 子组件</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c1&quot;</span>&gt;</span></span><br><span class="line">        子组件根元素(red)</span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;c2&quot;</span>&gt;</span></span><br><span class="line">            子组件非根元素(blue)</span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.c1</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">dashed</span> <span class="selector-id">#000</span>;</span></span><br><span class="line">        margin-top: 10px;</span><br><span class="line">        padding: 5px;</span><br><span class="line">        color: red;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.c1</span> <span class="selector-class">.c2</span>&#123;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">border</span>: 1<span class="selector-tag">px</span> <span class="selector-tag">dotted</span> <span class="selector-id">#000</span>;</span></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 父组件</span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;demo&quot;</span>&gt;</span></span><br><span class="line">        父组件</span><br><span class="line">        <span class="tag">&lt;<span class="name">css-demo</span> <span class="attr">class</span>=<span class="string">&quot;son&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">css-demo</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">lang</span>=<span class="string">&quot;ts&quot;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> cssDemo <span class="keyword">from</span> <span class="string">&quot;./css-demo2.vue&quot;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> Vue.extend(&#123;</span></span><br><span class="line">    components:&#123; cssDemo &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.demo</span>&#123;</span></span><br><span class="line">        width: 200px;</span><br><span class="line">        padding: 10px;</span><br><span class="line">        border: 1px solid rgba(0,0,0,1);</span><br><span class="line"></span><br><span class="line"><span class="css">        <span class="selector-tag">color</span>: <span class="selector-id">#000</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.son</span>&#123;</span></span><br><span class="line">        color: green;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.son</span> <span class="selector-class">.c2</span>&#123;</span></span><br><span class="line">        color: green !important;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.c1</span> <span class="selector-class">.c2</span>&#123;</span></span><br><span class="line">        color: green !important;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.son</span><span class="selector-class">.c1</span> <span class="selector-class">.c2</span>&#123;</span></span><br><span class="line">        color: green !important;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2022/11/09/zSGVs0.png"></p>
<p><img src="https://s1.ax1x.com/2022/11/09/zSGuoF.png"></p>
<ul>
<li>可以看到只有子组件的根元素作用有生效，但是子组件的非根元素样式并没有生效，即使使用了<code>!important</code>。</li>
<li>scoped在渲染的时候，如果组件内部还有子组件，只会在子组件的根元素加上<code>data-v-xxx</code>属性。</li>
</ul>
<p>当加上样式穿透后</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">// 父组件</span><br><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;</span><br><span class="line">    &gt;&gt;&gt; <span class="selector-class">.c1</span> <span class="selector-class">.c2</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: green <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br></pre></td></tr></table></figure>
<p><img src="https://s1.ax1x.com/2022/11/09/zSGndU.png"></p>
<p><img src="https://s1.ax1x.com/2022/11/10/zpFUbt.png"></p>
<h5 id="三、样式穿透的方法"><a href="#三、样式穿透的方法" class="headerlink" title="三、样式穿透的方法"></a>三、样式穿透的方法</h5><p><code>vue</code>中针对不同的样式类型(<code>css</code>,<code>less</code>,<code>scss</code>)有不用的样式穿透方法。</p>
<ul>
<li><code>css</code> 使用 <code>&gt;&gt;&gt;</code></li>
<li><code>less</code> 使用 <code>/deep/</code></li>
<li><code>scss</code> 使用 <code>::v-deep</code></li>
</ul>
<p>1.css</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;<span class="selector-tag">style</span> <span class="selector-tag">scoped</span>&gt;</span><br><span class="line">    &gt;&gt;&gt; <span class="selector-class">.c1</span> <span class="selector-class">.c2</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: green <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br></pre></td></tr></table></figure>
<p>2.less</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style scoped lang=&quot;less&quot;&gt;</span><br><span class="line">    /<span class="selector-tag">deep</span>/ <span class="selector-class">.c1</span> <span class="selector-class">.c2</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: green <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br></pre></td></tr></table></figure>
<p>3.scss</p>
<figure class="highlight css"><table><tr><td class="code"><pre><span class="line">&lt;style scoped lang=”scss“&gt;</span><br><span class="line">    <span class="selector-pseudo">::v-deep</span> <span class="selector-class">.c1</span> <span class="selector-class">.c2</span>&#123;</span><br><span class="line">        <span class="attribute">color</span>: green <span class="meta">!important</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/<span class="selector-tag">style</span>&gt;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>换行步骤条</tag>
      </tags>
  </entry>
  <entry>
    <title>01_git 简介</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/01-git-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="集中式-svn"><a href="#集中式-svn" class="headerlink" title="集中式(svn)"></a>集中式(svn)</h3><p>svn因为每次存的都是差异 需要的硬盘空间会相对的小一点  可是回滚的速度会很慢<br>优点:<br>    代码存放在单一的服务器上 便于项目的管理</p>
<a id="more"></a>

<p>缺点:<br>    服务器宕机: 员工写的代码得不到保障<br>    服务器炸了: 整个项目的历史记录都会丢失</p>
<h3 id="分布式-git"><a href="#分布式-git" class="headerlink" title="分布式(git)"></a>分布式(git)</h3><p>git每次存的都是项目的完整快照 需要的硬盘空间会相对大一点<br>    (Git团队对代码做了极致的压缩 最终需要的实际空间比svn多不了太多 可是Git的回滚速度极快)<br>优点:<br>    完全的分布式<br>缺点:<br>    学习起来比SVN难一点</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>vue之换行步骤条</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/14-vue%E4%B9%8B%E6%8D%A2%E8%A1%8C%E6%AD%A5%E9%AA%A4%E6%9D%A1/</url>
    <content><![CDATA[<h2 id="vue之换行步骤条"><a href="#vue之换行步骤条" class="headerlink" title="vue之换行步骤条"></a>vue之换行步骤条</h2><h3 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h3><p><a href="https://imgse.com/i/zSEAJO"><img src="https://s1.ax1x.com/2022/11/09/zSEAJO.png" alt="zSEAJO.png"></a></p>
<h3 id="首页需要这样的展示图，网上百度了半天，找了个类似的但是有很多问题。在此基础上优化了，直接上代码"><a href="#首页需要这样的展示图，网上百度了半天，找了个类似的但是有很多问题。在此基础上优化了，直接上代码" class="headerlink" title="首页需要这样的展示图，网上百度了半天，找了个类似的但是有很多问题。在此基础上优化了，直接上代码"></a>首页需要这样的展示图，网上百度了半天，找了个类似的但是有很多问题。在此基础上优化了，直接上代码</h3><a id="more"></a>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;main&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">Steps</span> <span class="attr">:stepInfo</span>=<span class="string">&quot;stepInfo&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">Steps</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> Steps <span class="keyword">from</span> <span class="string">&#x27;./components/Steps&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line">  components: &#123; Steps &#125;,</span><br><span class="line">  data () &#123;</span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      stepInfo: &#123;</span><br><span class="line">        list: [</span><br><span class="line"><span class="javascript">            &#123; <span class="attr">status</span>: <span class="string">&#x27;1&#x27;</span>,  &#125;,</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">status</span>: <span class="string">&#x27;2&#x27;</span>,  &#125;,</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">status</span>: <span class="string">&#x27;3&#x27;</span>,  &#125;,</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">status</span>: <span class="string">&#x27;4&#x27;</span>,  &#125;,</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">status</span>: <span class="string">&#x27;5&#x27;</span>,  &#125;,</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">status</span>: <span class="string">&#x27;6&#x27;</span>,  &#125;,</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">status</span>: <span class="string">&#x27;7&#x27;</span>,  &#125;,</span></span><br><span class="line"><span class="javascript">            &#123; <span class="attr">status</span>: <span class="string">&#x27;8&#x27;</span>,  &#125;,</span></span><br><span class="line">        ],</span><br><span class="line">        step: 7</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="上面代码是调用的组件，下面是封装好的换行步骤条组件-注意传入的list必须是双数的-不行就加个开始或者结束"><a href="#上面代码是调用的组件，下面是封装好的换行步骤条组件-注意传入的list必须是双数的-不行就加个开始或者结束" class="headerlink" title="上面代码是调用的组件，下面是封装好的换行步骤条组件(注意传入的list必须是双数的,不行就加个开始或者结束)"></a>上面代码是调用的组件，下面是封装好的换行步骤条组件(注意传入的list必须是双数的,不行就加个开始或者结束)</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;stepOut&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span> <span class="attr">style</span>=<span class="string">&quot;width: 100%&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">&quot;stepItem&quot;</span> <span class="attr">v-for</span>=<span class="string">&quot;(stepItem, index) in stepInfo.list&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;index&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;index&gt;noIndex-1?&#x27;right&#x27;:&#x27;&#x27;&quot;</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;width:100/noIndex+&#x27;%&#x27;&#125;&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 模拟步骤条的节点，此处为圆圈 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;stepInfo.step &gt;= index+1 ? &#x27;icon active&#x27;:&#x27;icon&#x27;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 模拟步骤条连接线，动态显示  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;index != noIndex-1&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;index&gt;noIndex?stepInfo.step &gt;= index+1 ? &#x27;line lineActive&#x27;:&#x27;line&#x27;:stepInfo.step &gt;= index+2 ? &#x27;line lineActive&#x27;:&#x27;line&#x27;&quot;</span> <span class="attr">v-show</span>=<span class="string">&quot;index!==noIndex&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--     showWrap主要用于隐藏转弯处多出的左半部分边框   --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;showWrap&quot;</span> <span class="attr">v-if</span>=<span class="string">&quot;index == noIndex-1&quot;</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">div</span> <span class="attr">:class</span>=<span class="string">&quot;stepInfo.step &gt;= index+2  ? &#x27;lineCircle lineCircleActive&#x27;:&#x27;lineCircle&#x27;&quot;</span> &gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!-- 步骤名称  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;stepInfo.step &gt;= index+1 ? &#x27;stepStatus activeColor&#x27;:&#x27;stepStatus&#x27;&quot;</span>&gt;</span>&#123;&#123;stepItem.status&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 步骤时间  --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span> <span class="attr">:class</span>=<span class="string">&quot;stepInfo.step &gt;= index+1 ? &#x27;statusTime activeColor&#x27;:&#x27;statusTime&#x27;&quot;</span>&gt;</span>&#123;&#123;stepItem.statusTime&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;Steps&#x27;</span>,</span></span><br><span class="line">  props: &#123;</span><br><span class="line"><span class="javascript">    <span class="comment">// 传递步骤参数 注意传入的list必须是双数的,不行就加个开始或者结束</span></span></span><br><span class="line">    stepInfo: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Object</span>,</span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line">          list: [],</span><br><span class="line">          step: 0</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line">      noIndex:0,</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">mounted</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">this</span>.getInit()</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">getInit</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.noIndex = <span class="built_in">this</span>.stepInfo.list.length/<span class="number">2</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">lang</span>=<span class="string">&quot;less&quot;</span> <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="css"><span class="selector-class">.stepOut</span> &#123;</span></span><br><span class="line">  margin-left: -15px;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 70px;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: center;</span><br><span class="line"><span class="css">  <span class="selector-class">.stepItem</span> &#123;</span></span><br><span class="line">    //width: 260px;</span><br><span class="line">    height: 70px;</span><br><span class="line">    float: left;</span><br><span class="line">    font-family: SimSun;</span><br><span class="line">    font-size: 16px;</span><br><span class="line">    text-align: center;</span><br><span class="line">    position: relative;</span><br><span class="line"><span class="css">    <span class="selector-class">.showWrap</span>&#123;</span></span><br><span class="line">      width: 50%;</span><br><span class="line">      height: 100%;</span><br><span class="line">      position: absolute;</span><br><span class="line">      top: 6px;</span><br><span class="line">      right: 0;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.lineCircle</span>&#123;</span></span><br><span class="line">      //left: 52%;</span><br><span class="line">      position: absolute;</span><br><span class="line">      display: block;</span><br><span class="line">      border-left-color: white;</span><br><span class="line">      border-left-width: 0px;</span><br><span class="line">      width: 100%;</span><br><span class="line">      border-color: white white white white;</span><br><span class="line">      border-left-style: hidden;</span><br><span class="line">      border-left: none;</span><br><span class="line">      border-top: 1px dashed rgba(3, 2, 2, 0.7);</span><br><span class="line">      border-right: 1px dashed rgba(3, 2, 2, 0.7);</span><br><span class="line">      border-bottom: 1px dashed rgba(3, 2, 2, 0.7);</span><br><span class="line">      border-bottom: 1p dashed rgba(3, 2, 2, 0.7);</span><br><span class="line">      border-left: 0px dashed rgba(3, 2, 2, 0.7);</span><br><span class="line">      height: 100%;</span><br><span class="line">      border-radius: 0px 25px 25px 0px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    //&amp;<span class="selector-pseudo">:nth-child(n+4)</span>&#123;</span></span><br><span class="line">    //  float: right !important;</span><br><span class="line">    //  right: 12%;</span><br><span class="line">    //&#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.lineCircleActive</span>&#123;</span></span><br><span class="line">      border-bottom: 1px solid green;</span><br><span class="line">      border-top: 1px solid green;</span><br><span class="line">      border-right: 1px solid green;</span><br><span class="line">      border-bottom: 1px solid green;</span><br><span class="line">      border-bottom: 1p solid green;</span><br><span class="line">      border-left: 0px solid green;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    //&amp;<span class="selector-pseudo">:nth-child(5)</span>&#123;</span></span><br><span class="line"><span class="css">    //  <span class="selector-class">.line</span>&#123;</span></span><br><span class="line">    //    display: none;</span><br><span class="line">    //  &#125;</span><br><span class="line">    //</span><br><span class="line">    //&#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.icon</span> &#123;</span></span><br><span class="line">      width: 13px;</span><br><span class="line">      height: 13px;</span><br><span class="line">      border-radius: 50%;</span><br><span class="line">      background: rgba(226, 226, 226, 1);</span><br><span class="line">      margin: 0 auto;</span><br><span class="line">      position: relative;</span><br><span class="line">      z-index: 888;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.active</span> &#123;</span></span><br><span class="line">      background-color: green;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.line</span> &#123;</span></span><br><span class="line">      position: absolute;</span><br><span class="line">      top: 6px;</span><br><span class="line">      left: 50%;</span><br><span class="line">      border-bottom: 1px dashed rgba(3, 2, 2, 0.7);</span><br><span class="line">      width: 100%;</span><br><span class="line">      z-index: 111;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.lineActive</span> &#123;</span></span><br><span class="line">      border-bottom: 1px solid green;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.stepStatus</span> &#123;</span></span><br><span class="line">      color: rgba(87, 87, 87, 1);</span><br><span class="line">      line-height: 36px;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.statusTime</span> &#123;</span></span><br><span class="line">      color: rgba(87, 87, 87, 1);</span><br><span class="line">      opacity: 0.5;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="css">    <span class="selector-class">.activeColor</span>&#123;</span></span><br><span class="line">      color: green;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="css">  <span class="selector-class">.right</span>&#123;</span></span><br><span class="line">    float: right;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/wangliko/p/14768881.html">自定义基于element UI 换行步骤条</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
        <tag>换行步骤条</tag>
      </tags>
  </entry>
  <entry>
    <title>02_Git的基本理论</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/02-Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>类似于qq的下一步 下一步</p>
<p>查看版本号</p>
<p>git –version</p>
<a id="more"></a>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>git config –global user.name ysj</p>
<p>git config –global user.email <a href="mailto:&#x79;&#115;&#106;&#49;&#x38;&#48;&#51;&#55;&#51;&#x31;&#x36;&#52;&#51;&#51;&#64;&#x31;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;">&#x79;&#115;&#106;&#49;&#x38;&#48;&#51;&#55;&#51;&#x31;&#x36;&#52;&#51;&#51;&#64;&#x31;&#54;&#x33;&#x2e;&#99;&#111;&#x6d;</a></p>
<p>git config –list</p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>​        Git 的核心部分是一个简单的键值对数据库。你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索该内容</p>
<p>​        Git 存储内容的方式：一个文件对应一条内容。校验和的前两个字符用于命名子目录，余下的38个字符则用作文件名。</p>
<p>​        在 Git 中，<font color="deeppink"><strong>文件名并没有被保存</strong></font>——我们仅保存了文件的内容</p>
<p>​        <strong><font color="deeppink">解决方案：树对象</font></strong></p>
<p>​        树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。Git 以一种类似于 UNIX 文件系统的方式存储内容。所有内容均以树对象和数据对象<font color="red">(git对象)</font>的形式存储，其中树对象对应了 UNIX 中的目录项， 数据对象<font color="red">(git对象)</font>则大致上对应文件内容。一个树对象包含了一条或多条记录<font color="cornflowerblue">（每条记录含有一个指向git对象或者子树对象的SHA-1指针，以及相应的模式、类型、文件名信息）。</font>一个树对象也可以包含另一个树对象。</p>
<h3 id="区域（操作时的流程）"><a href="#区域（操作时的流程）" class="headerlink" title="区域（操作时的流程）"></a>区域（操作时的流程）</h3><p><font color="deeppink"><strong>工作区</strong></font>(沙箱环境Git不会管理)</p>
<p><font color="deeppink"><strong>暂存区</strong></font>（不在数据库中，存的是git对象的描述信息，也即在工作区执行（git add ./）命令时文件的描述信息，例如时间戳、内容的长度等，代表了此时文件的状态）(暂存区只有一个存放在根目录下的index文件中)</p>
<p><font color="deeppink"><strong>版本区</strong></font>（将以此版本的暂存区进行以此快照，并存入数据库中）</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p><font color="deeppink"><strong>Git对象</strong></font>（代表文件的一次次版本）只能存数据</p>
<p>​    key：val  组成的键值对（key是val对应的hash）</p>
<p>​                    键值对在Git内部是一个<font color="red"><strong>blob类型</strong></font></p>
<p><font color="deeppink"><strong>树对象</strong></font>（代表项目的一次次版本）</p>
<p><font color="deeppink"><strong>提交对象</strong></font>(对每次提交版本的封装，包括注释)</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>03_Git、linux基本操作</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/03-Git%E3%80%81linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>初始化新仓库：git init</p>
<p><font color="red"><strong>git 目录</strong></font></p>
<p><a href="https://imgchr.com/i/s9SUfK"><img src="https://s3.ax1x.com/2021/01/03/s9SUfK.png" alt="s9SUfK.png"></a></p>
<p>​                    hooks                        目录包含客户端或服务端的钩子脚本；</p>
<a id="more"></a>

<p>​                    info                            包含一个全局性排除文件</p>
<p>​                    logs                            保存日志信息</p>
<p>​                    <font color="red"><strong>objects                     目录存储所有数据内容；</strong></font></p>
<p>​                    <font color="red"><strong>refs                            目录存储指向数据的提交对象的指针（所有分支）</strong></font></p>
<p>​                    config                        文件包含项目特有的配置选项</p>
<p>​                    description                用来显示对仓库的描述信息</p>
<p>​                    <font color="red"><strong>head                        文件指示目前被检出的分支</strong></font></p>
<p>​                    <font color="red"><strong>index                        文件保存暂存区信息</strong></font></p>
<h3 id="git-底层命令："><a href="#git-底层命令：" class="headerlink" title="git 底层命令："></a>git 底层命令：</h3><p><strong>git 对象</strong></p>
<p>​        <font color="blue">git hash-object -w 文件路径</font>（生成一个key(hash值)和val的键值对，并将其<strong>存入.git/objects</strong>）</p>
<p><strong>tree对象</strong></p>
<p>​        <font color="blue">git update-index –add –cacheinfo 10064 hash值 text.txt </font>(此时没有生成树对象,只是向暂存区添加一条记录,让git对象对应上传文件名,并将其<strong>存入.git/index</strong>)</p>
<p>​        <font color="blue">git write-tree</font> (生成树对象,并将其<strong>存入.git/objects</strong>)</p>
<p><strong>commit对象</strong></p>
<p>​        <font color="blue">echo ‘内容’ / git commit-tree treehash值</font>  (生成一个提交对象并将其<strong>存入.git/objects</strong>)</p>
<p><strong>对以上对象的查询:</strong></p>
<p>​        <font color="blue">git cat-file -p hash值</font>  (拿对应对象的内容)</p>
<p>​        <font color="blue">git cat-file -t hash值</font>  (拿对应对象的类型)</p>
<p><strong>查看暂存区:</strong></p>
<p>​        <font color="cornflowerblue">git ls-files -s</font></p>
<h2 id="基础的linux命令"><a href="#基础的linux命令" class="headerlink" title="基础的linux命令"></a>基础的linux命令</h2><p><strong>clear</strong> ：清除屏幕</p>
<p><strong>echo ‘test content’**：往控制台输出信息 **echo ‘test content’ &gt; test.txt</strong></p>
<p><strong>ll</strong>：将当前目录下的 子文件&amp;子目录平铺在控制台</p>
<p><strong>find</strong> <strong>目录名</strong>： 将对应目录下的子孙文件&amp;子孙目录平铺在控制台</p>
<p><strong>find</strong> <strong>目录名</strong> <strong>-type f</strong> ：将对应目录下的文件平铺在控制台</p>
<p><strong>rm</strong>  <strong>文件名 ：</strong> 删除文件</p>
<p><strong>mv</strong> <strong>源文件 重命名文件</strong>: 重命名</p>
<p><strong>cat</strong> <strong>文件的</strong> <strong>url :</strong> 查看对应文件的内容</p>
<h4 id="vim-文件的-url-在英文模式下"><a href="#vim-文件的-url-在英文模式下" class="headerlink" title="vim 文件的 url(在英文模式下)"></a>vim 文件的 url(在英文模式下)</h4><ul>
<li>按 i 进插入模式 进行文件的编辑按 esc 键&amp;按:键 进行命令的执行</li>
<li>q!   强制退出（不保存）</li>
<li>wq  保存退出</li>
<li>set nu 设置行号</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
<p>​    </p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>04_Git常用操作</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a><font color="deeppink">常用命令：</font></h1><h3 id="git高层命令-curd"><a href="#git高层命令-curd" class="headerlink" title="git高层命令(curd)"></a>git高层命令(curd)</h3><ol>
<li><font color="cornflowerblue">git init</font><font color="orange">(初始化仓库)</font></li>
<li><font color="cornflowerblue">git add ./(这是你修改内容的路径./表示当前工作空间根目录，也可写具体文件目录)</font><font color="orange">(将修改添加到暂存区)</font></li>
<li><font color="cornflowerblue">git commit </font><font color="orange">(此时会进入编辑器，用于插入大量的注释)</font></li>
<li><font color="cornflowerblue">git commit -a</font><font color="orange">(跳过使用暂存区)</font><a id="more"></a></li>
<li><font color="cornflowerblue">git commit -m “注释内容”</font><font color="orange">(将暂存区提交到版本库)</font></li>
<li><font color="blue"><strong>git status</strong></font><font color="orange">(查看确定文件当前处于什么状态)</font></li>
<li><font color="blue">git diff</font><font color="orange">(查看当前有哪些更新还没有暂存？)</font></li>
<li><font color="blue">git diff –staged/git diff -–cached</font><font color="orange">(查看有哪些更新已经暂存还没提交)</font></li>
<li><font color="blue"><strong>git ls-files -s</strong></font><font color="orange">(查看暂存区)</font></li>
<li><font color="blue">mv  “原文件名”  “新文件名” </font><font color="orange">(更改文件名，接下来直接提交即可)</font></li>
<li><font color="blue">git rm 文件名 </font><font color="orange">(删除工作目录中的文件，并将该存入缓存区，接下来直接提交即可)</font></li>
<li><font color="blue"><strong>git log(参数：–pretty=oneline 出现在一行/–oneline出现在一行，并简写)</strong></font><font color="orange">(查看当前分支的状态)</font></li>
<li><font color="blue"><strong>git reflog</strong></font><font color="orange">(查看完整的历史记录)</font></li>
<li><font color="cornflowerblue">git log -g</font><font color="orange">(以标准日志的格式输出引用日志)</font></li>
<li><font color="blue"><strong>git config –global alias.加别名 原本命令(不要加git并要加双引号)</strong></font><font color="orange">(git配别名)</font></li>
</ol>
<h3 id="git高层命令-分支"><a href="#git高层命令-分支" class="headerlink" title="git高层命令(分支)"></a>git高层命令(分支)</h3><ol>
<li><p><font color="blue"><strong>git branch</strong></font><font color="orange">(显示分支列表)</font></p>
</li>
<li><p><font color="blue">git branch 分支名</font><font color="orange">(创建分支)</font></p>
</li>
<li><p><font color="blue"><strong>git branch -D 分支名</strong></font><font color="orange">(强行删除分支，但是不能自己删除自己，得切换到其他分支)</font></p>
</li>
<li><p>git branch -v(查看每个分支的最后一次提交)</p>
</li>
<li><p><font color="blue"><strong>git branch 自定义指针名 对应要跳转的分支hash缩写</strong></font><font color="orange">(该操作会在指定的hash对象出新建一个指针)</font></p>
</li>
<li><p><font color="blue"><strong>git switch 分支名</strong>(git checkout 分支名)</font><font color="orange">(切换分支)</font></p>
</li>
<li><p><font color="blue"><strong>git switch -c 分支名(git checkout -b 分支名)</strong></font><font color="orange">(相当于创建分支并切换到该分支)</font></p>
</li>
<li><p><font color="blue"><strong>git merge 分支名</strong></font><font color="orange">(分支合并)</font></p>
</li>
<li><p><font color="blue"><strong>git branch –merged</strong></font><font color="orange">(查看合并到当前分支的分支)一旦出现在该列表中，这些分支就要删除</font></p>
</li>
<li><p><font color="blue"><strong>git branch –no-merged</strong></font><font color="orange"><strong>一旦出现在该列表中，就应该观察一下是否需要合并</strong></font></p>
</li>
<li><p><font color="cornflowerblue">git log –oneline –decorate –graph –all</font><font color="orange">(查看完整分支图，<strong>我已经将该命令配置为了git lol</strong>)</font></p>
</li>
</ol>
<h3 id="git存储命令"><a href="#git存储命令" class="headerlink" title="git存储命令"></a><strong>git存储命令</strong></h3><ol>
<li><font color="blue"><strong>git stash</strong></font><font color="orange">(将未完成的修改保存到一个栈上)</font></li>
<li><font color="blue"><strong>git stash list</strong></font><font color="orange">(查看存储)</font></li>
<li><font color="cornflowerblue">git stash apply stash@{2}</font><font color="orange">(在栈中取出对应的内容但不会从栈中删除)</font></li>
<li><font color="cornflowerblue">git stash drop stash@{2}</font><font color="orange">(将栈中对应的元素删除）</font></li>
<li><font color="blue"><strong>git stash pop stash@{0}</strong></font><font color="orange">(应用栈中对应的元素，并将其从栈中移除）</font></li>
</ol>
<h3 id="restore-恢复-后悔药"><a href="#restore-恢复-后悔药" class="headerlink" title="restore(恢复)后悔药"></a><strong>restore(恢复)后悔药</strong></h3><ol>
<li><font color="blue"><strong>git restore filename</strong>(git checkout –filename)</font><font color="orange">撤回自己在工作目录中的修改</font></li>
<li><font color="blue"><strong>git restore –staged  filename</strong>(git reset HEAD filename)</font><font color="orange">撤回自己的暂存</font></li>
<li><font color="blue"><strong>git restore -s HEAD~1 filename</strong></font><font color="orange">撤回自己的提交</font></li>
<li><font color="blue"><strong>git commit –amend</strong></font><font color="orange">修改上次提交的注释</font></li>
</ol>
<h3 id="reset-重置-三部曲"><a href="#reset-重置-三部曲" class="headerlink" title="reset(重置)三部曲"></a><strong>reset(重置)三部曲</strong></h3><ol>
<li><font color="cornflowerblue">git reset –soft HEAD~</font><font color="orange">(移动HEAD)</font></li>
<li><font color="cornflowerblue">git reset [–mixed] HEAD~</font><font color="orange">(更新暂存区）</font></li>
<li><font color="cornflowerblue">git reset –hard HEAD~</font><font color="orange">(更新工作目录）</font></li>
<li><strong>路径reset</strong></li>
<li><strong><font color="red">checkout与git reset –hard HEAD~的区别</font></strong></li>
</ol>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><ol>
<li>硬重置（不推荐）</li>
<li><strong>使用分支（推荐）</strong></li>
</ol>
<h3 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h3><ol>
<li><font color="blue">git tag v1.4 commitHash</font><font color="orange">创建标签</font></li>
<li><font color="blue">git tag -d tagname</font><font color="orange">删除标签</font></li>
<li><font color="blue">git show tagname</font><font color="orange">查看特定标签</font></li>
<li><font color="blue">git checkout tagname</font><font color="orange">检出标签**(注意使用检出标签后会出现头部分离现象)**</font></li>
</ol>
<h1 id="使用Git步骤："><a href="#使用Git步骤：" class="headerlink" title="使用Git步骤："></a><font color="deeppink">使用Git步骤：</font></h1><p>第一步：创建工作目录  </p>


<p>第二步：开始工作，对工作目录进行修改</p>
<p><font color="cornflowerblue">git add ./（这是你修改内容的路径./表示当前工作空间根目录，也可写具体文件目录）</font><font color="orange">（将修改添加到暂存区）</font></p>
<p>​        <font color="deeppink">这一步是将提交的修改的文件一个一个的存入暂存区（存入暂存区的会将之前的同名文件覆盖）如果该文件未曾被跟踪过则还会将其一个一个存入版本库（存成一个一个的git对象不是覆盖原本的而是创建一个新的）</font></p>
<p>​        <strong>暂存区存的是git对象的描述信息，也即在工作区执行（git add ./）命令时文件的描述信息，例如时间戳、内容的长度等，代表了此时文件的状态</strong></p>
<p>第三步：</p>
<p><font color="cornflowerblue">git commit -m “注释内容”</font><font color="orange">（将暂存区提交到版本库）</font></p>
<p>​        <font color="deeppink">这一步是表示暂存区的内容已经可以达到一个新的版本，需要提交，执行后现将暂存区进行一次快照，然后存入版本库（存入的是一个树对象），然后取出添加注释作者信息等，再将其封装为提交对象存入版本库</font></p>
<h3 id="工作目录下的文件分为两种"><a href="#工作目录下的文件分为两种" class="headerlink" title="工作目录下的文件分为两种"></a><font color="deeppink">工作目录下的文件分为两种</font></h3><ul>
<li><p><font color="red">未跟踪</font>（在显示时为红色）</p>
<p>跟踪文件既没有上次更新时的快照，也不在当前的暂存区域。</p>
</li>
<li><p><font color="red">已跟踪</font></p>
<p>​        已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是<font color="cornflowerblue">已提交（不显示），已修改（在显示时为红色）或者已暂存（在显示时为绿色）</font></p>
</li>
</ul>
<p>使用 Git 时的文件状态变化周期如下图所示</p>
<p><a href="https://imgchr.com/i/s9SBOH"><img src="https://s3.ax1x.com/2021/01/03/s9SBOH.png" alt="s9SBOH.png"></a></p>
<p>​        当一个文件已暂存时，然后对文件进行修改，此时再对文件进行查看状态时，<font color="deeppink">该文件就会出现两个状态：已暂存和已修改（此时当次修改的git对象还未暂存）</font></p>
<p>​        实际上 Git 只不过暂存了你运行git add 命令时的版本，如果现在提交，那么提交的是修改前的版本，而非当前工作目录中的版本。所以，运行了git add 之后又作了修订的文件，需要重新运行git add 把最新版本重新暂存起来。</p>
<p>​        实际上 git status 的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 git diff 命令.这个命令它已经能解决我们</p>
<p><strong>两个问题了：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备好了下次提交？</strong></p>
<ul>
<li>当前做的哪些更新还没有暂存？，</li>
</ul>
<p>命令：git diff（不加参数直接输入 git diff）</p>
<ul>
<li>有哪些更新已经暂存起来准备好了下次提交？</li>
</ul>
<p>命令： git diff -–cached   或者 git diff –staged(1.6.1 以上)</p>
<p><strong>git commit进入编辑模式如何退出：</strong></p>
<p>1.Ubuntu下git commit后进入的是nano界面</p>
<p>2.输入需要内容后按下ctrl+x会提示是否保存</p>
<p>3.输入Y保存后按下回车即可退出</p>
<p><strong>跳过使用暂存区</strong></p>
<p><font color="blue">git commit -a</font></p>
<p>​        尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候， 给 git commit 加上-a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add 步骤</p>
<p><strong>移除文件</strong></p>
<p><font color="blue">git rm 文件名 </font></p>
<p>​        相当于他先把该文件先从工作目录中删除，然后将其提交至缓存区，此时再使用git commit -m ‘注释’将修改后的缓存区快照存入版本库</p>
<p>并没有真正的删除文件，对之前的版本可内的记录没有任何影响</p>
<p><strong>文件改名</strong></p>
<p><font color="blue">mv  “原文件名”  “新文件名” </font></p>
<p>其实低层做的是先删除原文件再添加源文件</p>
<p>​        做完该操作依旧需要将文件加入缓存区，缓存区快照加入版本库</p>
<p><strong>查看暂存区</strong></p>
<p><font color="blue"><strong>git ls-files -s</strong></font></p>
<p><strong>查看历史记录</strong></p>
<p><font color="blue">git log（按q退出）</font></p>
<p><font color="blue">git log –pretty=oneline （出现在一行）</font></p>
<p><font color="blue">git log –oneline（出现在一行，并简写）</font></p>
<p><font color="blue"><strong>git reflog</strong></font></p>
<p><strong>只要head有变化,那么git reflog就会记录下来而git log当前分支的状态(不包括撤回和删除的内容)</strong></p>
<p><font color="deeppink"><strong>配置别名</strong></font></p>
<p><font color="cornflowerblue"><strong>git config –global alias.加别名 原本命令</strong></font></p>
<p><font color="red"><strong>注意:后边的原命令不能加git,如果原命令不止一个单词还要加双引号</strong></font></p>
<p>例如:</p>
<p>将查看完整分支图git log –oneline –decorate –graph –all这个命令配置为git lol则输入以下命令:</p>
<p><font color="blue">git config –global alias.lol “log –oneline –decorate –graph –all”</font></p>
<h2 id="分支操作-时光机-杀手功能"><a href="#分支操作-时光机-杀手功能" class="headerlink" title="分支操作(时光机)杀手功能"></a><font color="deeppink">分支操作(时光机)杀手功能</font></h2><p>​        使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 </p>
<p><font color="red"><strong>分支就是指向最新提交对象的指针</strong></font></p>
<p>​        我们知道HEAD本质指向一个分支，分支的本质是一个提交对象<br>​        提交对象指向一个树对象，树对象又很有可能指向多个git对象，一个git对象代表一个文件!!!<br>​        HEAD可以代表一系列文件的状态!!!!</p>
<h4 id="查看分支列表"><a href="#查看分支列表" class="headerlink" title="查看分支列表"></a><strong>查看分支列表</strong></h4><p><font color="blue">git branch</font></p>
<h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支:"></a><strong>创建分支:</strong></h4><p><font color="cornflowerblue">git branch 分支名</font></p>
<p>​        为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支：git branch testing。这会在当前所在的提交对象上创建一个指针。<font color="red"><strong>注意！创建 一个新分支，并不会自动切换到新分支中去</strong></font></p>
<h4 id="显示分支列表"><a href="#显示分支列表" class="headerlink" title="显示分支列表"></a><strong>显示分支列表</strong></h4><p><font color="blue">git branch</font></p>
<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a><strong>删除分支</strong></h4><p><font color="blue">git branch -D/-d 分支名</font>(小写是删除已经合并过的分支，大写是强制删除没有合并过的分支)</p>
<p><font color="deeppink"><strong>注意：假如当前处在a分支上就不能删除a分支(不能自己删除自己)需要先转到其他分支才能删除a分支</strong></font></p>
<p><strong>当文件处于未跟踪状态时使用强制删除命令会<font color="red">引发数据丢失的风险</font>，它也是 Git 会<font color="red">真正地销毁数据</font>的仅有的几个操作之一</strong></p>
<h4 id="查看每个分支最后一次提交"><a href="#查看每个分支最后一次提交" class="headerlink" title="查看每个分支最后一次提交"></a><strong>查看每个分支最后一次提交</strong></h4><p><font color="blue">git branch -v</font></p>
<p><strong><font color="red">分支的本质其实就是一个提交对象!!!</font></strong></p>
<p><strong><font color="red">HEAD: 是一个指针 它默认指向master分支 切换分支时其实就是让HEAD指向不同的分支 每次有新的提交时 HEAD都会带着当前指向的分支 一起往前移动</font></strong></p>
<p><font color="blue">git branch 自定义指针名 对应要跳转的分支hash缩写</font>(该操作会在指定的hash对象出新建一个指针,但现在指针指向并没有切过去,要手动切过去)</p>
<h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a><strong>切换分支</strong></h4><p><font color="cornflowerblue">git switch 分支名(git checkout 分支名)</font></p>
<p><font color="blue">git switch -c 分支名(git checkout -b 分支名)</font><font color="orange">(相当于创建分支并切换到该分支)</font></p>
<p><strong><font color="red">新建一个分支并且使指针指向对应的分支对象</font></strong></p>
<p><font color="red"><strong>切换分支会更改三个地方:</strong></font></p>
<p>​        <strong>HEAD</strong>(对应的指针指向改变)</p>
<p>​        <strong>暂存区</strong>(暂存区内容跟随改变)</p>
<p>​        <strong>工作目录</strong>(工作目录内容跟随改变)</p>
<p>​        <strong>暂存区不会动(他只会一直增多)</strong></p>
<p><font color="deeppink"><strong>最佳实践：每次切换分支前,当前分支一定得是已经提交的状态(干净的)！！！</strong></font></p>
<h4 id="切换分支的坑！！！"><a href="#切换分支的坑！！！" class="headerlink" title="切换分支的坑！！！"></a><font color="red"><strong>切换分支的坑！！！</strong></font></h4><p>​        <strong>在切换分支时，如果当前分支上有未暂存的修改(第一次) 或者 有未提交的暂存(第一次)，分支可以切换成功，但是这种操作可能会污染其他分支</strong></p>
<p>​        如果不是第一次（该文件已经在此分支上提交过一次），如果在不是已经提交的状态下切换文件，此时就会提醒，不允许切换分支。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><font color="red"><strong>注意点</strong></font></h4><p><font color="deeppink"><strong>在切换的时候 一定要保证当前分支是干净的!!!</strong></font></p>
<p><font color="Cyan"><strong>允许切换分支:</strong></font><br>   分支上所有的内容处于 已提交状态<br>    <strong>(避免)**分支上的内容是初始化创建 处于未跟踪状态<br>    **(避免)**分支上的内容是初始化创建 第一次处于已暂存状态<br><font color="Cyan">**不允许切分支:</font></strong><br>     分支上所有的内容处于 已修改状态  或 第二次以后的已暂存状态  </p>
<p><font color="Cyan"><strong>在分支上的工作做到一半时 如果有切换分支的需求, 我们应该将现有的工作存储起来</strong></font><br>    git stash : 会将当前分支上的工作推到一个栈中<br>    分支切换  进行其他工作 完成其他工作后 切回原分支<br>    git stash apply : 将栈顶的工作内容还原 但不让任何内容出栈<br>    git stash drop  : 取出栈顶的工作内容后 就应该将其删除(出栈)<br>    git stash pop   :      git stash apply +  git stash drop<br>    git stash list : 查看存储</p>
<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a><strong>合并分支</strong></h4><p><font color="blue">git merge 分支名</font></p>
<p>得先回到主分支，再将该分支合并到主分支（快进合并）快进合并不会产生冲突，但是对后续的合并有可能产生冲突</p>
<p>例子：</p>
<p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201208195953748.png" alt="image-20201208195953748"></p>
<p>此时将hotbug合并到主分支</p>
<p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201208200009367.png" alt="image-20201208200009367"></p>
<p>此时iss53就变成了过期的分支，在iss53分支中看不到c4中更改的内容，在这种情况下，iss53继续工作</p>
<p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201208200131377.png" alt="image-20201208200131377"></p>
<p>如果在iss53工作中野更改了c4中更改的内容，iss53工作完成了需要合并到主分支</p>
<p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201208202429549.png" alt="image-20201208202429549"></p>
<p>你在此时合并到主分支时就会存在冲突：你在该分支也更改了c4分支更改的文件，使用git merge iss53后会<strong>产生冲突</strong>，此时就需要打开冲突的文件进行<strong>解决冲突</strong>(修改业务逻辑)，然后使用git add ./ 然后提交到版本库再将分支删除就会<strong>完成冲突的解决(这种叫做典型合并即自己与自己的冲突)</strong><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201208202411314.png" alt="image-20201208202411314"></p>
<h4 id="查看合并到当前分支的分支"><a href="#查看合并到当前分支的分支" class="headerlink" title="查看合并到当前分支的分支"></a>查看合并到当前分支的分支</h4><p><font color="blue"><strong>git branch –merged</strong></font></p>
<p><font color="orange"><strong>一旦出现在该列表中，这些分支就要删除</strong></font></p>
<h4 id="查看没有合并到当前分支的分支"><a href="#查看没有合并到当前分支的分支" class="headerlink" title="查看没有合并到当前分支的分支"></a>查看没有合并到当前分支的分支</h4><p><font color="blue"><strong>git branch –no-merged</strong></font></p>
<p><font color="orange"><strong>一旦出现在该列表中，就应该观察一下是否需要合并</strong></font></p>
<h4 id="分支模式"><a href="#分支模式" class="headerlink" title="分支模式"></a><strong>分支模式</strong></h4><p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/01.png" alt="01"></p>
<p>在master下创建一个新的分支（取名为develop自己花名）<font color="orange"><strong>develop和master分支被叫做长期分支</strong></font></p>
<p>然后在自己的分支上创建各种功能分支（在完成功能后合并到自己的分支上）</p>
<h4 id="分支的本质"><a href="#分支的本质" class="headerlink" title="分支的本质"></a><strong>分支的本质</strong></h4><p><font color="red"><strong>Git 的分支，其实本质上仅仅是指向提交对象的可变指针</strong></font></p>
<p>​        分支就是一个没有后缀名的文件(提交对象)内部存储的是一个hsah值（存储在.git\refs\heads中）</p>
<p>​        那个可变指针是head（存储在根目录的HEAD文件中），每次移动的都是head，这个可变指针head带着提交对象移动。</p>
<h4 id="查看完整分支图"><a href="#查看完整分支图" class="headerlink" title="查看完整分支图"></a><strong>查看完整分支图</strong></h4><p><font color="blue">git log –oneline –decorate –graph –all</font></p>
<p>注意工作时整个分支图有可能很大（我已经将该命令配置为了git lol）</p>
<h2 id="Git存储"><a href="#Git存储" class="headerlink" title="Git存储"></a><font color="deeppink">Git存储</font></h2><p>当你在一个分支上的任务还未完成时，你需要切换分支，此时由于任务未完成，又不想提交，就可以使用git存储功能。</p>
<p>其实他帮你做了一次提交但是此次提交不会在git log –oneline中显示（但是通过查看完整分支图的命令会看到）</p>
<p>**<font color="blue">git stash</font>**将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动</p>
<p><strong><font color="blue">git stash list</font>查看存储</strong></p>
<p><font color="cornflowerblue">git stash apply stash@{2}</font>在栈中取出对应的内容但不会从栈中删除，如果不指定一个储藏，Git 认为指定的是最近的储藏</p>
<p><font color="cornflowerblue">git stash drop stash@{2} </font>将栈中对应元素删除</p>
<p><strong><font color="blue">git stash pop  stash@{2} </font>应用栈中对应元素并将其从栈中移除</strong></p>
<h2 id="撤回操作-后悔药"><a href="#撤回操作-后悔药" class="headerlink" title="撤回操作(后悔药)"></a><font color="deeppink"><strong>撤回操作(后悔药)</strong></font></h2><h4 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a><strong>工作区</strong></h4><p>​        如何撤回自己在工作目录中的修改</p>
<p>​        <font color="cornflowerblue">git restore filename(git checkout –filename)</font></p>
<p>​        <font color="red"><strong>注意：</strong></font>这是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。除非你确实清楚不想要那个文件了， 否则不要使用这个命令</p>
<p><font color="orange"><strong>git restore是默认带着–worktree参数的</strong></font></p>
<p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201209092213576.png" alt="image-20201209092213576"></p>
<p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201209092106548.png" alt="image-20201209092106548"></p>
<h4 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a><strong>暂存区</strong></h4><p>​        如何撤回自己的暂存</p>
<p>​        <font color="cornflowerblue">git restore –staged  filename(git reset [HEAD] filename)</font></p>
<h4 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a><strong>版本库</strong></h4><p>​        如何撤回自己的提交（实际上没有撤销只是重新存入一份之前的一份在git log中看不到，在git reflog中能看到）</p>
<p>​        <font color="cornflowerblue">git restore -s HEAD~1 filename </font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ git restore -s HEAD~<span class="number">1</span> READEME.md  <span class="comment">// 该命名表示将版本回退到当前快照的前一个版本</span></span><br><span class="line">$ git restore -s <span class="number">91410</span>eb9  READEME.md  <span class="comment">// 改命令指定明确的 commit id ，回退到指定的快照中</span></span><br><span class="line">$ git reset --soft HEAD^  <span class="comment">// 该命令表示撤销 commit 至上一次 commit 的版本</span></span><br></pre></td></tr></table></figure>
<p><strong>如果文件仅仅是注释写错了可以使用<font color="cornflowerblue">git commit –amend</font></strong></p>
<h2 id="reset三部曲"><a href="#reset三部曲" class="headerlink" title="reset三部曲"></a><font color="deeppink"><strong>reset三部曲</strong></font></h2><h3 id="移动HEAD"><a href="#移动HEAD" class="headerlink" title="移动HEAD"></a><strong>移动HEAD</strong></h3><p>​        <font color="cornflowerblue">git reset –soft HEAD~</font>(回到上一次提交对象)</p>
<p><font color="deeppink">(后边的HEAD~是个参数可写想要去的对象的hash)</font></p>
<p><font color="red"><strong>等价于后悔药版本库中的git commit –amend</strong></font></p>
<p>​        动HEAD(带着分支一起走)</p>
<p>​        而不动暂存区和工作目录</p>
<h3 id="更新暂存区-索引"><a href="#更新暂存区-索引" class="headerlink" title="更新暂存区(索引)"></a><strong>更新暂存区(索引)</strong></h3><p>​        <font color="cornflowerblue">git reset [–mixed] HEAD~</font>(回到上一次提交对象)</p>
<p><font color="deeppink">(后边的HEAD~是个参数可写想要去的对象的hash)</font></p>
<p><font color="red"><strong>等价于后悔药暂存库中的git reset HEAD filename</strong></font></p>
<p>​        动HEAD(带着分支一起走)</p>
<p>​        动暂存区</p>
<p>​        而不动工作目录</p>
<h3 id="更新工作目录"><a href="#更新工作目录" class="headerlink" title="更新工作目录"></a><strong>更新工作目录</strong></h3><p><font color="cornflowerblue">git reset –hard HEAD~</font>(回到上一次提交对象)</p>
<p>​    <font color="deeppink">(后边的HEAD~是个参数可写想要去的对象的hash)</font></p>
<p>​    <font color="red"><strong>类似于后悔药工作区中的git checkout –filename</strong></font></p>
<p>​        动HEAD(带着分支一起走)</p>
<p>​        动暂存区</p>
<p>​        动工作目录</p>
<p><font color="deeppink"><strong>该操作有危险不要用</strong></font></p>
<h4 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a><font color="red"><strong>注意点</strong></font></h4><p>​        必须注意，**–hard<strong>标记是</strong>reset<strong>命令<font color="red">**唯一的危险用法</font></strong>，它也是 Git 会<font color="red"><strong>真正地销毁数据</strong></font>的仅有的几个操作之一。 其他任何形式的<strong>reset</strong>调用都可以轻松撤消，但是**–hard**选项不能，因为它强制覆盖了工作目录中的文件。</p>
<p>​        在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 <strong>v3</strong> 版本， 我们可以通过reflog来找回它。但是若该文件还未提交，Git    仍会覆盖它从而导致无法恢复。 </p>
<h3 id="路径reset-只有–mixed才能跟路径"><a href="#路径reset-只有–mixed才能跟路径" class="headerlink" title="路径reset(只有–mixed才能跟路径)"></a>路径reset(只有–mixed才能跟路径)</h3><p><strong>所有的路径reset都要省略第一步！！！</strong></p>
<p>​        第一步是重置HEAD内容，我们知道HEAD本质指向一个分支 分支的本质是一个提交对象<br>​        提交对象指向一个树对象，树对象又很有可能指向多个git对象，一个git对象代表一个文件!!!<br>​        HEAD可以代表一系列文件的状态!!!!</p>
<p><font color="cornflowerblue">git reset [–mixed] HEAD filename     </font></p>
<p>​        原本是git reset [–mixed] HEADhsah。他的作用是更新暂存区，更改了HEAD和暂存区。但现在在后面加了一个文件名(因为第一步是更改head指向他不能指向一个文件,他只会指向一个树对象)所以这个HEADhsah就可不要(此时第一步也不会执行)最终变成<strong>git reset  filename</strong></p>
<p>​    reset 将会跳过第 1 步(即不更改HEAD)</p>
<p>​    只动了暂存区</p>
<p>​    不改工作目录</p>
<h3 id="checkout与git-reset-–hard-HEAD-的区别"><a href="#checkout与git-reset-–hard-HEAD-的区别" class="headerlink" title="checkout与git reset –hard HEAD~的区别"></a><font color="red"><strong>checkout与git reset –hard HEAD~的区别</strong></font></h3><p><font color="deeppink"><strong>git checkout 跟hash(分支名)</strong></font></p>
<p><font color="cornflowerblue">git  checkout 分支名(commithash)</font>与<font color="cornflowerblue">git reset –hard 提交对象(commithash)</font> 很相似     </p>
<p>​    两者都重置了HEAD，暂存区和工作目录</p>
<p>区别是：</p>
<ol>
<li><p>checkout只动HEAD(将head换到另一个分支)    </p>
<p>–hard动HEAD并带着分支一起走</p>
</li>
<li><p>checkout对工作目录是安全的(去看切换分支的坑)   </p>
<p>–hard是强制覆盖工作目录(该操作有危险不要用)</p>
</li>
</ol>
<p><font color="deeppink"><strong>git checkout 跟路径(文件名)</strong></font></p>
<p>git checkout –filename 相比于 git reset –hard  commitHash(只有–mixed才能跟路径)<br>      第一  第二步都没做(HEAD和暂存区都不动)<br>      只会动了工作目录</p>
<p><font color="deeppink">git checkout 跟hash和路径</font>(该命令基本不用)</p>
<p>git checkout  commithash filename</p>
<p>​      将会跳过第 1 步 (更改HEAD)<br>​      更新暂存区<br>​      更新工作目录   </p>
<h2 id="数据恢复-1"><a href="#数据恢复-1" class="headerlink" title="数据恢复"></a>数据恢复</h2><ol>
<li><h3 id="硬重置-不建议使用"><a href="#硬重置-不建议使用" class="headerlink" title="硬重置(不建议使用)"></a>硬重置(不建议使用)</h3><p>假设你提交了5次，我们将master分支硬重置到第三次提交</p>
<p><font color="cornflowerblue">git reset –hard 第三次hash</font></p>
<p>现在后两个的提交已经丢失，我们可以通过git reflog查看丢失的提交记录(存放在.git/logs/HEAD文件中)。</p>
<p>此时恢复回第五次提交就再次使用硬重置</p>
<p><font color="cornflowerblue">git rest –hard 第五次hash</font></p>
</li>
</ol>
<ol start="2">
<li><h3 id="使用分支-推荐使用"><a href="#使用分支-推荐使用" class="headerlink" title="使用分支(推荐使用)"></a>使用分支(推荐使用)</h3><p>看起来下面的那个就是你丢失的提交，你可以通过创建一个新的分支，指向这个提交来恢复它 。 例如，你可以创建一个 名为recover-branch 的分支指向这个提交（ab1afef）</p>
<p><font color="blue"><strong>git branch recover-branch ab1afef</strong></font></p>
<p>现在有一个名为 recover-branch 的分支是你的 master 分支曾经指向的地方，再一次使得前两次提交可到达了。</p>
</li>
</ol>
<h2 id="打tag-1"><a href="#打tag-1" class="headerlink" title="打tag"></a>打tag</h2><p>​        <font color="orange"><strong>标签就像一个不会动的分支</strong></font></p>
<p>​        Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><ol>
<li><p><strong>轻量标签</strong>很像一个不会改变的分支 - 它只是一个特定提交的引用</p>
<p><strong><font color="blue">git tag v1.4</font></strong></p>
<p><strong><font color="blue">git tag v1.4 commitHash</font></strong></p>
</li>
<li><p><strong>附注标签</strong>是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子 邮件地址、日期时间；还有一个标签信息；通常建议 创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p>
<p><strong><font color="blue">git tag -a v1.4</font></strong></p>
<p><strong><font color="blue">git tag -a v1.4 commitHash</font></strong></p>
<p><strong><font color="blue">git tag -a v1.4 commitHash -m ‘my version 1.4’</font></strong></p>
</li>
</ol>
<h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p><font color="blue">git tag</font></p>
<p><font color="cornflowerblue">git tag -l ‘v1.8.5*’</font>（显示出v1.8.5系列）</p>
<h3 id="查看特定标签"><a href="#查看特定标签" class="headerlink" title="查看特定标签"></a>查看特定标签</h3><p>​        git show 可以显示任意类型的对象（git 对象 树对象 提交对象 tag 对象）</p>
<p>​        <font color="cornflowerblue">git show tagname</font></p>
<h3 id="远程标签"><a href="#远程标签" class="headerlink" title="远程标签"></a>远程标签</h3><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p><strong><font color="blue">git tag -d tagname</font></strong></p>
<h3 id="检出标签-头部分离"><a href="#检出标签-头部分离" class="headerlink" title="检出标签(头部分离)"></a>检出标签(<font color="deeppink">头部分离</font>)</h3><p><strong><font color="blue">git checkout tagname</font></strong></p>
<p><strong>使用检出标签后会出现<font color="deeppink">头部分离</font>状态（HEAD指针到了标签的位置但是该指针没有指向一个分支）</strong>如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非访问确切的提交哈希。<strong>因此当使用检出标签后<font color="deeppink">需要创建一个新分支</font></strong></p>
<p><strong><font color="blue">git checkout -b 分支名</font></strong></p>
<h1 id="Git特点"><a href="#Git特点" class="headerlink" title="Git特点"></a>Git特点</h1><ol>
<li><h3 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h3></li>
<li><h3 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h3></li>
<li><h3 id="时刻保持数据完整性"><a href="#时刻保持数据完整性" class="headerlink" title="时刻保持数据完整性"></a>时刻保持数据完整性</h3></li>
<li><h3 id="多数操作仅添加数据"><a href="#多数操作仅添加数据" class="headerlink" title="多数操作仅添加数据"></a>多数操作仅添加数据</h3></li>
<li><h3 id="文件的三种状态"><a href="#文件的三种状态" class="headerlink" title="文件的三种状态"></a>文件的三种状态</h3></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>07_总结</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/07-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><p>git –version</p>
</li>
<li><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a><strong>初始化配置</strong></h3><p>git config –global user.name “damu”<br>git config –global user.email </p>
<p>git config –list</p>
<a id="more"></a>
</li>
<li><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a><strong>初始化仓库</strong></h3><p>git init</p>
</li>
<li><h3 id="C-新增"><a href="#C-新增" class="headerlink" title="C(新增)"></a><strong>C(新增)</strong></h3><p>在工作目录中新增文件<br>git status<br>git add ./<br>git commit -m “msg”  </p>
</li>
<li><h3 id="U-修改"><a href="#U-修改" class="headerlink" title="U(修改)"></a><strong>U(修改)</strong></h3><p>在工作目录中修改文件<br>git status<br>git add ./<br>git commit -m “msg”</p>
</li>
<li><h3 id="D-删除-amp-重命名"><a href="#D-删除-amp-重命名" class="headerlink" title="D(删除&amp;重命名)"></a><strong>D(删除&amp;重命名)</strong></h3><p>git rm 要删除的文件     git mv 老文件 新文件<br>git  status             git  status<br>git commit -m “msg”     git commit -m “msg”</p>
</li>
<li><h3 id="R-查询"><a href="#R-查询" class="headerlink" title="R(查询)"></a><strong>R(查询)</strong></h3><p>git  status   :  查看工作目录中文件的状态(已跟踪(已提交 已暂存 已修改) 未跟踪)<br>git  diff     :  查看未暂存的修改<br>git  diff –cache : 查看未提交的暂存<br>git  log –oneline : 查看提交记录</p>
</li>
<li><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a><strong>分支</strong></h3><p>分支的本质其实就是一个提交对象!!!<br>HEAD: </p>
<pre><code>是一个指针 它默认指向master分支 切换分支时其实就是让HEAD指向不同的分支
每次有新的提交时 HEAD都会带着当前指向的分支 一起往前移动</code></pre>
<p>git  log –oneline –decorate –graph –all : 查看整个项目的分支图<br>git branch : 查看分支列表<br>git branch -v: 查看分支指向的最新的提交<br>git branch name : 在当前提交对象上创建新的分支<br>git branch name commithash: 在指定的提交对象上创建新的分支<br>git checkout name :     切换分支<br>git branch -d name : 删除空的分支 删除已经被合并的分支<br>git branch -D name : 强制删除分支</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据类型1</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/1.1.JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript 规定了 7 种语言类型，用于变量、函数参数、表达式、函数返回值等：</p>
<ol>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Symbol</li>
<li>Object</li>
</ol>
<p>其中，又分为<strong>基本数据类型</strong>和<strong>引用数据类型</strong>：</p>
<a id="more"></a>

<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>number、string、boolean、null、 undefined、symbol（ES6）</p>
<p>基本数据类型的变量是保存在栈内存中的，基本数据类型的值直接在栈内存中存储，值与值之间是独立存在的，修改一个变量不会影响其他的变量。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">10</span></span><br><span class="line"><span class="keyword">var</span> b = a</span><br><span class="line">b = <span class="number">20</span></span><br><span class="line"><span class="built_in">console</span>.log(a) <span class="comment">// 10</span></span><br><span class="line"><span class="built_in">console</span>.log(b) <span class="comment">// 20</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201006133331604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>Object（在 JS 中除了基本数据类型以外的都是对象，数据是对象，函数是对象，正则表达式是对象）</p>
<p>对象是保存在堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量在栈内存中保存的是一个指针（指向对象在堆内存中的引用地址，通过这个引用地址可以快速查找到保存在堆内存中的对象）。如果两个变量保存的是同一个对象引用，当修改其中一个变量修改属性时，另一个也会受到影响。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> obj1 = <span class="keyword">new</span> <span class="built_in">Object</span>()</span><br><span class="line"><span class="keyword">var</span> obj2 = obj1</span><br><span class="line">obj2.name = <span class="string">&#x27;我&#x27;</span></span><br><span class="line"><span class="built_in">console</span>.log(obj1.name) <span class="comment">// 我</span></span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201006133331700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="一、Undefined-Null"><a href="#一、Undefined-Null" class="headerlink" title="一、Undefined Null"></a>一、Undefined Null</h3><p>任何变量在赋值前都是 Undefined 类型，值为 undefined。</p>
<p>void 运算可以把任意一个表达式变成 undefined 值。</p>
<h4 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h4><p>对给定的表达式进行求值，然后返回 undefined</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;aaa&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">void</span> a())</span><br></pre></td></tr></table></figure>
<p>打印结果：aaa 和 undefined</p>
<h4 id="void-0-可以代替-undefined，好处"><a href="#void-0-可以代替-undefined，好处" class="headerlink" title="void 0 可以代替 undefined，好处"></a>void 0 可以代替 undefined，好处</h4><ol>
<li>void 0 比 undefined 省 3 个字节</li>
<li>避免 undefined 被重写(undefined 是一个变量，而并非是一个关键字，为避免无意中篡改)</li>
</ol>
<h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>null:定义了但是为空</p>
<p>编程中，我们一般不会把变量赋值为 undefined，为了保证所有值为 undefined 的变量都是从未赋值的自然状态。</p>
<p>Null 类型也只有一个值 null，与 undefined 不同，是 JavaScript 关键字。所以可以放心用 null 关键字来获取 null 值。</p>
<blockquote>
<p>undefined：定义了未赋值</p>
<p>null：定义了也赋值了，值为 null</p>
</blockquote>
<p><strong>什么时候给对象赋值为 null</strong></p>
<ol>
<li>初始赋值，表明变量将会被赋值为对象</li>
<li>结束前，切断变量与它此前引用的对象之间的联系，被垃圾回收器回收</li>
</ol>
<h3 id="二、Boolean"><a href="#二、Boolean" class="headerlink" title="二、Boolean"></a>二、Boolean</h3><p>Boolean 类型的两个值：true 和 false，表示逻辑意义上的真和假，同样都是关键字。</p>
<h3 id="三、String"><a href="#三、String" class="headerlink" title="三、String"></a>三、String</h3><p>字符串一旦构造出来，就永远无法变更。字符串的最大长度为 2^53-1(针对的是字符串的 UTF16 编码)</p>
<h3 id="四、Number"><a href="#四、Number" class="headerlink" title="四、Number"></a>四、Number</h3><p>基本符合双精度浮点数规则。Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。</p>
<ul>
<li>NaN，代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。</li>
<li>Infinity，无穷大</li>
<li>-Infinity，负无穷大</li>
</ul>
<p>根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="number">0.1</span> + <span class="number">0.2</span> == <span class="number">0.3</span>)</span><br></pre></td></tr></table></figure>
<p>输出结果为 false。</p>
<p>浮点运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。</p>
<p>正确的比较方法是使用 JavaScript 提供的最小精度值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Math</span>.abs(<span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span>) &lt;= <span class="built_in">Number</span>.EPSILON)</span><br></pre></td></tr></table></figure>
<p>检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果是 true。</p>
<h3 id="五、Symbol"><a href="#五、Symbol" class="headerlink" title="五、Symbol"></a>五、Symbol</h3><p>Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合。</p>
<p>创建 Symbol 的方式是使用全局的 Symbol 函数 :</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> mySymbol = <span class="built_in">Symbol</span>(<span class="string">&#x27;my symbol&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>Symbol.iterator(迭代器)可以自定义 for…of 在对象上的行为</p>
<h3 id="六、Object"><a href="#六、Object" class="headerlink" title="六、Object"></a>六、Object</h3><p>对象：属性的集合。属性分为数据属性和访问器属性，都是 key-value 结构。key 可以使字符串或者 Symbol 类型。</p>
<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>这几个<strong>基本类型</strong>都在<strong>对象类型</strong>中有相似的“亲戚”：</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Symbol</li>
</ul>
<p>所以，3 与 new Number(3) 是完全不同的值，前者是基本类型中的 Number 类型，后者是对象类型。</p>
<p>前三个的构造器是两用的，与 new 搭配时产生对象；直接调用时，表示强制类型转换。</p>
<p>而最后一个 Symbol 类型直接用 new 调用会抛出错误，但仍是 Symbol 对象的构造器。</p>
<p>JS 语言设计上试图模糊对象和基本类型之间的关系，日常代码可以把对象的方法在基本类型上使用，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="string">&#x27;abc&#x27;</span>.charAt(<span class="number">0</span>)) <span class="comment">//a</span></span><br></pre></td></tr></table></figure>
<p>甚至，我们在原型上添加的方法都可以应用于基本类型，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.prototype.hello = <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = <span class="built_in">Symbol</span>(<span class="string">&#x27;a&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// symbol，a 并非对象类型</span></span><br><span class="line">a.hello() <span class="comment">// hello, 添加的方法有效</span></span><br></pre></td></tr></table></figure>
<p>所以我们能在基础类型上调用对应对象的方法，是因为运算符提供了装箱操作，它会根据基础类型构造一个临时对象。</p>
<h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><p>把基本类型转化为对应的对象类型的操作。</p>
<h4 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h4><p>将对象类型转换为对应的基本类型的值的操作。</p>
<p>它是通过所有对象都继承的两个转换方法 valueOf() 或者 toString() 来实现的：</p>
<p>**toString()**：它的作用是返回一个这个对象的字符串</p>
<p>**valueOf()**：它的作用是返回对象类型相应的原始值</p>
<p><img src="https://img-blog.csdnimg.cn/20201027094348515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>调用顺序：</p>
<p>当遇到 <code>Number()、+、==、&lt;、&gt;</code> 等运算符时会先调用 valueOf()，没有返回基本类型再去调用 toString()；</p>
<p>当遇到 String()、alert() 等会先调用 toString()，没有返回基本类型再去调用 valueOf()；</p>
<p>如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p>
<h4 id="显性转换"><a href="#显性转换" class="headerlink" title="显性转换"></a>显性转换</h4><p>直接用 String()，Boolean()，Number() 来进行转换的</p>
<h4 id="隐性转换"><a href="#隐性转换" class="headerlink" title="隐性转换"></a>隐性转换</h4><p>在内部进行，甚至可能用到 String()，Boolean()，Number() 中的多个来进行转换：</p>
<p>1.当使用 <code>if，?:，&amp;&amp;，||</code> 等操作的时候进行 Boolean() 转换。</p>
<p>2.当使用 <code>+，-，*，/，==，&gt;，&lt;</code> 等操作符的时候进行 Number() 转换。</p>
<p>而 <code>+</code> 号比较特殊，因为它既可以作为字符串连接符号又可以作为数字的加号。因此就会有 1 + 1 结果为 2，而 1 + ‘1’ 结果为 ‘11’ 的情况，因为这个时候加号的作用不同。</p>
<p>各种类型在不同时候加号的不同含义：</p>
<p><img src="https://img-blog.csdnimg.cn/20201027094351583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>注意：</p>
<ol>
<li>Date 对象，本来 valueOf 返回的是时间戳，但是 + 1 的时候是先调用 toString 返回的字符串</li>
<li>自定义 Object，虽然 + ‘1’ 是属于字符串连接，但是先调用的是 valueOf() 返回的是 567</li>
<li>数组 [1,2,3] 遇到 + 1 的情况时，相当于 Number()，先调用 valueOf() 返回的是 [1,2,3] 不是基本类型，所以接着调用 toString() 返回 ‘1,2,3’</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>05_代码风格</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/05-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><h2 id="Eslint-js代码检查工具"><a href="#Eslint-js代码检查工具" class="headerlink" title="Eslint(js代码检查工具)"></a>Eslint(js代码检查工具)</h2><h3 id="仅使用eslint"><a href="#仅使用eslint" class="headerlink" title="仅使用eslint"></a>仅使用eslint</h3><p><strong>创建package.json文件(npm init -y)</strong></p>
<p><strong>首先本地安装eslint</strong></p>
<p><font color="cornflowerblue"><strong>npm i eslint –save-dev</strong></font></p>
<a id="more"></a>



<p><strong>设置package.json文件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint src&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lint:create&quot;</span>: <span class="string">&quot;eslint --init&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>在终端中输入npm run lint:create(等价于执行npm eslint –init)</strong></p>
<p>出现的问题:</p>
<p>1.你想要怎么使用eslint (只是检查语法，检查语法找到问题，检查语法找到问题并强制保存编码风格)    3</p>
<p>2.哪一种模块化方案你要去使用    3</p>
<p>3.哪一种框架    3</p>
<p>4.你用不用typescript    n</p>
<p>5.你的项目跑在那儿(浏览器，node)    1</p>
<p>6.你想要怎么去定义一个风格(使用流行的向导，回答问题去自定义，导入配置文件)    1</p>
<p>7.哪一个向导你想要使用(Airbnb，标准，谷歌)    2</p>
<p>8.哪种配置文件你想要(js，yaml，json)    1</p>
<p>9.你希望让npm帮你装依赖的包吗    y</p>
<p><strong>完成后会生成 .eslintrc.js 文件。提供编码规则</strong></p>
<p><strong>装完之后以后在该项目的终端中输入npm run lint命令就会去验证跟根目录下的src文件夹下的js代码</strong></p>
<p>此时存在的问题是你可以不去通过eslint的约束而直接提交到git上</p>
<h3 id="eslint配合husky-哈士奇-和Git使用"><a href="#eslint配合husky-哈士奇-和Git使用" class="headerlink" title="eslint配合husky(哈士奇)和Git使用"></a>eslint配合husky(哈士奇)和Git使用</h3><p><strong>在装husky之前一定要先创建Git仓库，因为他要像git中添加钩子</strong></p>
<p><strong>安装husky</strong></p>
<p><font color="blue">npm i husky –save-dev</font></p>
<p><strong>设置package.json文件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;pre-commit&quot;</span>: <span class="string">&quot;npm run lint&quot;</span></span><br><span class="line">      <span class="comment">//在git commit之前一定要通过npm run lint的检查</span></span><br><span class="line">      <span class="comment">// 只有npm run lint不报错时 commit才能真正的运行</span></span><br><span class="line">    &#125;</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置之后再向git提交就会自动调用eslint验证js代码</p>
<h2 id="Editor-Config"><a href="#Editor-Config" class="headerlink" title="Editor Config"></a>Editor Config</h2><p>​        EditorConfig 帮助开发人员定义和维护不同编辑器之间一致的编码风格。EditorConfig 项目由定义编码样式的文件格式和一组文本编辑器插件组成，这些插件使编辑器能够读取文件格式并坚持已定义的样式。编辑器配置文件易于阅读，并且可以很好地与版本控制系统一起工作</p>
<p>​        你只需配置一个 .editorconfig 文件，在其中设置好要遵守的代码规范，放在项目的根目录下，就能够在几乎所有的主流 IDE 和编辑器中复用了，可以将 .editorconfig 文件也提交到版本控制系统中，就不需要针对不同 IDE 和编辑器再单独进行设置了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据类型2</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/1.2.JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>因为 JS 是弱类型语言，所以类型转换发生非常频繁。</p>
<p>在 <code>JS</code> 中类型转换只有三种情况，分别是：</p>
<ul>
<li>转换为布尔值</li>
<li>转换为数字</li>
<li>转换为字符串</li>
</ul>
<a id="more"></a>

<p><img src="https://img-blog.csdnimg.cn/20201027094718348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="对象转原始类型"><a href="#对象转原始类型" class="headerlink" title="对象转原始类型"></a>对象转原始类型</h3><p>对象类型遇到原始类型时，就会多重隐性转换。（思路是：先将对象类型变成原始类型，再通过原始类型的转换来达到效果）</p>
<p>在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑一般来说如下：</p>
<ul>
<li>如果已经是用原始类型的构造函数 new 出来的，那就不需要转换了</li>
<li>先调用 <code>x.valueOf()</code> 转换为基本类型，就返回转换的值</li>
<li>然后调用 <code>x.toString()</code> 转换为基本类型，就返回转换的值</li>
<li>如果都没有返回原始类型，就报错</li>
</ul>
<p>也可以重写 <code>Symbol.toPrimitive</code>，该方法在转原始类型时调用优先级最高。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span> + a) <span class="comment">// 3</span></span><br><span class="line"><span class="comment">// 先重写,再valueOf,再toString</span></span><br></pre></td></tr></table></figure>
<h3 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h3><p>运算时进行隐式转换。它有以下几个特点：</p>
<ul>
<li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li>
<li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">1</span> + <span class="string">&#x27;1&#x27;</span> <span class="comment">// &#x27;11&#x27; 触发特点一，将数字 1 转换为字符串</span></span><br><span class="line"><span class="literal">true</span> + <span class="literal">true</span> <span class="comment">// 2 触发特点二，将 true 转为数字 1</span></span><br><span class="line"><span class="number">4</span> + [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>] <span class="comment">// &quot;41,2,3&quot; 触发特点二，将数组通过 toString 转为字符串 1,2,3</span></span><br></pre></td></tr></table></figure>
<ul>
<li>在加法中：<code>+ &#39;b&#39;</code> 等于 <code>NaN</code>， <code>+ &#39;1&#39;</code> 等于 1，可以用来快速获取 <code>number</code> 类型。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">&#x27;a&#x27;</span> +</span><br><span class="line">  +<span class="string">&#x27;b&#x27;</span> + <span class="comment">// -&gt; &#x27;aNaN&#x27;</span></span><br><span class="line">  <span class="string">&#x27;1&#x27;</span> ===</span><br><span class="line">  <span class="number">1</span> <span class="comment">// -&gt; true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">4</span> * <span class="string">&#x27;3&#x27;</span> <span class="comment">// 12</span></span><br><span class="line"><span class="number">4</span> * [] <span class="comment">// 0</span></span><br><span class="line"><span class="number">4</span> * [<span class="number">1</span>, <span class="number">2</span>] <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li>
<li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  <span class="function"><span class="title">valueOf</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">toString</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;2&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a &gt; <span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="comment">// 因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。</span></span><br><span class="line"><span class="comment">// 先</span></span><br></pre></td></tr></table></figure>
<h2 id="三种判断值数据类型的方法"><a href="#三种判断值数据类型的方法" class="headerlink" title="三种判断值数据类型的方法"></a>三种判断值数据类型的方法</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>只能判断为 number、string、boolean、symbol、undefined、function 这几种类型，</p>
<p>而遇到 <code>null</code>、<code>array</code>、<code>object</code> 以及函数实例 <code>new + 函数</code> 时，得到的都是 <code>object</code> ，</p>
<p>对于 null -&gt; “object” 的问题，仅仅 typeof 无解，记住有这么个坑即可。</p>
<p>而关于 array -&gt; “object” 的问题，可以使用 <code>Array.isArray([]) // true</code> 来判断。</p>
<p>由此引出 instanceof。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>typeof</code> 对于基本类型，除了 <code>null</code> 都可以显示正确的类型</p>
<p>typeof 对于对象，除了函数都会显示 object</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>意为实例，这个运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，返回值为 true 或 false</p>
<p>涉及的构造函数有这些基础类型：String、Number、Boolean、Undefined、Null、Symbol；</p>
<p>复杂类型：Array，Object；</p>
<p>其他类型：Function、RegExp、Date。</p>
<p>语法：[对象] instanceof [构造函数]，<strong>注意左侧必须是对象（object），如果不是，直接返回 false。</strong></p>
<blockquote>
<p>所以，instanceof 不能用来判断基本类型，但可以判断对象类型中用基本类型的构造函数 new 出来的</p>
</blockquote>
<h4 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h4><p>Number、String、Boolean、Symbol、Undefined、Null</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> num = <span class="number">1</span></span><br><span class="line">num <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">num = <span class="keyword">new</span> <span class="built_in">Number</span>(<span class="number">1</span>)</span><br><span class="line">num <span class="keyword">instanceof</span> <span class="built_in">Number</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>明明都是 num，而且都是 1，只是因为第一个不是对象，是基本类型，所以直接返回 false，而第二个是封装成对象，所以 true。string、boolean，也是一样的。</p>
<blockquote>
<p>new String(1 )与 String(1) 是不同的，new 是封装成对象，而没有 new 的只是基础类型转换，还是基础类型</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="number">1</span>) <span class="comment">// String &#123;&quot;1&quot;&#125;</span></span><br><span class="line"><span class="keyword">let</span> w = <span class="built_in">String</span>(<span class="number">1</span>) <span class="comment">// &quot;1&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> s) <span class="comment">//object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> w) <span class="comment">//string</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(s <span class="keyword">instanceof</span> <span class="built_in">String</span>) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(w <span class="keyword">instanceof</span> <span class="built_in">String</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h4 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a><strong>复杂类型</strong></h4><p>Array、Object</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = []</span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br><span class="line">arr <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(arr) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因为字面量是直接生成构造函数的，所以不会像基本类型一样有两种情况，可以放心使用。</p>
<p>但是与 Object 对比时，由于 Object 在原型链的上层，所以都会返回 true</p>
<h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><p>或者是 RegExp、Date、HTMLDivElement</p>
<p>与上面的类型一样</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>()</span><br><span class="line">reg <span class="keyword">instanceof</span> <span class="built_in">RegExp</span> <span class="comment">// true</span></span><br><span class="line">reg <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">date <span class="keyword">instanceof</span> <span class="built_in">Date</span> <span class="comment">// true</span></span><br><span class="line">date <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s = <span class="built_in">document</span>.getElementById(<span class="string">&#x27;123&#x27;</span>)</span><br><span class="line">s <span class="keyword">instanceof</span> HTMLDivElement <span class="comment">// true</span></span><br><span class="line">s <span class="keyword">instanceof</span> <span class="built_in">Object</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>除了 Function，自定义的构造函数/类：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> a = <span class="keyword">new</span> A()</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> a) <span class="comment">// object</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> A) <span class="comment">// function</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Function</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> <span class="built_in">Object</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(a <span class="keyword">instanceof</span> A) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(A <span class="keyword">instanceof</span> <span class="built_in">Function</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这里要注意，<code>function A() &#123;&#125;</code> 相当于 <code>let A; A = function() &#123;&#125;</code>：</p>
<ol>
<li>a 是 new 出来，所以是经过构造，因此已经是对象，不再是函数</li>
<li>A 是个函数，因此没什么概念上的问题。但是要知道 <code>A.__proto__</code> 即 <code>Function.prototype</code> 是 <code>ƒ () &#123; [native code] &#125;</code>，这是与 object 一样处于原型链上层的存在，而且与 object 平级</li>
</ol>
<h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><p>可以判断 [object Number]、[object String]、[object Boolean]、[object Symbol]、[object Null]、[object Undefined]、[object RegExp]、[object Date]、[object Array]、[object HTMLDivElement]这几种类型，其他都是[object Object]</p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>06_远程仓库</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/06-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h3 id="三个必须懂的概念"><a href="#三个必须懂的概念" class="headerlink" title="三个必须懂的概念"></a>三个必须懂的概念</h3><p>本地分支<br>远程跟踪分支(remote/分支名)<br>远程分支</p>
<h3 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h3><p>创建一个 <strong>.gitignore</strong> 文件</p>
<a id="more"></a>

<p>所有空行或者以注释符号＃ 开头的行都会被 Git 忽略。</p>
<p>可以使用标准的 glob 模式匹配。</p>
<p>​    *代表匹配任意个字符</p>
<p>​    ？代表匹配任意一个字符</p>
<p>​    ** 代表匹配多级目录</p>
<p>匹配模式前跟反斜杠（/） 这个斜杠代表项目根目录</p>
<p>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</p>
<p>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</p>
<p><strong>GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 找到它!!!</strong></p>
<h3 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h3><ol>
<li><p><strong>项目经理初始化远程仓库</strong><br>一定要初始化一个空的仓库; 在github上操作</p>
</li>
<li><p><strong>项目经理创建本地仓库（项目经理为远程仓库配置别名&amp;用户信息）</strong><br><font color="blue">git remote 别名 仓库地址(https)</font><strong>添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写</strong></p>
<p>git init ; 将源码复制进来</p>
<p>git add</p>
<p>git commit </p>
<p><font color="blue"><strong>git remote -v</strong></font>查看远程仓库使用的 Git别名和与其对应的URL</p>
<p><strong>git remote rename pb paul</strong>重命名</p>
<p>**git remote rm [remote-name]**如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了</p>
</li>
<li><p>项目经理推送本地仓库到远程仓库<br><font color="blue"><strong>git push  别名 分支名</strong></font>  (输入用户名 密码;推完之后会附带生成远程跟踪分支)</p>
</li>
<li><p>项目邀请成员 &amp; 成员接受邀请<br>在github上操作  </p>
</li>
<li><p>成员克隆远程仓库<br>git clone  仓库地址 (在本地生成.git文件 默认为远程仓库配了别名 orgin)</p>
<pre><code>        只有在克隆的时候 本地分支master 和 远程跟踪分支别名/master 是有同步关系的</code></pre>
</li>
<li><p>成员做出贡献<br>修改源码文件<br>git add<br>git commit<br>git push  别名 分支 (输入用户名 密码;推完之后会附带生成远程跟踪分支) </p>
</li>
<li><p>项目经理更新修改<br><strong>git fetch</strong> 别名 (将修改同步到远程跟踪分支上)<br>git merge 远程跟踪分支</p>
</li>
</ol>
<h3 id="本地分支"><a href="#本地分支" class="headerlink" title="本地分支"></a>本地分支</h3><p>正常的数据推送 和 拉取步骤<br>    1. 确保本地分支已经跟踪了远程跟踪分支<br>        2. 拉取数据 : git pull<br>        3. 上传数据: git push</p>
<p><font color="deeppink"><strong>一个本地分支怎么去跟踪一个远程跟踪分支</strong></font></p>
<ol>
<li><p>当克隆的时候 会自动生成一个master本地分支(已经跟踪了对应的远程跟踪分支)</p>
</li>
<li><p>在新建其他分支时 可以指定想要跟踪的远程跟踪分支<br> <font color="blue"><strong>git checkout -b 本地分支名 远程跟踪分支名</strong></font><br>  <font color="blue"><strong>git checkout –track  远程跟踪分支名</strong> </font></p>
</li>
<li><p>将一个已经存在的本地分支 改成 一个跟踪分支<br> <font color="blue"><strong>git branch -u 远程跟踪分支名</strong> </font></p>
</li>
<li><p><font color="cornflowerblue"><strong>git branch -vv</strong></font></p>
<p>查看设置的所有跟踪分支</p>
</li>
</ol>
<p>git remote remove origin 取消连接</p>
<p>git remote add origin https://… 连接本地仓库和远程仓库</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p><strong>git push origin –delete serverfix</strong>删除远程分支</p>
<p><strong>git remote prune origin –dry-run</strong>列出仍在远程跟踪但是远程已被删除的无用分支</p>
<p><strong>git remote prune origin</strong>清除上面命令列出来的远程跟踪</p>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>git本地操作会不会有冲突?<br>    典型合并的时候<br>git远程协作的时候 会不会有冲突?<br>    push<br>    pull</p>
<h3 id="pull-request"><a href="#pull-request" class="headerlink" title="pull request"></a>pull request</h3><p>让第三方人员参与到项目中 fork</p>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>​    ssh-keygen –t rsa –C  你的邮箱：生成公私钥</p>
<p>​    .ssh 文件位置：C:\Users\Administrator.ssh</p>
<p>​    ssh -T <a href="mailto:git@github.com">git@github.com</a> ：测试公私钥是否已经配对</p>
<h3 id="使用频率最高的五个命令"><a href="#使用频率最高的五个命令" class="headerlink" title="使用频率最高的五个命令"></a>使用频率最高的五个命令</h3><p>git status<br>git add<br>git commit<br>git push<br>git pull</p>
<p>经常用到的：<br>git pull origin 远程分支名:master 更新自己的代码到最新版<br>遇到冲突时：<br>git pull –rebase 拉下来master的代码 解决冲突后再<br>git rebase –continue</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>执行语句</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/11.%E6%89%A7%E8%A1%8C%E8%AF%AD%E5%8F%A5/</url>
    <content><![CDATA[<h2 id="Completion-类型"><a href="#Completion-类型" class="headerlink" title="Completion 类型"></a>Completion 类型</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125; catch(err) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    console.log(&quot;a&quot;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo());</span><br><span class="line">&#x2F;&#x2F; a</span><br><span class="line">&#x2F;&#x2F; 0</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>虽然 return 执行了，但是函数并没有立即返回，又执行了 finally 里面的内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo()&#123;</span><br><span class="line">  try&#123;</span><br><span class="line">    return 0;</span><br><span class="line">  &#125; catch(err) &#123;</span><br><span class="line"></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    return 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(foo()); &#x2F;&#x2F; 1</span><br></pre></td></tr></table></figure>
<p>finally中的return“<strong>覆盖</strong>”了try中的return。（后文有解释原因）</p>
<p>JS 使用 Completion Record 类型，控制语句执行的过程。Completion Record 表示一个语句执行完之后的结果，它有三个字段：</p>
<ul>
<li>[[type]] 表示完成的类型，有 break continue return throw 和 normal 几种类型；</li>
<li>[[value]] 表示语句的返回值，如果语句没有，则是 empty；</li>
<li>[[target]] 表示语句的目标，通常是一个 JavaScript 标签。</li>
</ul>
<p><strong>语句的分类：</strong></p>
<p><img src="https://static001.geekbang.org/resource/image/98/d5/98ce53be306344c018cddd6c083392d5.jpg" alt="img"></p>
<h2 id="普通的语句"><a href="#普通的语句" class="headerlink" title="普通的语句"></a>普通的语句</h2><p>不带控制能力的语句称为普通语句。</p>
<ul>
<li>声明类语句<ul>
<li>var 声明</li>
<li>const 声明</li>
<li>let 声明</li>
<li>函数声明</li>
<li>类声明</li>
</ul>
</li>
<li>表达式语句</li>
<li>空语句</li>
<li>debugger 语句</li>
</ul>
<p>这些普通语句在执行时，从前到后顺次执行（忽略 var 和函数声明的预处理机制），没有任何分支或者重复执行逻辑。</p>
<p>普通语句执行后，会得到 [[type]] 为 normal 的 Completion Record。JS 引擎遇到这样的 Completion Record，会继续执行下一条语句。这些语句中，只有表达式语句会产生 [[value]]。</p>
<h2 id="语句块"><a href="#语句块" class="headerlink" title="语句块"></a>语句块</h2><p>语句块就是拿大括号括起来的一组语句，它是一种语句的复合结构，可以嵌套。</p>
<p>注意的是语句块内部的语句的 Completion Record 的<code>[[type]]</code>如果不为 <strong>normal</strong>，会<strong>打断</strong>语句块后续的语句执行。</p>
<p>比如，一个[[type]]为 return 的语句，出现在一个语句块中的情况。return 语句可能产生 return 或者 throw 类型的 Completion Record。</p>
<p>先给出一个内部为普通语句的语句块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  var i &#x3D; 1; &#x2F;&#x2F; normal, empty, empty</span><br><span class="line">  i ++; &#x2F;&#x2F; normal, 1, empty</span><br><span class="line">  console.log(i) &#x2F;&#x2F;normal, undefined, empty</span><br><span class="line">&#125; &#x2F;&#x2F; normal, undefined, empty</span><br></pre></td></tr></table></figure>
<p>在每一行的注释中，给出了语句的 Completion Record。在一个 block 中，如果每一个语句都是 normal 类型，那么它会顺次执行。</p>
<p>接下来加入 return :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  var i &#x3D; 1; &#x2F;&#x2F; normal, empty, empty</span><br><span class="line">  return i; &#x2F;&#x2F; return, 1, empty</span><br><span class="line">  i ++; </span><br><span class="line">  console.log(i)</span><br><span class="line">&#125; &#x2F;&#x2F; return, 1, empty</span><br></pre></td></tr></table></figure>
<p>假如我们在 block 中插入了一条 return 语句，产生了一个非 normal 记录，那么整个 block 会成为非 normal。</p>
<p>这个结构就保证了非 normal 的完成类型可以穿透复杂的语句嵌套结构，产生控制效果。</p>
<h2 id="控制型语句"><a href="#控制型语句" class="headerlink" title="控制型语句"></a>控制型语句</h2><p>控制型语句带有 if、switch 关键字，它们会对不同类型的 Completion Record 产生反应。</p>
<p>控制类语句分成两部分：</p>
<ul>
<li>一类 对其<strong>内部</strong>造成影响，如 if、switch、while/for、try。</li>
<li>另一类 对<strong>外部</strong>造成影响如 break、continue、return、throw。</li>
</ul>
<p>这两类语句的配合，会产生控制代码<strong>执行顺序</strong>和<strong>执行逻辑</strong>的效果，这也是我们编程的主要工作。</p>
<p>一般来说， for/while - break/continue 和 try - throw 这样比较符合逻辑的组合。但是，实际上，我们需要控制语句跟 break 、continue 、return 、throw 四种类型与控制语句两两组合产生的效果。</p>
<p><img src="https://static001.geekbang.org/resource/image/77/d3/7760027d7ee09bdc8ec140efa9caf1d3.png" alt="img"></p>
<p>通过这个表，发现最初的 case 中的 try 和 return 的组合。</p>
<blockquote>
<p>穿透”就是指不在当前这一层处理，向外逐层寻找可以“消费”的那一层，直到最后都没找到就报错。</p>
<p>比如：function里面有while, while里面有switch, switch里面又有continue，按图表来看，switch-continue应该是穿透，向上层寻找消费，碰到while-contine,那就是消费，再如switch里面是return, switch-return穿透，向上层whlie-return穿透，最后function-return是消费。</p>
</blockquote>
<p><strong>原因：</strong></p>
<p>因为 finally 中的内容必须保证执行，所以 try/catch 执行完毕，即使得到的结果是非 normal 型的完成记录，也必须要执行 finally。而当 finally 执行也得到了非 normal 记录，则会使 finally 中的记录作为整个 try 结构的结果。</p>
<h2 id="带标签的语句"><a href="#带标签的语句" class="headerlink" title="带标签的语句"></a>带标签的语句</h2><p>Completion Record 最后一个字段：target，涉及了 JS 中的一个语法，带标签的语句。</p>
<p>实际上，任何 JS 语句都是可以加标签的，在语句前加冒号即可。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">firstStatement: var i &#x3D; 1;</span><br></pre></td></tr></table></figure>
<p>大部分时候，这个东西类似于注释，没有任何用处。唯一有作用的时候是：与完成记录类型中的 target 相配合，用于跳出多层循环。</p>
<p>如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">outer: while(true) &#123;</span><br><span class="line">  inner: while(true) &#123;</span><br><span class="line">    break outer;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(&quot;finished&quot;) &#x2F;&#x2F; finished</span><br></pre></td></tr></table></figure>
<p>break/continue 语句如果后跟了关键字，会产生带 target 的完成记录。一旦完成记录带了 target，那么只有拥有对应 label(标签) 的循环语句会消费它。</p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据类型3</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/1.3.JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="相等比较"><a href="#相等比较" class="headerlink" title="相等比较"></a>相等比较</h2><h3 id><a href="#" class="headerlink" title="=="></a>==</h3><p>在比较的时候会强制转换左右两边的数据类型</p>
<ul>
<li>对象 == 对象：比较地址</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> b = &#123;&#125;</span><br><span class="line">a == b <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<ul>
<li>对象 == 字符串：对象转换为字符串</li>
</ul>
<a id="more"></a>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> a = &#123;&#125;</span><br><span class="line">a == <span class="string">&#x27;[object Object]&#x27;</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<ul>
<li><p>NaN == NaN：NaN 和自己以及其他值比较都不相等</p>
</li>
<li><p>null == undefined：在两个等于号下相等，三个等于号下不相等，并且和自己比较相等，和其他值比较都不相等</p>
</li>
<li><p>剩下的情况，只要两边类型不同，都转换为数字（遇到 <code>!</code> 会先转换为 boolean 再转换为数字）</p>
<ul>
<li>只有这 5 个可以转换为 boolean 的 false：<code>null</code>、<code>undefined</code>、<code>NaN</code>、<code>&#39;&#39;</code>（空字符串）、<code>0</code></li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">!<span class="literal">null</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">undefined</span> <span class="comment">// true</span></span><br><span class="line">!<span class="literal">NaN</span> <span class="comment">// true</span></span><br><span class="line">!<span class="string">&#x27;&#x27;</span> <span class="comment">// true</span></span><br><span class="line">!<span class="number">0</span> <span class="comment">// true</span></span><br><span class="line">![] <span class="comment">// false 引用类型转boolean都为true</span></span><br><span class="line">!<span class="string">&#x27; &#x27;</span> <span class="comment">// false //字符串转boolean，除了空串都为true</span></span><br></pre></td></tr></table></figure>
<ul>
<li>遇到 [] 时，先 .toString() 转为字符串，字符串再变成数字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[] &#x3D;&#x3D; false &#x2F;&#x2F; true，都转为数字再进行比较：先把[].toString()转为字符串，空字符串再变成数字0（Number(&#39;&#39;) &#x3D;&#x3D;&gt; 0），false转换为数字是0</span><br><span class="line">[0] &#x3D;&#x3D; false &#x2F;&#x2F; true，Number([0].toString()) --&gt; 0</span><br><span class="line">[1] &#x3D;&#x3D; true &#x2F;&#x2F; true，Number([1].toString()) --&gt; 1</span><br><span class="line">[2] &#x3D;&#x3D; true &#x2F;&#x2F; false，Number([2].toString()) --&gt; 2</span><br><span class="line">[] &#x3D;&#x3D; ![] &#x2F;&#x2F; true</span><br><span class="line">&#39; &#39; &#x3D;&#x3D; !&#39; &#39; &#x2F;&#x2F; true，Number(&#39; &#39;) &#x3D;&#x3D;&gt; 0</span><br><span class="line">+0 &#x3D;&#x3D; -0 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>  数组的 toString 转化为字符串，而对象的 toString 相当于 <code>Object.prototype.toString.call()</code> 结果是 <code>&quot;[object Object]&quot;</code></p>
<p><img src="https://img-blog.csdnimg.cn/20201027111751868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="-1"><a href="#-1" class="headerlink" title="==="></a>===</h3><p>三等运算符更加严格并且不会将操作数进行强制类型转换。然而三等运算符也不是最好的解决方案，也存在问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F; false</span><br><span class="line">+0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>在 ES6 中有一个新的 <code>Object.is()</code>，它更精确，它具有与 <code>===</code> 相同的功能，而且在某些特殊情况下，其表现还不错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.is(+0, -0) &#x2F;&#x2F; false</span><br><span class="line">Object.is(NaN, NaN) &#x2F;&#x2F; true</span><br><span class="line">Object.is(null, undefined) &#x2F;&#x2F; false</span><br><span class="line">Object.is([1], true) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://img-blog.csdnimg.cn/20201006133331649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://qiutianaimeili.com/html/page/2017/08/ap8d1w6oml.html">js 的隐性类型转换与 valueOf 和 toString</a></p>
<p><a href="http://poetries1.gitee.io/fe-interview/docs/excellent.html#_2-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">FE-Inte-类型转换</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS中的对象函数类实例方法究竟是什么</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/12.JS%E4%B8%AD%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%87%BD%E6%95%B0%E7%B1%BB%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95%E7%A9%B6%E7%AB%9F%E6%98%AF%E4%BB%80%E4%B9%88/</url>
    <content><![CDATA[<h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>在JS中一切皆为对象，它是一种无序数据的集合，由若干个“键值对”（key-value）构成。对象就好比是一个容器，它里面包含了属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;实例创建方式：</span><br><span class="line">var person &#x3D; new Object();</span><br><span class="line">person.name&#x3D;&quot;l&quot;;</span><br><span class="line">person.age&#x3D;24;</span><br><span class="line">&#x2F;&#x2F;字面量式：</span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line">  name&#x3D;&quot;李&quot;,</span><br><span class="line">  age&#x3D;24</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>JS 是基于原型的面向对象语言, 所有数据都可以当作对象处理。</p>
<p>第一个 person 是对象, 可以把它当作是 Object 的实例。</p>
<p>第二个采用对象字面量的方式生成的person也是如此。它内部没有调用 new Object()，而是采用 JSON 的初始化方式：将现有的引用指向person。</p>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><p><strong>“类”是对象的模板，对象就是“类”的实例。</strong>类实例化的结果是对象，而对象的抽象就是类。类描述了一组有相同特性（属性）和相同行为的对象。</p>
<blockquote>
<p>比如：人是类，具体的人就是对象，小明、小红都是对象。动物是类，具体的小猫、小狗都是对象。</p>
</blockquote>
<p>“对象”是单个实物的抽象。所以，通常需要一个模板，表示某一类实物的共同特征，然后“对象”根据这个模板生成。</p>
<p>JS在ES6之前没有“类”的语法，而改用构造函数（constructor）作为对象的模板。“构造函数”，就是专门用来生成“对象”的函数。它提供模板，作为对象的基本结构。一个构造函数，可以生成多个对象，这些对象都有相同的结构。</p>
<h3 id="几种创建类的写法"><a href="#几种创建类的写法" class="headerlink" title="几种创建类的写法"></a>几种创建类的写法</h3><p>（此部分内容与【JavaScript】对象分类(四)中的补充内容相似）</p>
<h4 id="构造函数法"><a href="#构造函数法" class="headerlink" title="构造函数法"></a>构造函数法</h4><p>构造函数的优点是：我们可以根据参数来构造不同的对象实例 ，缺点是每次构造实例对象时都会生成getName、setName方法，造成了内存的浪费。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function information() &#123;</span><br><span class="line">  this.name &#x3D; &#39;&#39;;</span><br><span class="line">  this.setName &#x3D; (name) &#x3D;&gt; &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line">  this.getName &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var myName &#x3D; new information;&#x2F;&#x2F;没有参数可以省略小括号</span><br><span class="line">myName.setName(&#39;wy&#39;);&#x2F;&#x2F;调用实例的setName方法</span><br><span class="line">myName.getName();&#x2F;&#x2F;调用实例的getName方法</span><br></pre></td></tr></table></figure>
<p>还可以用一个外部函数代替类的方法，达到每个对象共享一个方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getColor() &#123; &#x2F;&#x2F;外部函数</span><br><span class="line">  return this.color;</span><br><span class="line">&#125;</span><br><span class="line">function Cloth(color) &#123;</span><br><span class="line">  this.color &#x3D; color;</span><br><span class="line">  this.getColor &#x3D; getColor;</span><br><span class="line">&#125;</span><br><span class="line">var c1 &#x3D; new Cloth(&#39;red&#39;);</span><br><span class="line">console.log(c1.getColor()); &#x2F;&#x2F; red</span><br></pre></td></tr></table></figure>
<h4 id="原型方式"><a href="#原型方式" class="headerlink" title="原型方式"></a>原型方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Pen() &#123;</span><br><span class="line">  Pen.prototype.name &#x3D; &#39;pencil&#39;;</span><br><span class="line">  Pen.prototype.getPenName &#x3D; function() &#123;</span><br><span class="line">    console.log(&quot;It is &quot; + this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var pen1 &#x3D; new Pen();</span><br><span class="line">console.log(pen1.name); &#x2F;&#x2F;pencil</span><br><span class="line">console.log(pen1.prototype.name); &#x2F;&#x2F;报错</span><br><span class="line">console.log(pen1.__proto__.name);&#x2F;&#x2F;pencil</span><br><span class="line">pen1.getPenName(); &#x2F;&#x2F;It is pencil</span><br></pre></td></tr></table></figure>
<p>当我们创建一个函数在浏览器中被解析时，解析器会向函数中添加一个属性prototype，也就是原型对象，包含了构造器。如果函数作为普通函数调用，prototype没有任何作用；当函数以构造函数形式调用时，它所创建的对象都会有一个隐含属性指向该构造函数的原型对象，就是<strong>隐含属性<code>__proto__</code>，指向原型对象</strong>，我们可以通过它访问原型对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.dir(Pen); &#x2F;&#x2F; 输出Pen</span><br><span class="line">console.dir(Pen.prototype &#x3D;&#x3D; pen1.__proto__); &#x2F;&#x2F;Person.prototype 与 pen1.__proto__ 指向同一个对象</span><br></pre></td></tr></table></figure>
<p>原型方式的缺点就是<strong>不能通过参数来构造对象实例</strong>（一般每个对象的属性是不相同的），优点是所有对象实例都共享getName()方法（相对于构造函数方式）没有造成内存浪费。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var pen1 &#x3D; new Pen(&#39;wy&#39;);</span><br><span class="line">var pen2 &#x3D; new Pen(&#39;woc&#39;);</span><br><span class="line"></span><br><span class="line">console.log(pen1.name); &#x2F;&#x2F;woc</span><br><span class="line">console.log(pen2.name); &#x2F;&#x2F;woc</span><br></pre></td></tr></table></figure>
<p>像上面那样，设置实例自己的属性（方法）（即所谓的私有属性）后将<strong>覆盖原型对象上的同名属性（方法）</strong>。</p>
<h4 id="构造函数-原型方式"><a href="#构造函数-原型方式" class="headerlink" title="构造函数+原型方式"></a>构造函数+原型方式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Pen(name) &#123;</span><br><span class="line">  this.name &#x3D; name; &#x2F;&#x2F;构造函数方式</span><br><span class="line">  Pen.prototype.getPenName &#x3D; function() &#123; &#x2F;&#x2F;&#x2F;&#x2F;原型方式</span><br><span class="line">    return &quot;It is &quot; + this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var pen1 &#x3D; new Pen(&#39;wy&#39;);</span><br><span class="line">var pen2 &#x3D; new Pen(&#39;woc&#39;);</span><br><span class="line"></span><br><span class="line">console.log(pen1.name); &#x2F;&#x2F;wy</span><br><span class="line">console.log(pen2.name);&#x2F;&#x2F;woc</span><br><span class="line">console.log(pen1.getPenName());&#x2F;&#x2F;It is wy</span><br><span class="line">console.log(pen2.getPenName());&#x2F;&#x2F;It is woc</span><br></pre></td></tr></table></figure>
<p>或者还可以写成这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Pen(name)&#123;</span><br><span class="line">    this.name &#x3D;name;</span><br><span class="line">&#125;</span><br><span class="line">Pen.prototype &#x3D; &#123;</span><br><span class="line">    constructor:Pen, &#x2F;&#x2F;指定构造器为Pen</span><br><span class="line">    getPenName: function()&#123;</span><br><span class="line">        console.log(this.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var pen1 &#x3D; new Pen(&#39;wy&#39;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是，上面这种写法中Person.prototype的constructor必须指定为Pen，否则实例对象的构造器<code>pen1.__proto__.constructor</code>为<em>ƒ</em> <em>Object()\</em>而不是*f* *Pen(name)*。</p>
</blockquote>
<p>这种方式只是将函数中的属性用<code>构造函数</code>中的<code>this</code>，方法用<code>原型方式</code>中的<code>prototype</code>。这样即避免了内存浪费，又不会造成参数的覆盖。</p>
<h4 id="Object-create-方法"><a href="#Object-create-方法" class="headerlink" title="Object.create()方法"></a>Object.create()方法</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var Pen &#x3D; &#123;</span><br><span class="line">  name: &#39;wy&#39;,</span><br><span class="line">  getPenName: function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var pen1 &#x3D; Object.create(Pen);</span><br><span class="line">pen1.getPenName(); &#x2F;&#x2F;wy</span><br></pre></td></tr></table></figure>
<p>用这个方法，”类”<strong>就是一个对象，而不是函数</strong>。然后，直接用Object.create()生成实例，不需要用到new。这种方法比”构造函数法”简单，但是<strong>不能实现私有属性和私有方法</strong>，实例对象之间也不能共享数据，对”类”的模拟不够全面。</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function createPen(name) &#123;</span><br><span class="line">  var obj &#x3D; new Object();</span><br><span class="line">  obj.name &#x3D; name;</span><br><span class="line">  obj.getPenName &#x3D; function() &#123;</span><br><span class="line">    console.log(this.name);</span><br><span class="line">  &#125;</span><br><span class="line">  return obj;</span><br><span class="line">&#125;</span><br><span class="line">var pen1 &#x3D; createPen(&#39;wy&#39;);</span><br><span class="line">pen1.getPenName(); &#x2F;&#x2F;wy</span><br></pre></td></tr></table></figure>
<p>这种方式主要是通过在函数内部创建一个对象，为其添加属性和方法，并将对象返回，从而实现创建多个对象的目的。缺点是构造器为Object，没有解决对象识别的问题，不能知道一个对象的类型。</p>
<h4 id="ES6中的类"><a href="#ES6中的类" class="headerlink" title="ES6中的类"></a>ES6中的类</h4><p>ES6中加入的新特性（【JavaScript】类(三)中有相似内容）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Pen &#123;</span><br><span class="line">  constructor(first) &#123;</span><br><span class="line">    this.first &#x3D; first;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;getter</span><br><span class="line">  get firstName() &#123;</span><br><span class="line">    return this.first;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;method</span><br><span class="line">  name(last) &#123;</span><br><span class="line">    return this.first + last;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let n &#x3D; new Pen(&#39;w&#39;);</span><br><span class="line">console.log(n.first); &#x2F;&#x2F;w</span><br><span class="line">console.log(n.firstName); &#x2F;&#x2F;w</span><br><span class="line">console.log(n.name(&#39;y&#39;)); &#x2F;&#x2F;wy</span><br></pre></td></tr></table></figure>
<p><code>n.__proto__.constructor</code>为<em>class</em> <em>Pen</em>。</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>实例是类的具象化产品，<strong>就是通过new关键字调用的对象</strong>。</p>
<p><strong>实例都是对象，而对象不全是实例。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; new Object;&#x2F;&#x2F;对象实例</span><br><span class="line">var arr &#x3D; new Array;&#x2F;&#x2F;数组实例</span><br></pre></td></tr></table></figure>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>就是使用function关键字定义(或声明)的表达式语句。</p>
<p>两种写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;函数定义表达式：</span><br><span class="line">var aa &#x3D; function() &#123;...&#125;;</span><br><span class="line">&#x2F;&#x2F;函数声明语句：（会被提升到所在作用域的最顶端）</span><br><span class="line">function aa() &#123;...&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>当对象的属性是一个函数时，这个函数就是该对象的方法。简而言之，方法就是作为对象属性的函数！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var bb &#x3D; &#123;</span><br><span class="line">  cc: function() &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数cc在这里就是对象bb的方法。一般叫做bb的cc方法。</p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>执行函数和this</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/10.%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E5%92%8Cthis/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>第一种，普通函数：用 function 关键字定义的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二种，箭头函数：用 =&gt; 运算符定义的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p><strong>第三种，在 class 中定义的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第四种，生成器函数：用 function * 定义的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第五种，类：用 class 定义的类，实际上也是函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第六种，异步函数：普通函数、箭头函数和生成器函数加上 async 关键字</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对普通变量而言，这些函数并没有本质区别，都是遵循了“继承定义时环境”的规则，它们的一个行为差异在于 this 关键字。</p>
<h3 id="this-关键字的行为"><a href="#this-关键字的行为" class="headerlink" title="this 关键字的行为"></a>this 关键字的行为</h3><p>this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showThis</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    showThis: showThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// global</span></span><br><span class="line">o.showThis(); <span class="comment">// o</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，定义了函数 showThis，并把它赋值给一个对象 o 的属性，然后尝试分别使用两个引用来调用同一个函数，结果得到了不同的 this 值。</p>
<p><strong>调用函数时使用的引用，决定了函数执行时刻的 this 值。</strong></p>
<p>换成箭头函数，结果就不一样了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> showThis = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    showThis: showThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// global</span></span><br><span class="line">o.showThis(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<p><strong>改为箭头函数后，不论用什么引用来调用它，都不影响它的 this 值。</strong></p>
<p>换成”方法”：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">showThis</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">var</span> showThis = o.showThis;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// undefined</span></span><br><span class="line">o.showThis(); <span class="comment">// o</span></span><br></pre></td></tr></table></figure>
<p>创建了一个类 C，并且实例化出对象 o，再把 o 的方法赋值给了变量 showThis。</p>
<p>使用 showThis 这个引用去调用方法时，得到了 undefined。</p>
<p>所以，在方法中， this 的行为也不太一样，它得到了 undefined 的结果。方法的行为跟普通函数有差异，是因为 <strong>class</strong> 设计成了默认按 <strong>strict 模式</strong>执行。</p>
<p>再举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jay Global&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jay Person&#x27;</span>,</span><br><span class="line">    details: &#123;</span><br><span class="line">        name: <span class="string">&#x27;Jay Details&#x27;</span>,</span><br><span class="line">        print: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    print: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person.details.print());  <span class="comment">// Jay Details</span></span><br><span class="line"><span class="built_in">console</span>.log(person.print());          <span class="comment">// Jay Person</span></span><br><span class="line"><span class="keyword">var</span> name1 = person.print;</span><br><span class="line"><span class="keyword">var</span> name2 = person.details;</span><br><span class="line"><span class="built_in">console</span>.log(name1()); <span class="comment">// Jay Global</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.print()) <span class="comment">// Jay Details</span></span><br></pre></td></tr></table></figure>
<h3 id="this-关键字的机制"><a href="#this-关键字的机制" class="headerlink" title="this 关键字的机制"></a>this 关键字的机制</h3><h4 id="切换上下文"><a href="#切换上下文" class="headerlink" title="切换上下文"></a>切换上下文</h4><p>函数能够引用定义时的变量，如上文分析，函数也能记住定义时的 this，因此，函数内部必定有一个机制来保存这些信息。</p>
<p>在 JS 中，为函数规定了用来保存定义时上下文的私有属性[[Environment]]。当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的[[Environment]]。</p>
<p>这个动作就是<strong>切换上下文</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js 文件</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">exports</span>.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js 文件</span></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Node环境下执行 main.js，b打印成功，a发生 ReferenceError错误</span></span><br></pre></td></tr></table></figure>
<p>这里的 foo 能够访问 b（定义时词法环境），却不能访问 a（执行时的词法环境），这就是执行上下文的切换机制。</p>
<p>JS 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。</p>
<p>而 this 则是一个更为复杂的机制，JavaScript 标准定义了 [[thisMode]] 私有属性。</p>
<p>[[thisMode]] 私有属性有三个取值。</p>
<ul>
<li>lexical：表示从上下文中找 this，这对应了箭头函数。</li>
<li>global：表示当 this 为 undefined 时，取全局对象，对应了普通函数。</li>
<li>strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。</li>
</ul>
<p>方法的行为跟普通函数有差异，恰恰是因为 class 设计成了默认按 strict 模式执行。</p>
<p>可以用 strict 达成与上一节中方法的例子一样的效果:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showThis</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    showThis: showThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// undefined</span></span><br><span class="line">o.showThis(); <span class="comment">// o</span></span><br></pre></td></tr></table></figure>
<p>函数创建新的执行上下文中的词法环境记录时，会根据[[thisMode]]来标记新纪录的[[ThisBindingStatus]]私有属性。代码执行遇到 this 时，会逐层检查当前词法环境记录中的[[ThisBindingStatus]]，当找到有 this 的环境记录时获取 this 的值。</p>
<p>这样的规则的实际效果是，<strong>嵌套的箭头函数中的代码都指向外层 this</strong></p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line">o.foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); </span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.foo()()(); <span class="comment">// o, o, o</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，我们定义了三层嵌套的函数，最外层为普通函数，两层都是箭头函数。这里调用三个函数，获得的 this 值是一致的，都是对象 o。</p>
<h3 id="操作-this-的内置函数"><a href="#操作-this-的内置函数" class="headerlink" title="操作 this 的内置函数"></a>操作 this 的内置函数</h3><p>Function.prototype.call 和 Function.prototype.apply 可以指定函数调用时传入的 this 值。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line">foo.call(&#123;&#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//1 2 3</span></span><br><span class="line">foo.apply(&#123;&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure>
<p>call 和 apply 作用是一样的，只是传参方式有区别。</p>
<p>此外，还有 Function.prototype.bind 它可以生成一个绑定过的函数，这个函数的 this 值固定了参数。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line">foo.bind(&#123;&#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)();</span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure>
<p>call、bind 和 apply 用于不接受 this 的函数类型如箭头、class 都不会报错。这时候，它们无法实现改变 this 的能力，但是可以实现传参。</p>
<p>this 关键字是为了在 JS 中加入动态作用域而做的努力。 所谓动态作用域，就是说变量的作用范围，是根据函数调用的位置而定的。从这个角度来理解 this，就简单的多。</p>
<p>this 是 JS 中的动态作用域机制, 具体来说有四种, 优先级有低到高分别如下：</p>
<ol>
<li>默认的 this 绑定，就是说 在一个函数中使用了 this，但是没有为 this 绑定对象。这种情况下，非严格默认，this 就是全局变量 Node 环境中的 global，浏览器环境中的 window。严格模式下，默认的 this 就是 undefined 了。</li>
<li>隐式绑定: 使用 obj.foo() 这样的语法来调用函数的时候，函数 foo 中的 this 绑定到 obj 对象。</li>
<li>显示绑定: foo.call(obj, …)， foo.apply(obj,[…])，foo.bind(obj,…)</li>
<li>构造绑定: new foo() ， 这种情况,，无论 foo 是否做了绑定, 都要创建一个新的对象， 然后 foo 中的 this 引用这个对象。</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>记录二</title>
    <url>/%E7%AC%94%E8%AE%B0/%E5%B0%8F%E6%9C%AC%E6%9C%AC/%E8%AE%B0%E5%BD%95%E4%BA%8C/</url>
    <content><![CDATA[<h2 id="input输入框限制输入数字"><a href="#input输入框限制输入数字" class="headerlink" title="input输入框限制输入数字"></a>input输入框限制输入数字</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 只能输入整数</span></span><br><span class="line"><span class="comment">// 绑定对应input输入框事件</span></span><br><span class="line">@input=<span class="string">&quot;addForm.numberVolumes = addForm.numberVolumes.replace(/[^\d]/g,&#x27;&#x27;)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 输入保存小数点后三位</span></span><br><span class="line"><span class="comment">// 绑定对应input输入框事件</span></span><br><span class="line">@input=<span class="string">&quot;addForm.digitizCapacity = addForm.digitizCapacity.replace(/[^\d.]/g,&#x27;&#x27;)&quot;</span></span><br><span class="line"><span class="comment">// 加入watch监听</span></span><br><span class="line">    <span class="string">&quot;addForm.digitizCapacity&quot;</span>(newVal,oldVal) &#123;</span><br><span class="line">		<span class="comment">// 第一位不能是点</span></span><br><span class="line">        <span class="keyword">if</span>(newVal[<span class="number">0</span>]===<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">          <span class="built_in">this</span>.addForm.digitizCapacity = <span class="string">&#x27;&#x27;</span></span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line"> </span><br><span class="line">        <span class="comment">// 保证一个小数点 (当输入的最后一位不是.并且已经存在一个.并且存在的这个.的下标不是最后一位)</span></span><br><span class="line">        <span class="keyword">if</span> (newVal[newVal.length-<span class="number">1</span>] === <span class="string">&#x27;.&#x27;</span> &amp;&amp; oldVal.toString().indexOf(<span class="string">&#x27;.&#x27;</span>)&gt;<span class="number">0</span> &amp;&amp; newVal.length-<span class="number">1</span> !== oldVal.toString().indexOf(<span class="string">&#x27;.&#x27;</span>))&#123;</span><br><span class="line">          <span class="built_in">this</span>.addForm.digitizCapacity = oldVal</span><br><span class="line">          <span class="keyword">return</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 小数点后保存三位</span></span><br><span class="line">        <span class="keyword">if</span> (newVal)&#123;</span><br><span class="line">          newVal = newVal.toString()</span><br><span class="line">          <span class="keyword">let</span> pointIndex = newVal.indexOf(<span class="string">&#x27;.&#x27;</span>)</span><br><span class="line">          <span class="keyword">if</span> (pointIndex&gt;<span class="number">0</span> &amp;&amp; (newVal.length-pointIndex)&gt;<span class="number">4</span>)&#123;</span><br><span class="line">            <span class="built_in">this</span>.addForm.digitizCapacity = oldVal</span><br><span class="line">            <span class="keyword">return</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">	  </span><br><span class="line">	  </span><br><span class="line"><span class="comment">// 添加校验保证最后一位不是.</span></span><br><span class="line"><span class="keyword">var</span> checkSort = <span class="function">(<span class="params">rule, value, callback</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (!value) &#123;</span><br><span class="line">	<span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;请输入内容&quot;</span>));</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(value[value.length-<span class="number">1</span>]===<span class="string">&#x27;.&#x27;</span>)&#123;</span><br><span class="line">	  <span class="keyword">return</span> callback(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">&quot;最后一位不能是.&quot;</span>));</span><br><span class="line">	&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">	  callback();</span><br><span class="line">	&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>小本本</tag>
      </tags>
  </entry>
  <entry>
    <title>ES5、6、7（2）</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/15.ES5%E3%80%816%E3%80%817%EF%BC%882%EF%BC%89/</url>
    <content><![CDATA[<p><strong>ES6（常用）</strong></p>
<h3 id="2-1-1-let、const-关键字"><a href="#2-1-1-let、const-关键字" class="headerlink" title="2.1.1 let、const 关键字"></a>2.1.1 let、const 关键字</h3><p>let：声明一个变量</p>
<ul>
<li>在块级作用域内有效</li>
<li>不能重复声明</li>
<li>不会预处理，不存在变量提升</li>
</ul>
<p>const：定义一个常量</p>
<ul>
<li>不能修改</li>
<li>其他特点同 let</li>
</ul>
<a id="more"></a>

<h4 id="var、let、const-的区别"><a href="#var、let、const-的区别" class="headerlink" title="var、let、const 的区别"></a>var、let、const 的区别</h4><ol>
<li>var 定义的变量，没有块的概念，可以跨块访问, 不能跨函数访问。</li>
<li>let 定义的变量，只能在块作用域里访问，不能跨块访问，也不能跨函数访问。</li>
<li>const 用来定义常量，使用时必须初始化(即必须赋值)，只能在块作用域里访问，而且不能修改。</li>
</ol>
<h3 id="2-1-2-变量的解构赋值"><a href="#2-1-2-变量的解构赋值" class="headerlink" title="2.1.2 变量的解构赋值"></a>2.1.2 变量的解构赋值</h3><p>从对象或数组中提取数组，并赋值给变量（多个）</p>
<p>对象的解构赋值：</p>
<p> let {n, a} = {n: ‘tom’, a:12}</p>
<p>数组的解构赋值：</p>
<p> let [a, b] = [1, ‘atguigu’]</p>
<p>用途</p>
<p> 给多个形参赋值</p>
<h4 id="获取数组中的值"><a href="#获取数组中的值" class="headerlink" title="获取数组中的值"></a>获取数组中的值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var foo &#x3D; [&quot;one&quot;, &quot;two&quot;, &quot;three&quot;, &quot;four&quot;];</span><br><span class="line"></span><br><span class="line">var [a, b, c] &#x3D; foo;</span><br><span class="line">console.log(a); &#x2F;&#x2F; &quot;one&quot;</span><br><span class="line">console.log(b); &#x2F;&#x2F; &quot;two&quot;</span><br><span class="line">console.log(c); &#x2F;&#x2F; &quot;three&quot;</span><br><span class="line">&#x2F;&#x2F; or</span><br><span class="line">var a, b;</span><br><span class="line">[a, b] &#x3D; [1, 2];</span><br><span class="line">console.log(a); &#x2F;&#x2F; 1</span><br><span class="line">console.log(b); &#x2F;&#x2F; 2</span><br></pre></td></tr></table></figure>
<h4 id="获取对象中的值"><a href="#获取对象中的值" class="headerlink" title="获取对象中的值"></a>获取对象中的值</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const student &#x3D; &#123;</span><br><span class="line">  name: &#39;Ming&#39;,</span><br><span class="line">  age: 18,</span><br><span class="line">  city: &#39;Shanghai&#39;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const &#123;name, age, city&#125; &#x3D; student;</span><br><span class="line">console.log(name); &#x2F;&#x2F; &#39;Ming&#39;</span><br><span class="line">console.log(age); &#x2F;&#x2F; 18</span><br><span class="line">console.log(city); &#x2F;&#x2F; &#39;Shanghai&#39;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-3-模板字符串"><a href="#2-1-3-模板字符串" class="headerlink" title="2.1.3 模板字符串"></a>2.1.3 模板字符串</h3><p>简化字符串的拼接</p>
<ul>
<li>必须用``包含</li>
<li>变化的部分使用 ${xxx} 定义</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name &#x3D; &#39;Your name is &#39; + first + &#39; &#39; + last + &#39;.&#39;</span><br><span class="line">&#x2F;&#x2F; 使用模板字符串</span><br><span class="line">var name &#x3D; &#96;Your name is $&#123;first&#125; $&#123;last&#125;.&#96;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-4-对象的简写方式"><a href="#2-1-4-对象的简写方式" class="headerlink" title="2.1.4 对象的简写方式"></a>2.1.4 对象的简写方式</h3><p>省略同名的属性值</p>
<p>省略方法的function</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const name&#x3D;&#39;Ming&#39;, age&#x3D;&#39;18&#39;, city&#x3D;&#39;Shanghai&#39;;</span><br><span class="line">&#x2F;&#x2F;ES5</span><br><span class="line">const student &#x3D; &#123;</span><br><span class="line">    name: name,</span><br><span class="line">    age: age,</span><br><span class="line">    city: city,</span><br><span class="line">      getName: function() &#123;</span><br><span class="line">      return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;ES6</span><br><span class="line">const student &#x3D; &#123;</span><br><span class="line">    name, &#x2F;&#x2F; 同名的属性可以省略不写</span><br><span class="line">    age,</span><br><span class="line">    city,</span><br><span class="line">      getName() &#123; &#x2F;&#x2F; 可以省略函数的function</span><br><span class="line">      return this.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(student);&#x2F;&#x2F;&#123;name: &quot;Ming&quot;, age: &quot;18&quot;, city: &quot;Shanghai&quot;&#125;</span><br><span class="line">console.log(student.getName()); &#x2F;&#x2F; Ming</span><br></pre></td></tr></table></figure>
<h3 id="2-1-5-箭头函数"><a href="#2-1-5-箭头函数" class="headerlink" title="2.1.5 箭头函数"></a>2.1.5 箭头函数</h3><p>作用：定义匿名函数</p>
<p>语法：</p>
<ul>
<li>没有参数：() =&gt; console.log(‘xxxx’)</li>
<li>一个参数：i =&gt; i+2</li>
<li>大于一个参数：(i, j) =&gt; i+j</li>
<li>函数体不用大括号：默认返回结果</li>
<li>函数体如果有多个语句，需要用{}包围，若有需要返回的内容，需要手动 return 返回</li>
</ul>
<p>使用场景：多用于定义回调函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 形参的情况</span><br><span class="line">&#x2F;&#x2F; 1.没有形参的时候</span><br><span class="line">let fun1 &#x3D; () &#x3D;&gt; console.log(&#39;我是箭头函数&#39;)</span><br><span class="line">fun1()</span><br><span class="line">&#x2F;&#x2F; 2.只有一个形参的时候，()可以省略</span><br><span class="line">let fun2 &#x3D; a &#x3D;&gt; console.log(a)</span><br><span class="line">fun2(&#39;aaa&#39;)</span><br><span class="line">&#x2F;&#x2F; 3.两个及两个以上形参的时候，()不能省略</span><br><span class="line">let fun3 &#x3D; (x, y) &#x3D;&gt; console.log(x, y)</span><br><span class="line">fun3(25, 35)</span><br><span class="line">&#x2F;&#x2F; 函数体的情况</span><br><span class="line">&#x2F;&#x2F; 1.函数体只有一条语句或表达式的时候，&#123;&#125;可以省略--&gt;会自动返回（return）语句&#x2F;表达式的结果</span><br><span class="line">fun4 &#x3D; (x, y) &#x3D;&gt; x + y</span><br><span class="line">console.log(fun4(24, 36))</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 2.函数体不止一条语句或表达式的时候，&#123;&#125;不可以省略</span><br><span class="line">let fun5 &#x3D; (x, y) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(x, y)</span><br><span class="line">  return x + y</span><br><span class="line">&#125;</span><br><span class="line">console.log(fun5(20, 30))</span><br></pre></td></tr></table></figure>
<p>箭头函数的特点：</p>
<ol>
<li>箭头函数没有自己 this，箭头函数的 this 不是调用的时候决定的，而是在定义的时候处在的对象就是它的 this（这个规则与常规函数的 this 指向相反）</li>
<li>扩展理解：箭头函数的 this 看外层的是否有函数，如果有，外层函数的 this 就是内部箭头函数的 this，如果没有，则 this 是 window</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button id&#x3D;&quot;btn1&quot;&gt;btn1&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button id&#x3D;&quot;btn2&quot;&gt;btn2&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">let btn1 &#x3D; document.getElementById(&#39;btn1&#39;)</span><br><span class="line">let btn2 &#x3D; document.getElementById(&#39;btn2&#39;)</span><br><span class="line"></span><br><span class="line">btn1.onclick &#x3D; function() &#123;</span><br><span class="line">  console.log(this) &#x2F;&#x2F; [object HTMLbuttonElement]</span><br><span class="line">&#125;</span><br><span class="line">btn2.onclick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">  console.log(this) &#x2F;&#x2F; [object Window]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>将箭头函数改为外层有函数的形式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  name: &#39;箭头函数&#39;,</span><br><span class="line">  getNmae() &#123;</span><br><span class="line">    btn2.onclick &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">          console.log(this.name) &#x2F;&#x2F; 箭头函数</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 此时箭头函数中的this指向这个obj</span><br></pre></td></tr></table></figure>
<p>再举个栗子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">  b: &#39;wy&#39;,</span><br><span class="line">  c() &#123;</span><br><span class="line">    let d &#x3D; () &#x3D;&gt; &#123;</span><br><span class="line">      console.log(this.b)</span><br><span class="line">    &#125;</span><br><span class="line">    return d &#x2F;&#x2F; 注意一定要有这个return</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let b &#x3D; &#39;ss&#39;</span><br><span class="line">a.c()() &#x2F;&#x2F; wy</span><br></pre></td></tr></table></figure>
<p>箭头函数外层有函数c，和函数c的 this 一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; &#123;</span><br><span class="line">    b: &#39;wy&#39;,</span><br><span class="line">    c: () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(this.b)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var b &#x3D; &#39;ss&#39;</span><br><span class="line">a.c() &#x2F;&#x2F; ss</span><br></pre></td></tr></table></figure>
<p>由于箭头函数外没有函数，所以this指向window</p>
<h3 id="2-1-6-三点运算符"><a href="#2-1-6-三点运算符" class="headerlink" title="2.1.6 三点运算符"></a>2.1.6 三点运算符</h3><p>用途</p>
<p>1.rest（不定/可变）参数</p>
<p>用来取代 arguments，但比 arguments 灵活，只能是最后部分形参参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function foo(a, ...value) &#123;</span><br><span class="line">  console.log(value) &#x2F;&#x2F; [7, 45, 22]</span><br><span class="line">&#125;</span><br><span class="line">foo(5, 7, 45, 22)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不定参数 value 会返回一个数组，可以用数组的所有方法；而 arguments 只是伪数组，没有数组的各种方法。</p>
</blockquote>
<p>2.扩展运算符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 6]</span><br><span class="line">let arr1 &#x3D; [2, 3, 4, 5]</span><br><span class="line">arr &#x3D; [1, ...arr1, 6]</span><br><span class="line">console.log(...arr) &#x2F;&#x2F;[1, 2, 3, 4, 5, 6]</span><br></pre></td></tr></table></figure>
<p>相当于会自动遍历这个数组，拿到每一项值</p>
<h3 id="2-1-7-形参默认值"><a href="#2-1-7-形参默认值" class="headerlink" title="2.1.7 形参默认值"></a>2.1.7 形参默认值</h3><p>当不传入参数的时候默认使用形参里的默认值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Point(x &#x3D; 0, y &#x3D; 0) &#123;</span><br><span class="line">  this.x &#x3D; x;</span><br><span class="line">  this.y &#x3D; y;</span><br><span class="line">&#125;</span><br><span class="line">let point &#x3D; new Point(23, 35)</span><br><span class="line">console.log(point) &#x2F;&#x2F; &#123;x:23, y:35&#125;</span><br><span class="line">let point2 &#x3D; new Point() &#x2F;&#x2F; 不传参数</span><br><span class="line">console.log(point) &#x2F;&#x2F; &#123;x:0, y:0&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-8-Promise-对象"><a href="#2-1-8-Promise-对象" class="headerlink" title="2.1.8 Promise 对象"></a>2.1.8 Promise 对象</h3><ol>
<li><p>Promise 对象：代表了未来某个将要发生的事件（通常是一个异步操作）</p>
<p>有了 promise 对象，可以将异步操作以同步的流程表达出来，避免了层层嵌套的回调函数（回调地狱）</p>
<p>ES6的 Promise 是一个构造函数，用来生成 Promise 实例</p>
</li>
<li><p>使用 promise 基本步骤（2步）：</p>
<ul>
<li>创建 promise 对象</li>
<li>调用 promise 的 then()</li>
</ul>
</li>
<li><p>promise 对象的3个状态</p>
<ul>
<li>pending ：初始化状态</li>
<li>fullfilled（resolved）：成功状态</li>
<li>rejected：失败状态</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>使用 promise 实现超时处理</li>
<li>使用 promise 封装处理 ajax 请求</li>
</ul>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; &#x2F;&#x2F; 同步执行</span><br><span class="line">  &#x2F;&#x2F; 初始化promise状态：pending</span><br><span class="line">  console.log(111)</span><br><span class="line">  &#x2F;&#x2F; 执行异步操作，通常是发送ajax请求 或 开启定时器</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(333)</span><br><span class="line">    &#x2F;&#x2F; 根据异步任务的返回结果来去修改promise的状态</span><br><span class="line">    &#x2F;&#x2F; 异步任务成功</span><br><span class="line">    resolve(&#39;xixi&#39;); &#x2F;&#x2F; 修改promise的状态为fullfilled（成功的状态）</span><br><span class="line">    &#x2F;&#x2F; 异步任务失败</span><br><span class="line">    &#x2F;&#x2F;reject(&#39;555&#39;) &#x2F;&#x2F; 修改promise的状态为rejected（失败的状态）</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(222)</span><br><span class="line">p.then(</span><br><span class="line">  value &#x3D;&gt; &#123; &#x2F;&#x2F; 成功的回调</span><br><span class="line">      console.log(&#39;成功了&#39;,value)</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123; &#x2F;&#x2F; 失败的回调</span><br><span class="line">      console.log(&#39;失败了&#39;,reason)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>下面是一个案例练习</p>
<p>需求：</p>
<ol>
<li>发送 ajax 请求获取新闻内容</li>
<li>新闻内容获取成功后再次发送请求，获取对应的新闻评论内容</li>
<li>新闻内容获取失败则不需要再次发送请求</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义获取新闻的功能函数</span><br><span class="line">function getData(url) &#123;</span><br><span class="line">  let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;&#x2F; 状态：初始化</span><br><span class="line">    &#x2F;&#x2F; 执行异步任务</span><br><span class="line">    &#x2F;&#x2F; 创建 xmlHttp 实例对象</span><br><span class="line">    let xmlHttp &#x3D; new XMLHttpRequest();</span><br><span class="line">    console.log(xmlHttp.readyState);</span><br><span class="line">    &#x2F;&#x2F; 绑定监听 readyState</span><br><span class="line">    xmlHttp.onreadystatechange &#x3D; function() &#123;</span><br><span class="line">      if(xmlHttp.readyState &#x3D;&#x3D;&#x3D; 4) &#123;</span><br><span class="line">        if(xmlHttp.status &#x3D;&#x3D;&#x3D; 200) &#123;</span><br><span class="line">          &#x2F;&#x2F; 修改状态</span><br><span class="line">          resolve(xmlHttp.responseText); &#x2F;&#x2F; 修改promise的状态为成功的状态</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">          reject(&#39;暂时没有新闻内容&#39;)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;open 设置请求的方式以及url</span><br><span class="line">    xmlHttp.open(&#39;GET&#39;, url);</span><br><span class="line">    &#x2F;&#x2F; 发送</span><br><span class="line">    xmlHttp.send();</span><br><span class="line">  &#125;)</span><br><span class="line">  return promise;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getData(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;news?if&#x3D;2&#39;).then(</span><br><span class="line">  (value) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    &#x2F;&#x2F; 发送请求获取评论内容准备url</span><br><span class="line">    let commentsUrl &#x3D; JSON.parse(value).commentsUrl;</span><br><span class="line">    let url &#x3D; &#39;https:&#x2F;&#x2F;localhost:3000&#39; + commentsUrl;</span><br><span class="line">    &#x2F;&#x2F; 发送请求</span><br><span class="line">    return getData(url);</span><br><span class="line">  &#125;),</span><br><span class="line">  (reason) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(reason);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-1-9-Symbol-属性"><a href="#2-1-9-Symbol-属性" class="headerlink" title="2.1.9 Symbol 属性"></a>2.1.9 Symbol 属性</h3><p>ES5 中对象的属性名都是字符串，容易造成重名，污染环境。ES6 中添加了一种原始数据类型 symbol。</p>
<p>特点：</p>
<ol>
<li>Symbol 属性值对应的值是唯一的，解决命名冲突问题</li>
<li>Symbol 值不能与其他数据进行计算，包括同字符串拼串</li>
<li>for in，for of 遍历时不会遍历 symbol 属性</li>
</ol>
<p>使用：</p>
<p><strong>1.调用 Symbol 函数得到 symbol 值</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建symbol属性值</span><br><span class="line">let symbol &#x3D; Symbol()</span><br><span class="line">let obj &#x3D; &#123;username: &#39;wy&#39;, age: 18&#125;</span><br><span class="line">obj[symbol] &#x3D; &#39;hi&#39;</span><br><span class="line">console.log(obj) &#x2F;&#x2F; &#123;username: &#39;wy&#39;, age: 18, symbol(): &#39;hi&#39;&#125;</span><br><span class="line">&#x2F;&#x2F; for in，for of 不能遍历symbol属性</span><br><span class="line">for(let i in obj) &#123;</span><br><span class="line">  console.log(i) &#x2F;&#x2F; username age</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.传参标识</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let symbol2 &#x3D; Symbol(&#39;owe&#39;)</span><br><span class="line">let symbol3 &#x3D; Symbol(&#39;two&#39;)</span><br><span class="line">console.log(symbol2 &#x3D;&#x3D; symbol3) &#x2F;&#x2F; false</span><br><span class="line">console.log(symbol2, symbol3) &#x2F;&#x2F; Symbol(owe) Symbol(two)</span><br><span class="line">&#x2F;&#x2F; 还可以去定义常量，可以作为当前常量的标识</span><br><span class="line">const Person_key &#x3D; Symbol(&#39;Person_key&#39;)</span><br><span class="line">console.log(Person_key) &#x2F;&#x2F; Symbol(Person_key)</span><br></pre></td></tr></table></figure>
<p><strong>3.内置 Symbol 值</strong></p>
<p>除了定义自己使用的 Symbol 值以外，ES6 还提供了11个内置 Symbol 值，指向语言内部使用的方法：</p>
<p>Symbol.iterator：对象的 Symbol.iterator 属性，指向该对象的默认遍历方法</p>
<h3 id="2-1-10-iterator-接口机制"><a href="#2-1-10-iterator-接口机制" class="headerlink" title="2.1.10 iterator 接口机制"></a>2.1.10 iterator 接口机制</h3><p>iterator 是一种接口机制，为各种不同的数据结构提供统一的访问机制</p>
<p>作用：</p>
<ol>
<li>为各种数据结构，提供一个统一的、简便的访问接口</li>
<li>使得数据结构成员能够按某种次序排列</li>
<li>ES6 创造了一种新的遍历命令 for of 循环，Iterator 接口主要供 for of 消费</li>
</ol>
<p>工作原理：</p>
<ul>
<li><p>创建一个指针对象（遍历器对象），指向数据结构的起始位置</p>
</li>
<li><p>第一次调用 next 方法，指针自动指向数据结构的第一个成员</p>
</li>
<li><p>接下来不断调用 next 方法，指针会一直往后移动，直到指向最后一个成员</p>
</li>
<li><p>每调用 next 方法返回的是一个包含 value 和 done 的对象，{value: 当前成员的值, done: 布尔值}</p>
<ul>
<li>value 表示当前成员的值，done 对应的布尔值表示当前的数据的结构是否遍历结束</li>
<li>当遍历结束的时候返回的 value 值是 undefined，done 值为 true</li>
</ul>
<p>原生具备 iterator 接口的数据（可用for of遍历）</p>
<p>扩展理解：</p>
<ol>
<li>当数据结构上部署了 Symbol.iterator 接口，该数据就是可以用 for of 遍历</li>
<li>当使用 for of 去遍历目标数据的时候，该数据会自动去找 Symbol.iterator 属性</li>
</ol>
<p>// Symbol.iterator 属性指向对象的默认遍历器方法</p>
<ol>
<li><p>Array</p>
</li>
<li><p>arguments</p>
</li>
<li><p>set 容器</p>
</li>
<li><p>map 容器</p>
</li>
<li><p>String</p>
<p>…</p>
</li>
</ol>
</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 模拟指针对象（遍历器对象）</span><br><span class="line">function myIterator(arr) &#123; &#x2F;&#x2F; iterator接口</span><br><span class="line">  let nextIndex &#x3D; 0;</span><br><span class="line">  return &#123; &#x2F;&#x2F; 遍历器对象</span><br><span class="line">    next: function() &#123;</span><br><span class="line">      return nextIndex &lt; arr.length ? &#123;value: arr[nextIndex++], done: false&#125;:&#123;value: undefined, done: true&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 准备一个数据</span><br><span class="line">let arr &#x3D; [1, 4, 65, &#39;abc&#39;]</span><br><span class="line">let iteratorObj &#x3D; myIterator(arr);</span><br><span class="line">console.log(iteratorObj.next()) &#x2F;&#x2F; &#123;value: 1, done: false&#125;</span><br><span class="line">console.log(iteratorObj.next()) &#x2F;&#x2F; &#123;value: 4, done: false&#125;</span><br><span class="line">console.log(iteratorObj.next()) &#x2F;&#x2F; &#123;value: 65, done: false&#125;</span><br><span class="line">console.log(iteratorObj.next()) &#x2F;&#x2F; &#123;value: &quot;abc&quot;, done: false&#125;</span><br><span class="line">console.log(iteratorObj.next()) &#x2F;&#x2F; &#123;value: undefined, done: true&#125;</span><br><span class="line">console.log(iteratorObj.next()) &#x2F;&#x2F; &#123;value: undefined, done: true&#125;</span><br><span class="line">for(let i of arr) &#123;</span><br><span class="line">  console.log(i) &#x2F;&#x2F; 1 4 65 abc</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>部署了 iterator 接口的数据类型可以使用 for of 遍历。</p>
<p>这些数据结构已经部署了上面的 iterator：数组、字符串、arguments、set 容器、map 容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; string可以使用 for of 遍历</span><br><span class="line">let str &#x3D; &#39;abcdefg&#39;</span><br><span class="line">for(let i of str) &#123;</span><br><span class="line">  console.log(i) &#x2F;&#x2F; a b c d e f g</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; arguments可以使用 for of 遍历</span><br><span class="line">funtion fun() &#123;</span><br><span class="line">    for(let i of aguments) &#123;</span><br><span class="line">    console.log(i) &#x2F;&#x2F; 1 4 65 abc</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fun(1, 4, 65, &#39;abc&#39;)</span><br><span class="line">&#x2F;&#x2F; 但是 arguments不可以使用 for each 遍历（因为它是伪数组）</span><br><span class="line">&#x2F;&#x2F; object不可以使用 for of 遍历（因为它没有部署iterator接口）</span><br><span class="line">let obj &#x3D; &#123;username: &#39;wy&#39;, age: 18&#125;</span><br><span class="line">for(let i of obj) &#123;</span><br><span class="line">  console.log(i) &#x2F;&#x2F; Uncaught TypeError:obj is not iterable</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面 Symbol 属性中提到的：</p>
<p>对象的Symbol.iterator属性，指向该对象的默认遍历器方法。</p>
<p>其用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 等同于在指定的数据结构上部署了iterator接口</span><br><span class="line">&#x2F;&#x2F; 当使用for of去遍历某一个数据结构的时候，首先去找Symbol.iterator，找到了就可以遍历，否则不能遍历，报错：xxx is not iterable</span><br><span class="line">let obj &#x3D; &#123;</span><br><span class="line">    username: &#39;wy&#39;,</span><br><span class="line">    age: 18,</span><br><span class="line">    [Symbol.iterator]()&#123;</span><br><span class="line">    let nextIndex &#x3D; 0;</span><br><span class="line">    return &#123; &#x2F;&#x2F; 遍历器对象</span><br><span class="line">      next: () &#x3D;&gt; &#123;</span><br><span class="line">        const arr &#x3D; Object.values(this)</span><br><span class="line">        return nextIndex &lt; arr.length ? &#123;value: arr[nextIndex++], done: false&#125;:&#123;value: undefined, done: true&#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">for(let i of obj) &#123;</span><br><span class="line">  console.log(i) &#x2F;&#x2F; wy 18</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实，使用三点运算符、解构赋值时，也默认会调用iterator接口</p>
<h3 id="2-1-11-Generator-函数"><a href="#2-1-11-Generator-函数" class="headerlink" title="2.1.11 Generator 函数"></a>2.1.11 Generator 函数</h3><p>概念：</p>
<ol>
<li>ES6 提供的解决异步编程的方案之一</li>
<li>Generator 函数是一个状态机，内部封装了不同状态的数据</li>
<li>用来生成遍历器对象</li>
<li>可暂停函数（惰性求值），yield 可暂停，next 方法可启动。每次返回的是 yield 后的表达式结果</li>
</ol>
<p>特点：</p>
<ol>
<li>function 与函数名之间有一个星号</li>
<li>内部用 yield 表达式来定义不同的状态</li>
<li>generator 函数返回的是指针对象（iterator），而不会执行函数内部逻辑</li>
<li>调用 next 方法函数内部逻辑开始执行，遇到 yield 表达式停止，返回{value: yield 后的表达式结果/undefined, done:true/false}</li>
<li>再次调用 next 方法会从上一次停止时的 yield 处开始，直到最后</li>
<li>yield 语句返回结果通常为 undefined，当调用 next 方法时传参内容会作为启动时（上一个）yield 语句的返回值</li>
</ol>
<p>简单使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function* myGenerator() &#123;</span><br><span class="line">  console.log(&#39;开始执行console.log语句不会阻断&#39;)</span><br><span class="line">  let result &#x3D; yield &#39;hi&#39;; &#x2F;&#x2F;result的值是从这里启动的next()的参数</span><br><span class="line">  console.log(result)</span><br><span class="line">  console.log(&#39;yield后跟一个语句而不是值时&#39;)</span><br><span class="line">  yield console.log(&#39;console.log会直接打印出来&#39;);&#x2F;&#x2F;yield后跟一个语句时，返回的对象的value就是undefined</span><br><span class="line">  console.log(&#39;暂停执行&#39;)</span><br><span class="line">  yield &#39;generator&#39;; &#x2F;&#x2F;yield后跟一个值时，返回的对象的value就是这个值</span><br><span class="line">  console.log(&#39;遍历完毕&#39;)</span><br><span class="line">  return &#39;返回结果&#39; &#x2F;&#x2F;没有return，最后一个yield的value会为undefined</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 生成遍历器对象</span><br><span class="line">let MG &#x3D; myGenerator()</span><br><span class="line">&#x2F;&#x2F; 执行函数，遇到yield后即暂停</span><br><span class="line">console.log(MG) &#x2F;&#x2F; 遍历器对象</span><br><span class="line">console.log(MG.next()) &#x2F;&#x2F; 函数执行。遇到yield暂停</span><br><span class="line">console.log(MG.next(&#39;这个值会作为启动时yield语句的返回值&#39;))</span><br><span class="line">console.log(MG.next())</span><br><span class="line">console.log(MG.next())</span><br><span class="line">&#x2F;&#x2F; 开始执行console.log语句不会阻断</span><br><span class="line">&#x2F;&#x2F; &#123;value: &quot;hi&quot;, done: false&#125;</span><br><span class="line">&#x2F;&#x2F; 这个值会作为启动时yield语句的返回值</span><br><span class="line">&#x2F;&#x2F; yield后跟一个语句而不是值时</span><br><span class="line">&#x2F;&#x2F; console.log会直接打印出来</span><br><span class="line">&#x2F;&#x2F; &#123;value: undefined, done: false&#125;</span><br><span class="line">&#x2F;&#x2F; 暂停执行</span><br><span class="line">&#x2F;&#x2F; &#123;value: &quot;generator&quot;, done: false&#125;</span><br><span class="line">&#x2F;&#x2F; 遍历完毕</span><br><span class="line">&#x2F;&#x2F; &#123;value: &quot;返回结果&quot;, done: true&#125;</span><br></pre></td></tr></table></figure>
<p>next() 会一直执行直到遇到一个 yield，就会执行其后表达式然后停止在这一步。</p>
<p>对象的 symbol.iterator 属性，指向遍历器对象，结合 generator 的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;username: &#39;wy&#39;, age: 18&#125;</span><br><span class="line">obj[Symbol.iterator] &#x3D; function* myTest() &#123;</span><br><span class="line">  yield 1</span><br><span class="line">  yield 2</span><br><span class="line">  yield 3</span><br><span class="line">&#125;</span><br><span class="line">for(let i of obj) &#123;</span><br><span class="line">  console.log(i) &#x2F;&#x2F; 1 2 3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面是 Promise 中的案例用 Generator 写的练习（用 setTimeout 来模拟 ajax 请求）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getData(url) &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 模拟一个get请求</span><br><span class="line">    var news &#x3D; &#123;id: 1, content: &#39;lalala&#39;, commentsUrl: &#39;&#x2F;comments?newsId&#x3D;1&#39;&#125; &#x2F;&#x2F; 模拟news数据</span><br><span class="line">    var comments &#x3D; [&#123;comments: &#39;aaa&#39;, newsId: &#39;1&#39;&#125;, &#123;comments: &#39;bbb&#39;, newsId: &#39;1&#39;&#125;] &#x2F;&#x2F; 模拟comments数据</span><br><span class="line">    if(url &#x3D;&#x3D;&#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;news?id&#x3D;1&#39;) &#123; &#x2F;&#x2F; 假设news数据请求成功</span><br><span class="line">      console.log(&#96;根据$&#123;url&#125;获取data内容：$&#123;news.content&#125;&#96;)</span><br><span class="line">      let newUrl &#x3D; &#96;http:&#x2F;&#x2F;localhost:3000&#x2F;news?id&#x3D;1$&#123;news.commentsUrl&#125;&#96; &#x2F;&#x2F; 新的url</span><br><span class="line">      SX.next(newUrl) &#x2F;&#x2F; 将新的url传输出去</span><br><span class="line">    &#125; else if(url &#x3D;&#x3D;&#x3D; &#39;http:&#x2F;&#x2F;localhost:3000&#x2F;news?id&#x3D;1&#x2F;comments?newsId&#x3D;1&#39;) &#123; &#x2F;&#x2F; 假设comments数据请求成功</span><br><span class="line">      console.log(&#96;根据$&#123;url&#125;获取data内容：&#96;)</span><br><span class="line">      console.log(comments)</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F; 假设请求失败</span><br><span class="line">      console.log(&#39;失败&#39;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 2000)</span><br><span class="line">&#125;</span><br><span class="line">function* sendXml() &#123;</span><br><span class="line">  let newUrl &#x3D; yield getData(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;news?id&#x3D;1&#39;) &#x2F;&#x2F; url就是传输过来的新的url</span><br><span class="line">  yield getData(newUrl) &#x2F;&#x2F; 用新的url再次调用get请求</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 获取遍历器对象</span><br><span class="line">let SX &#x3D; sendXml()</span><br><span class="line">SX.next()</span><br><span class="line">&#x2F;&#x2F; 根据http:&#x2F;&#x2F;localhost:3000&#x2F;news?id&#x3D;1获取data内容：lalala</span><br><span class="line">&#x2F;&#x2F; 根据http:&#x2F;&#x2F;localhost:3000&#x2F;news?id&#x3D;1&#x2F;comments?newsId&#x3D;1获取data内容： </span><br><span class="line">&#x2F;&#x2F; [&#123;comments: &quot;aaa&quot;, newsId: &quot;1&quot;&#125;, &#123;comments: &quot;bbb&quot;, newsId: &quot;1&quot;&#125;]</span><br></pre></td></tr></table></figure>
<h3 id="2-1-12-async-函数"><a href="#2-1-12-async-函数" class="headerlink" title="2.1.12 async 函数"></a>2.1.12 async 函数</h3><p>概念：真正意义上去解决异步回调的问题，同步流程表达异步操作</p>
<p>本质：Generator 的语法糖</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function foo() &#123;</span><br><span class="line">    await 异步操作;</span><br><span class="line">  await 异步操作;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>特点：</p>
<ol>
<li>不需要像 Generator 去调用 next 方法，遇到 await 等待，当前的异步操作完成就往下执行</li>
<li>返回的总是 Promise 对象，可以用 then 方法进行下一步操作</li>
<li>async 取代 Generator 函数的星号，await 取代 Generator 的 yield</li>
<li>语意上更为明确，使用简单</li>
</ol>
<p>简单使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function foo() &#123;</span><br><span class="line">  return new Promise(resolve &#x3D;&gt; &#123;</span><br><span class="line">    &#x2F;*</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve()</span><br><span class="line">    &#125;, 2000)</span><br><span class="line">    *&#x2F;</span><br><span class="line">    setTimeout(resolve, 2000) &#x2F;&#x2F; 简洁写法</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">async function test() &#123;</span><br><span class="line">  console.log(&#39;开始执行&#39;, new Date().toTimeString())</span><br><span class="line">  await foo();</span><br><span class="line">  console.log(&#39;执行完毕&#39;, new Date().toTimeString())</span><br><span class="line">&#125;</span><br><span class="line">test()</span><br><span class="line">&#x2F;&#x2F; 开始执行 01:25:09 GMT+0800 (中国标准时间)</span><br><span class="line">&#x2F;&#x2F; 执行完毕 01:25:11 GMT+0800 (中国标准时间)</span><br></pre></td></tr></table></figure>
<p>async 里 await 返回值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function test2() &#123;</span><br><span class="line">  return &#39;xxx&#39;</span><br><span class="line">&#125;</span><br><span class="line">async function asyncPrint() &#123;</span><br><span class="line">  let result &#x3D; await test2();</span><br><span class="line">  let result2 &#x3D; await Promise.resolve(&#39;成功了&#39;);</span><br><span class="line">  let result3 &#x3D; await Promise.reject(&#39;失败了&#39;);</span><br><span class="line">  console.log(result); &#x2F;&#x2F; xxx</span><br><span class="line">  console.log(result2); &#x2F;&#x2F; 成功了</span><br><span class="line">  console.log(result3); &#x2F;&#x2F; Uncaught (in promise) 失败了</span><br><span class="line">&#125;</span><br><span class="line">asyncPrint();</span><br></pre></td></tr></table></figure>
<p>还是同一个案例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 获取新闻内容</span><br><span class="line">async function getNews(url) &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    $.get(&#123;</span><br><span class="line">      method: &#39;GET&#39;,</span><br><span class="line">      url,</span><br><span class="line">      success: value &#x3D;&gt; resolve(value),</span><br><span class="line">      error: reason &#x3D;&gt; resolve(false)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function sendXml() &#123;</span><br><span class="line">  let result &#x3D; await getNews(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;news?id&#x3D;7&#39;);</span><br><span class="line">  console.log(result);</span><br><span class="line">  if(!result) &#123;console.log(&#39;暂时没有新闻&#39;);return&#125;</span><br><span class="line">  let result &#x3D; await getNews(&#39;http:&#x2F;&#x2F;localhost:3000&#x2F;news?id&#x3D;7&#39; + result.commentsUrl);</span><br><span class="line">  console.log(result);</span><br><span class="line">&#125;</span><br><span class="line">sendXml();</span><br></pre></td></tr></table></figure>
<h3 id="2-1-13-class-类"><a href="#2-1-13-class-类" class="headerlink" title="2.1.13 class 类"></a>2.1.13 class 类</h3><ol>
<li>通过 class 定义类/实现类的继承</li>
<li>在类中通过 constructor 定义构造方法</li>
<li>通过 new 来创建类的实例</li>
<li>通过 extends 来实现类的继承</li>
<li>通过 super 调用父类的构造方法</li>
<li>重写从父类中继承的一般方法</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name &#x3D; name</span><br><span class="line">  this.age &#x3D; age</span><br><span class="line">&#125;</span><br><span class="line">let person &#x3D; new Person(&#39;wy&#39;, 18)</span><br><span class="line">console.log(person)</span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">&#x2F;&#x2F; 定义一个人物的类</span><br><span class="line">class Person &#123;</span><br><span class="line">  &#x2F;&#x2F; 类的构造方法</span><br><span class="line">  constructor(name, age) &#123;</span><br><span class="line">    this.name &#x3D; name</span><br><span class="line">    this.age &#x3D; age</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 类的一般方法</span><br><span class="line">  showName() &#123;</span><br><span class="line">    console.log(&#39;父类方法:&#39;, this.name)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let person &#x3D; new Person(&#39;wy&#39;, 18)</span><br><span class="line">console.log(person)</span><br><span class="line">person.showName() &#x2F;&#x2F; 父类方法: wy</span><br><span class="line">&#x2F;&#x2F; 子类</span><br><span class="line">class StarPerson extends Person &#123;</span><br><span class="line">  constructor(name, age, salary) &#123;</span><br><span class="line">    super(name, age) &#x2F;&#x2F; 调用父类的构造方法</span><br><span class="line">    this.salary &#x3D; salary</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 父类的方法重写</span><br><span class="line">  showName() &#123;</span><br><span class="line">    console.log(&#39;子类方法:&#39;, this.name, this.age, this.salary)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let p1 &#x3D; new StarPerson(&#39;wd&#39;, 36, 1000)</span><br><span class="line">console.log(p1)</span><br><span class="line">p1.showName() &#x2F;&#x2F; 子类方法: wd 36 1000</span><br></pre></td></tr></table></figure>
<p>子类必须在 <code>constructor</code> 方法中调用 <code>super</code> 方法，否则新建实例时会报错。</p>
<p>这是因为子类没有自己的 <code>this</code> 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。<strong>如果不在子类的 <code>constructor</code> 中调用 <code>super</code> 方法，子类就得不到 <code>this</code> 对象。就不可以使用 <code>this</code> 关键字，否则会报错。</strong></p>
<blockquote>
<p>ES5 的继承，实质是先创造子类的实例对象 <code>this</code>，然后再将父类的方法添加到 <code>this</code> 上面（<code>Parent.apply(this)</code>）。</p>
<p>ES6 的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到 <code>this</code> 上面（所以必须先调用 <code>super</code> 方法），然后再用子类的构造函数修改 <code>this</code>。</p>
<p>如果子类没有定义<code>constructor</code>方法，这个方法会被<strong>默认添加</strong>。</p>
</blockquote>
<h4 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h4><p><code>super</code> 这个关键字，既可以当作<strong>函数</strong>使用，也可以当作<strong>对象</strong>使用。在这两种情况下，它的用法完全不同。</p>
<p><strong>1.作为函数调用：</strong></p>
<p>代表父类的构造函数，但是返回的是子类的实例，即 <code>super</code> 内部的 <code>this</code> 指的是子类的实例。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    console.log(this);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">new A() &#x2F;&#x2F; A &#123;&#125;</span><br><span class="line">new B() &#x2F;&#x2F; B &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>super()</code> 执行时，它指向的是子类 <code>B</code> 的构造函数，而不是父类 <code>A</code> 的构造函数。也就是说，<code>super()</code> 内部的 <code>this</code> 指向的是 <code>B</code>。</p>
<p>因此 <code>super()</code> 在这里相当于 <code>A.prototype.constructor.call(this)</code>。</p>
<p><strong>举个栗子</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    this.x &#x3D; 1;</span><br><span class="line">  &#125;</span><br><span class="line">  print() &#123;</span><br><span class="line">    console.log(this.x);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    this.x &#x3D; 2; &#x2F;&#x2F; 定义在实例b上</span><br><span class="line">    super.x &#x3D; 3; &#x2F;&#x2F; super指向子类实例b，覆盖2</span><br><span class="line">    console.log(super.x); &#x2F;&#x2F; 读的是原型上的（A.prototype.x），所以返回undefined</span><br><span class="line">  &#125;</span><br><span class="line">  m() &#123;</span><br><span class="line">    super.print(); &#x2F;&#x2F;实际执行的是super.print.call(this)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">b.m() &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<p>super.print() 虽然调用的是 A.prototype.print()，但是其内部的 this 指向子类 B 的实例 b。</p>
<p>又因为 super.x 赋值的属性会变成子类实例 b 的属性，所以 b.m() 打印 3，而 console.log(super.x)，读的是<code>A.prototype.x</code>，所以打印 undefined。</p>
<p><strong>2.作为对象：</strong></p>
<p><strong>在普通方法中，指向父类的原型对象；在静态方法中，指向父类。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class A &#123;</span><br><span class="line">  constructor() &#123; &#x2F;&#x2F; 属性s定义在A实例（也就是b）上</span><br><span class="line">      this.s &#x3D; 1</span><br><span class="line">  &#125;</span><br><span class="line">  p() &#123; &#x2F;&#x2F; 方法p定义在原型（也就是A.proptotype）上</span><br><span class="line">    return 2;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class B extends A &#123;</span><br><span class="line">  constructor() &#123;</span><br><span class="line">    super();</span><br><span class="line">    console.log(super.p()); &#x2F;&#x2F; 2</span><br><span class="line">    console.log(super.s); &#x2F;&#x2F; undefined</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let b &#x3D; new B();</span><br><span class="line">console.log(b.__proto__ &#x3D;&#x3D;&#x3D; B.prototype) &#x2F;&#x2F; true</span><br><span class="line">console.log(b.__proto__.__proto__ &#x3D;&#x3D;&#x3D; A.prototype) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>上面代码中，子类 <code>B</code> 当中的 <code>super.p()</code>，就是将 <code>super</code> 当作一个对象使用。这时，<code>super</code> 在普通方法之中，指向 <code>A.prototype</code>，所以 <code>super.p()</code> 就相当于<code>A.prototype.p()</code>。</p>
<blockquote>
<p>这里需要注意：由于 <code>super</code> 指向<strong>父类的原型对象</strong>，所以定义在<strong>父类实例上的方法或属性，是无法通过 <code>super</code> 调用的</strong>。如果属性 x 定义在 <code>父类.prototype</code> 上面，那么 <code>super.x</code> 就可以取到它的值。</p>
<p>当 <code>super</code> 作为对象，用在静态方法之中时， 将指向父类，而不是父类的原型对象。并且其 this 指向子类而不是子类实例。</p>
</blockquote>
<h3 id="2-1-14-Module-模块化"><a href="#2-1-14-Module-模块化" class="headerlink" title="2.1.14 Module 模块化"></a>2.1.14 Module 模块化</h3><p>ES6 将一个文件视为一个模块，一个模块中用 export 来导出多个变量或函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 导出变量</span><br><span class="line">export var name &#x3D; &#39;Rainbow&#39;</span><br><span class="line">&#x2F;&#x2F; or</span><br><span class="line">var name &#x3D; &#39;Rainbow&#39;;</span><br><span class="line">var age &#x3D; &#39;21&#39;;</span><br><span class="line">export &#123;name, age&#125;;</span><br><span class="line">&#x2F;&#x2F; 导出函数</span><br><span class="line">export function myModule(someArgs) &#123;</span><br><span class="line">  return someArgs;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在一个模块中定义好的导出可以在另外一个模块通过 import 引用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123;myModule&#125; from &#39;main.js&#39;;</span><br><span class="line">import &#123;name, age&#125; from &#39;test.js&#39;;</span><br></pre></td></tr></table></figure>
<p><strong>import 后加花括号{}和不加花括号的区别：</strong></p>
<p><code>export default</code> 命令用于指定模块的默认输出。一个模块只能有一个默认输出，因此 <code>export deault</code> 命令只能使用一次。</p>
<p>所以，import 命令后面才不用加大括号，相反其它的 export 输出可以有多个，且 import 时必须加大括号。</p>
<p>也就是说，通过 <code>import xxx from &quot;...&quot;</code> 引入的，xxx 已经是默认导出项的别名（自己取的其他名字）了。<br>而 <code>import &#123; xxx &#125; from &quot;...&quot;</code> 引入的，{ xxx } 只是导出项的名字（跟原名一致），而并非导入时的名字。</p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES5、6、7（3）</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/16.ES5%E3%80%816%E3%80%817%EF%BC%883%EF%BC%89/</url>
    <content><![CDATA[<h3 id="2-2-其他"><a href="#2-2-其他" class="headerlink" title="2.2 其他"></a>2.2 其他</h3><h4 id="2-2-1-字符串、数组的扩展"><a href="#2-2-1-字符串、数组的扩展" class="headerlink" title="2.2.1 字符串、数组的扩展"></a>2.2.1 字符串、数组的扩展</h4><h5 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h5><ol>
<li>includes(str)：判断是否包含指定的字符串</li>
<li>startsWith(str)：判断是否以指定字符串开头</li>
<li>endsWith(str)：判断是否以指定字符串结尾</li>
<li>repeat(count)：重复指定次数</li>
</ol>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let str &#x3D; &#39;asdfghjkl&#39;</span><br><span class="line"></span><br><span class="line">console.log(str.includes(&#39;t&#39;)) &#x2F;&#x2F; false</span><br><span class="line">console.log(str.includes(&#39;a&#39;)) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(str.startsWith(&#39;a&#39;)) &#x2F;&#x2F; true</span><br><span class="line">console.log(str.endsWith(&#39;l&#39;)) &#x2F;&#x2F; true</span><br><span class="line">console.log(str.repeat(3)) &#x2F;&#x2F; asdfghjklasdfghjklasdfghjkl</span><br></pre></td></tr></table></figure>
<h5 id="数值"><a href="#数值" class="headerlink" title="数值"></a>数值</h5><ol>
<li>二进制与八进制数值表示法：二进制用0b，八进制用0o</li>
<li>Number.isFinite(i)：判断是否是有限大的数</li>
<li>Number.isNaN(i)：判断是否是NaN</li>
<li>Number.isInteger(i)：判断是否是整数</li>
<li>Number.parseInt(str)：将字符串转换为对应的数值</li>
<li>Math.trunc(i)：直接去除小数部分</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(0b1010) &#x2F;&#x2F; 10</span><br><span class="line">console.log(0o56) &#x2F;&#x2F; 46</span><br><span class="line"></span><br><span class="line">console.log(Number.isFinite(Infinity)) &#x2F;&#x2F; false</span><br><span class="line">console.log(Number.isNaN(NaN)) &#x2F;&#x2F; true</span><br><span class="line">console.log(Number.isInteger(123.12)) &#x2F;&#x2F; false</span><br><span class="line">console.log(Number.isInteger(123.0)) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">console.log(Number.parseInt(&#39;123abc123&#39;)) &#x2F;&#x2F; 123</span><br><span class="line">console.log(Number.parseInt(&#39;a123abc123&#39;)) &#x2F;&#x2F; NaN</span><br><span class="line"></span><br><span class="line">console.log(Math.trunc(123.123)) &#x2F;&#x2F; 123</span><br></pre></td></tr></table></figure>
<h4 id="2-2-2-数组方法的扩展"><a href="#2-2-2-数组方法的扩展" class="headerlink" title="2.2.2 数组方法的扩展"></a>2.2.2 数组方法的扩展</h4><ol>
<li>Array.from(v)：将伪数组对象或可遍历对象转换为真数组</li>
<li>Array.of(v1, v2, v3)：将一系列值转换成数组</li>
<li>find(function(value, index, arr) {return true})：找出第一个满足条件返回 true 的元素</li>
<li>findIndex(function(value,index,arr) {return true})：找出第一个满足条件返回 true 的元素下标</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button&gt;测试1&lt;&#x2F;button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;button&gt;测试2&lt;&#x2F;button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;button&gt;测试3&lt;&#x2F;button&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line"></span><br><span class="line">let btns &#x3D; document.getElementsByTagName(&#39;button&#39;) &#x2F;&#x2F; 获取一个伪数组，没有数组的一般方法</span><br><span class="line">Array.from(btns).forEach(i &#x3D;&gt; &#123;</span><br><span class="line">    console.log(i)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">let arr &#x3D; Array.of(1, 4, &#39;abc&#39;, true)</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [1, 4, &quot;abc&quot;, true]</span><br><span class="line"></span><br><span class="line">let arr2 &#x3D; [1, 4, 3, 7, 5, 8]</span><br><span class="line">let result &#x3D; arr2.find((item, index) &#x3D;&gt; &#123;</span><br><span class="line">  return item &gt; 4</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result) &#x2F;&#x2F; 7</span><br><span class="line">let result2 &#x3D; arr2.findIndex((item, index) &#x3D;&gt; &#123;</span><br><span class="line">  return item &gt; 4</span><br><span class="line">&#125;)</span><br><span class="line">console.log(result2) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<h4 id="2-2-3-对象方法的扩展"><a href="#2-2-3-对象方法的扩展" class="headerlink" title="2.2.3 对象方法的扩展"></a>2.2.3 对象方法的扩展</h4><ol>
<li>Object.is(v1,v2)：判断2个数据是否完全相等</li>
<li>Object.assign(target,source1,source2..)：将源对象的属性复制到目标对象上</li>
<li>直接操作<code>__proto__</code>属性：<code>let obj2 = &#123;&#125;;obj2.__proto__ = obj1;</code></li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(0 &#x3D;&#x3D; -0) &#x2F;&#x2F; true</span><br><span class="line">console.log(NaN &#x3D;&#x3D; NaN) &#x2F;&#x2F; false(NaN和任何值都不相等)</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;Object.is()是以类型和字符串来判断的</span><br><span class="line">console.log(Object.is(0, -0)) &#x2F;&#x2F; false</span><br><span class="line">console.log(Object.is(NaN, NaN)) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;&#125;</span><br><span class="line">let obj1 &#x3D; &#123;username: &#39;wy&#39;, age: 18&#125;</span><br><span class="line">let obj2 &#x3D; &#123;sex: &#39;male&#39;&#125;</span><br><span class="line">Object.assign(obj, obj1, obj2)</span><br><span class="line">console.log(obj) &#x2F;&#x2F; &#123;username: &#39;wy&#39;, age: 18, sex: &#39;male&#39;&#125;</span><br><span class="line"></span><br><span class="line">let obj3 &#x3D; &#123;&#125;</span><br><span class="line">let obj4 &#x3D; &#123;money: 5000&#125;</span><br><span class="line">obj3.__proto__ &#x3D; obj4 &#x2F;&#x2F; 设置obj4为obj3的原型（父类）</span><br><span class="line">console.log(obj3) &#x2F;&#x2F; &#123;&#125;&gt;__proto__:money: 5000</span><br><span class="line">console.log(obj3.money) &#x2F;&#x2F; 5000</span><br></pre></td></tr></table></figure>
<h4 id="2-2-4-深度克隆"><a href="#2-2-4-深度克隆" class="headerlink" title="2.2.4 深度克隆"></a>2.2.4 深度克隆</h4><p>浅拷贝和深拷贝针对的是<code>对象/数组</code>，因为基本<code>数据类型</code>没有浅/深一说，它复制都会生成新数据，原数据永远不会被影响。</p>
<blockquote>
<p>深拷贝和浅拷贝最根本的区别在于是否是真正获取了一个对象的复制实体，而不是引用。深拷贝在计算机中开辟了一块内存地址用于存放复制的对象，而浅拷贝仅仅是指向被拷贝的内存地址，如果原地址中对象被改变了，那么浅拷贝出来的对象也会相应改变。</p>
</blockquote>
<p>也就是说：</p>
<p> <strong>浅拷贝</strong>：拷贝的引用，修改拷贝后<strong>会影响</strong>原数据，使得原数据不安全</p>
<p> <strong>深拷贝(深度克隆)**：拷贝后生成新数据，修改拷贝后</strong>不会影响**原数据</p>
<p>拷贝数据的方法有下面几种：</p>
<h5 id="2-2-4-1-直接赋值给一个变量：浅拷贝"><a href="#2-2-4-1-直接赋值给一个变量：浅拷贝" class="headerlink" title="2.2.4.1 直接赋值给一个变量：浅拷贝"></a>2.2.4.1 直接赋值给一个变量：浅拷贝</h5><p>基本数据类型：拷贝后会生成一份新的数据，修改拷贝以后的数据<strong>不会影响</strong>原数据</p>
<p>对象/数组：拷贝后不会生成新的数据，而是复制的引用。修改拷贝后的数据<strong>会影响</strong>原来的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 不会影响原数据 生成新数据</span><br><span class="line">let str &#x3D; &#39;abc&#39;</span><br><span class="line">let str2 &#x3D; str</span><br><span class="line">console.log(str2) &#x2F;&#x2F; abc</span><br><span class="line">str2 &#x3D; &#39;&#39;</span><br><span class="line">console.log(str) &#x2F;&#x2F; abc</span><br><span class="line"></span><br><span class="line">let bool1 &#x3D; true</span><br><span class="line">let bool2 &#x3D; bool1</span><br><span class="line">bool2 &#x3D; false</span><br><span class="line">console.log(bool1) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 拷贝数组&#x2F;对象，没有生成新的数据而是复制了一份引用，改变会影响原数据</span><br><span class="line">let obj &#x3D; &#123;username: &#39;wy&#39;, age: 18&#125;</span><br><span class="line">let obj1 &#x3D; obj</span><br><span class="line">console.log(obj1) &#x2F;&#x2F; &#123;username: &#39;wy&#39;, age: 18&#125;</span><br><span class="line">obj1.username &#x3D; &#39;wd&#39;</span><br><span class="line">console.log(obj.username) &#x2F;&#x2F; wd</span><br><span class="line"></span><br><span class="line">let arr &#x3D; [1, 4, &#123;username: &#39;wy&#39;, age: 18&#125;]</span><br><span class="line">let arr2 &#x3D; arr</span><br><span class="line">arr2[0] &#x3D; &#39;abc&#39;</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [&#39;abc&#39;, 4, &#123;username: &#39;wy&#39;, age: 18&#125;]</span><br></pre></td></tr></table></figure>
<h5 id="2-2-4-2-Object-assign-：浅拷贝"><a href="#2-2-4-2-Object-assign-：浅拷贝" class="headerlink" title="2.2.4.2 Object.assign()：浅拷贝"></a>2.2.4.2 Object.assign()：浅拷贝</h5><p>Object.assign(target,source1,source2..)：将源对象的属性复制到目标对象上，并返回目标对象。</p>
<p><strong>注意： 当对象只有一级属性为深拷贝；当对象中有多级属性时，二级属性后就是浅拷贝</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;username: &#39;wy&#39;, info: &#123;num: 101&#125;&#125;</span><br><span class="line">let obj2 &#x3D; Object.assign(&#123;&#125;, obj)</span><br><span class="line">console.log(obj2) &#x2F;&#x2F; &#123;username: &#39;wy&#39;, info: &#123;num: 101&#125;&#125;</span><br><span class="line">&#x2F;&#x2F; 修改obj2中的一级属性，不会影响原数组</span><br><span class="line">obj2.username &#x3D; &#39;wd&#39;</span><br><span class="line">console.log(obj) &#x2F;&#x2F; &#123;username: &#39;wy&#39;, info: &#123;num: 101&#125;&#125;</span><br><span class="line">&#x2F;&#x2F; 修改obj2中的二级属性，会影响原数组</span><br><span class="line">obj2.info.num &#x3D; 102</span><br><span class="line">console.log(obj) &#x2F;&#x2F; &#123;username: &#39;wy&#39;, info: &#123;num: 102&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆，这时候 obj 与 obj2 指向的是不同的栈对象，所以对 obj.username 重新复制也不会影响到 obj.username。<strong>但是 obj.info 是一个栈对象的引用，而不是一个字符串，那么赋值给 obj2 时，obj2.info 也同样是这个栈对象的引用</strong>。</p>
<h5 id="2-2-4-3-Array-prototype-concat-：浅拷贝"><a href="#2-2-4-3-Array-prototype-concat-：浅拷贝" class="headerlink" title="2.2.4.3 Array.prototype.concat()：浅拷贝"></a>2.2.4.3 Array.prototype.concat()：浅拷贝</h5><p>与 Object.assign() 相似，<strong>当数组中的元素均为一维是深拷贝，数组中元素一维以上是值的引用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 3, &#123;username: &#39;wy&#39;&#125;, [4]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 如果不传参,相当于拷贝了一份</span><br><span class="line">let arr3 &#x3D; arr.concat() &#x2F;&#x2F; 还可以写为 let arr3 &#x3D; [].concat(arr)</span><br><span class="line">console.log(arr3) &#x2F;&#x2F; [1, 3, &#123;username: &#39;wy&#39;&#125;, [4]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改arr3中的一维，不会影响原数组</span><br><span class="line">arr3[1] &#x3D; &#39;abc&#39;</span><br><span class="line">arr3.push(&#39;test&#39;)</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [1, 3, &#123;username: &#39;wy&#39;&#125;, [4]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改arr3中的二维，会影响原数组</span><br><span class="line">arr3[2].username &#x3D; &#39;wd&#39;</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [1, 3, &#123;username: &#39;wd&#39;&#125;, [4]]</span><br><span class="line">arr3[3].push(&#39;test&#39;)</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [1, 3, &#123;username: &#39;wd&#39;&#125;, [4, &quot;test&quot;]]</span><br></pre></td></tr></table></figure>
<h5 id="2-2-4-4-Array-prototype-slice-：浅拷贝"><a href="#2-2-4-4-Array-prototype-slice-：浅拷贝" class="headerlink" title="2.2.4.4 Array.prototype.slice()：浅拷贝"></a>2.2.4.4 Array.prototype.slice()：浅拷贝</h5><p>slice(idx1, idx2)</p>
<p>1）没有参数是拷贝数组</p>
<p>2）只有一个参数是从该位置起到结束拷贝数组元素</p>
<p>3）两个参数，拷贝从起始位置到结束位置的元素（不包含结束位置的元素：含头不含尾）</p>
<p>同样，<strong>当数组中的元素均为一维是深拷贝，数组中元素一维以上是值的引用</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 3, &#123;username: &#39;wy&#39;&#125;, [4]]</span><br><span class="line">&#x2F;&#x2F; 返回截取的数组片段</span><br><span class="line">let arr2 &#x3D; arr.slice(0, 2)</span><br><span class="line">console.log(arr2) &#x2F;&#x2F; [1, 3]</span><br><span class="line">&#x2F;&#x2F; 如果不传参,相当于拷贝了一份</span><br><span class="line">let arr3 &#x3D; arr.slice()</span><br><span class="line">console.log(arr3)&#x2F;&#x2F; [1, 3, &#123;username: &#39;wy&#39;&#125;, [4]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改arr3中的一维，不会影响原数组</span><br><span class="line">arr3[1] &#x3D; &#39;abc&#39;</span><br><span class="line">arr3.push(&#39;test&#39;)</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [1, 3, &#123;username: &#39;wy&#39;&#125;, [4]]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改arr3中的二维，会影响原数组</span><br><span class="line">arr3[2].username &#x3D; &#39;wd&#39;</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [1, 3, &#123;username: &#39;wd&#39;&#125;, [4]]</span><br><span class="line">arr3[3].push(&#39;test&#39;)</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [1, 3, &#123;username: &#39;wd&#39;&#125;, [4, &quot;test&quot;]]</span><br></pre></td></tr></table></figure>
<h5 id="2-2-4-5-JSON-parse-JSON-stringify-：深拷贝"><a href="#2-2-4-5-JSON-parse-JSON-stringify-：深拷贝" class="headerlink" title="2.2.4.5 JSON.parse(JSON.stringify())：深拷贝"></a>2.2.4.5 JSON.parse(JSON.stringify())：深拷贝</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 3, &#123;username: &#39;wy&#39;&#125;]</span><br><span class="line">&#x2F;&#x2F; 相当于拷贝了一份</span><br><span class="line">let arr2 &#x3D; JSON.parse(JSON.stringify(arr))</span><br><span class="line">console.log(arr2) &#x2F;&#x2F; [1, 3, &#123;username: &#39;wy&#39;&#125;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改arr2中的基本数据类型number，不会影响原数组</span><br><span class="line">arr2[1] &#x3D; &#39;abc&#39;</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [1, 3, &#123;username: &#39;wy&#39;&#125;]</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 修改arr2中的Object类型，不会影响原数组</span><br><span class="line">arr2[2].username &#x3D; &#39;wd&#39;</span><br><span class="line">console.log(arr, arr2) &#x2F;&#x2F; [1, 3, &#123;username: &#39;wy&#39;&#125;] [1, 3, &#123;username: &#39;wd&#39;&#125;]</span><br></pre></td></tr></table></figure>
<blockquote>
<p>需要注意的是：这种拷贝方法不可以拷贝一些特殊的属性（例如正则表达式，undefined，function函数）</p>
</blockquote>
<p>更重要的是，这种方法只能克隆原始对象自身的值，不能克隆它继承的值，参考如下代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var clone &#x3D; function (obj) &#123;</span><br><span class="line">  return JSON.parse(JSON.stringify(obj));</span><br><span class="line">&#125;</span><br><span class="line">function Person (name) &#123;</span><br><span class="line">  this.name &#x3D; name</span><br><span class="line">&#125;</span><br><span class="line">Person.prototype &#x3D; &#123;</span><br><span class="line">  age: 18,</span><br><span class="line">&#125;</span><br><span class="line">var wanger &#x3D; new Person(&#39;王二&#39;)</span><br><span class="line">var newwanger &#x3D; clone(wanger)</span><br><span class="line">console.log(wanger) &#x2F;&#x2F; Person &#123;name: &quot;王二&quot;, __proto__: &#123;age: 18&#125;&#125;</span><br><span class="line">console.log(newwanger) &#x2F;&#x2F; &#123;name: &quot;王二&quot;&#125;</span><br><span class="line">wanger instanceof Person &#x2F;&#x2F; true</span><br><span class="line">newwanger instanceof Person &#x2F;&#x2F; false</span><br><span class="line">newwanger instanceof Object &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>克隆的对象的构造函数已经变成了 Object，而原来的对象的构造是 Person。</p>
<h4 id="2-2-5-如何实现深度拷贝（克隆）"><a href="#2-2-5-如何实现深度拷贝（克隆）" class="headerlink" title="2.2.5 如何实现深度拷贝（克隆）"></a>2.2.5 如何实现深度拷贝（克隆）</h4><p>拷贝的数据都是基本数据时，确保都是深度克隆，不会影响到原数据。</p>
<p>如果有对象/数组，可以遍历它们，拿到里面的每一项值，直到拿到的是基本数据类型，然后再去复制，可以实现对象/数组的深度拷贝。</p>
<h5 id="知识点储备"><a href="#知识点储备" class="headerlink" title="知识点储备"></a>知识点储备</h5><p>如何判断数据类型：arr —&gt; Array，null —&gt; Null</p>
<ol>
<li><strong>typeOf 返回的数据类型：</strong>String，Number，Boolean，Undefined，Object（null也会返回一个Object，因为null默认是一个空对象），Function</li>
<li>Object.prototype.toString()</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let result &#x3D; &#39;abc&#39;</span><br><span class="line">console.log(Object.prototype.toString.call(result)) &#x2F;&#x2F; [object String]</span><br><span class="line">result &#x3D; null</span><br><span class="line">console.log(Object.prototype.toString.call(result)) &#x2F;&#x2F; [object Null]</span><br><span class="line">result &#x3D; [1, 2, 3]</span><br><span class="line">console.log(Object.prototype.toString.call(result)) &#x2F;&#x2F; [object Array]</span><br><span class="line">console.log(Object.prototype.toString.call(result).slice(8, -1)) &#x2F;&#x2F; Array</span><br></pre></td></tr></table></figure>
<ol>
<li>for in 循环 对象(属性名) 数组(下标)</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let obj &#x3D; &#123;username: &#39;wy&#39;, age: 18&#125;</span><br><span class="line">for(let i in obj) &#123;</span><br><span class="line">  console.log(i) &#x2F;&#x2F; username age</span><br><span class="line">&#125;</span><br><span class="line">let arr &#x3D; [1, 3, &#39;abc&#39;]</span><br><span class="line">for(let i in arr) &#123;</span><br><span class="line">  console.log(i) &#x2F;&#x2F; 0 1 2</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>完整实现深度克隆：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定义检测数据类型的功能函数</span><br><span class="line">function checkedType(target) &#123;</span><br><span class="line">  return Object.prototype.toString.call(target).slice(8, -1)</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 实现深度克隆 ---&gt; 对象&#x2F;数组</span><br><span class="line">function clone(target) &#123;</span><br><span class="line">  &#x2F;&#x2F; 判断拷贝的数据类型</span><br><span class="line">  &#x2F;&#x2F; 初始化变量result成为最终克隆的数据</span><br><span class="line">  let result, targetType &#x3D; checkedType(target);</span><br><span class="line">  if(targetType &#x3D;&#x3D;&#x3D; &#39;Object&#39;) &#123;</span><br><span class="line">    result &#x3D; &#123;&#125;;</span><br><span class="line">  &#125; else if(targetType &#x3D;&#x3D;&#x3D; &#39;Array&#39;) &#123;</span><br><span class="line">    result &#x3D; [];</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return target;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F; 遍历目标数据</span><br><span class="line">  for(let i in target) &#123;</span><br><span class="line">    &#x2F;&#x2F; 获取遍历数据结构的每一项值</span><br><span class="line">    let value &#x3D; target[i];</span><br><span class="line">    &#x2F;&#x2F; 判断目标结构里的每一项值是否存在对象&#x2F;数组</span><br><span class="line">    if(checkedType(value) &#x3D;&#x3D;&#x3D; &#39;Object&#39; || checkedType(value) &#x3D;&#x3D;&#x3D; &#39;Array&#39;) &#123; &#x2F;&#x2F; 对象&#x2F;数组中又嵌套着对象&#x2F;数组</span><br><span class="line">      &#x2F;&#x2F; 继续遍历获取到的value</span><br><span class="line">      result[i] &#x3D; clone(value);</span><br><span class="line">    &#125; else &#123; &#x2F;&#x2F;　获取到的value是基本的数据类型或函数</span><br><span class="line">      result[i] &#x3D; value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return result;</span><br><span class="line">&#125;</span><br><span class="line">let arr &#x3D; [1, 3, [5, 7, &#123;username: &#39;wy&#39;, age: 18&#125;, 15], 9]</span><br><span class="line">let arr2 &#x3D; clone(arr)</span><br><span class="line">console.log(arr2) &#x2F;&#x2F; [1, 3, [5, 7, &#123;username: &#39;wy&#39;, age: 18&#125;, 15], 9]</span><br><span class="line">arr2[2][2].username &#x3D; &#39;wd&#39;</span><br><span class="line">console.log(arr, arr2) &#x2F;&#x2F; [1, 3, [5, 7, &#123;username: &#39;wy&#39;, age: 18&#125;, 15], 9] [1, 3, [5, 7, &#123;username: &#39;wd&#39;, age: 18&#125;, 15], 9]</span><br><span class="line"></span><br><span class="line">let obj &#x3D; &#123;username: &#39;wy&#39;, age: 18&#125;</span><br><span class="line">let obj2 &#x3D; clone(obj)</span><br><span class="line">console.log(obj2) &#x2F;&#x2F; &#123;username: &quot;wy&quot;, age: 18&#125;</span><br><span class="line">obj2.username &#x3D; &#39;wd&#39;</span><br><span class="line">console.log(obj, obj2) &#x2F;&#x2F;&#123;username: &quot;wy&quot;, age: 18&#125; &#123;username: &quot;wd&quot;, age: 18&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-6-Set-和-Map-数据结构"><a href="#2-2-6-Set-和-Map-数据结构" class="headerlink" title="2.2.6 Set 和 Map 数据结构"></a>2.2.6 Set 和 Map 数据结构</h4><h5 id="Set-容器"><a href="#Set-容器" class="headerlink" title="Set 容器"></a>Set 容器</h5><p>无序不可重复的多个 value 的集合体</p>
<ul>
<li>Set()</li>
<li>Set(array)</li>
<li>add(value)：添加</li>
<li>delete(value)：删除</li>
<li>has(value)：判断有没有</li>
<li>clear()：清空</li>
<li>size：有几个（相当于length）</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let set &#x3D; new Set([1, 2, 4, 5, 2, 3, 6])</span><br><span class="line">console.log(set) &#x2F;&#x2F; Set(6) &#123;1, 2, 4, 5, 3, 6&#125;</span><br><span class="line">&#x2F;&#x2F; 重复的2被删去了</span><br><span class="line">set.add(7)</span><br><span class="line">console.log(set.size, set) &#x2F;&#x2F; 7 Set(7) &#123;1, 2, 4, 5, 3, 6, 7&#125;</span><br><span class="line"></span><br><span class="line">console.log(set.has(8)) &#x2F;&#x2F; false</span><br><span class="line">console.log(set.has(7)) &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">set.clear()</span><br><span class="line">console.log(set) &#x2F;&#x2F; Set(0) &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>用 Set 去重：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr1 &#x3D; [1, 2, 4, 5, 5, 6, 8, 2]</span><br><span class="line">let arr &#x3D; [... new Set(arr1)]</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [1, 2, 4, 5, 6, 8]</span><br></pre></td></tr></table></figure>
<h5 id="Map-容器"><a href="#Map-容器" class="headerlink" title="Map 容器"></a>Map 容器</h5><p>无序的 key 不重复的多个 key-value 的集合体</p>
<ul>
<li>Map()</li>
<li>Map(array)</li>
<li>set(key,value)：添加</li>
<li>get(key)</li>
<li>delete(key)：删除</li>
<li>has(key)</li>
<li>clear()</li>
<li>size</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let map &#x3D; new Map([ [&#39;aaa&#39;, &#39;username&#39;], [36, &#39;age&#39;] ])</span><br><span class="line">&#x2F;&#x2F; 添加</span><br><span class="line">map.set(78, &#39;hh&#39;)</span><br><span class="line">console.log(map) &#x2F;&#x2F; Map(3) &#123;&quot;aaa&quot; &#x3D;&gt; &quot;username&quot;, 36 &#x3D;&gt; &quot;age&quot;, 78 &#x3D;&gt; &quot;hh&quot;&#125;</span><br><span class="line">&#x2F;&#x2F; 删除</span><br><span class="line">map.delete(36)</span><br><span class="line">console.log(map) &#x2F;&#x2F; Map(2) &#123;&quot;aaa&quot; &#x3D;&gt; &quot;username&quot;, 78 &#x3D;&gt; &quot;hh&quot;&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-2-7-for-of-用法"><a href="#2-2-7-for-of-用法" class="headerlink" title="2.2.7 for of 用法"></a>2.2.7 for of 用法</h4><p>for(let value of target) {} 循环遍历（必须部署 iterator）</p>
<ol>
<li>遍历数组</li>
<li>遍历 Set</li>
<li>遍历 Map</li>
<li>遍历字符串</li>
<li>遍历伪数组</li>
</ol>
<p>前面 Set 去重的方法用 for of 可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr1 &#x3D; [1, 2, 4, 5, 5, 6, 8, 2]</span><br><span class="line">let arr &#x3D; []</span><br><span class="line">let set &#x3D; new Set(arr1)</span><br><span class="line">for(let i of set) &#123;</span><br><span class="line">  arr.push(i) </span><br><span class="line">&#125;</span><br><span class="line">console.log(arr) &#x2F;&#x2F; [1, 2, 4, 5, 6, 8]</span><br></pre></td></tr></table></figure>
<h2 id="三、ES7"><a href="#三、ES7" class="headerlink" title="三、ES7"></a>三、ES7</h2><ol>
<li>指数运算符<code>**</code>（幂）</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(3 ** 3) &#x2F;&#x2F; 27</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Array.prototype.includes(value)：判断数组中是否包含指定 value</p>
<blockquote>
<p>ES6 中只有 String 的 includes，ES7 中补上了 Array 的 includes</p>
</blockquote>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 4, 5, 6, &#39;abc&#39;]</span><br><span class="line">console.log(arr.includes(&#39;a&#39;)) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV18s411E7Nd?p=1">尚硅谷ECMAScript教程(ecmascript详解含es5、es6)</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>ES5、6、7（1）</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/14.ES5%E3%80%816%E3%80%817%EF%BC%881%EF%BC%89/</url>
    <content><![CDATA[<p>ES的几个重要版本</p>
<ul>
<li>ES5：09年发布</li>
<li>ES6(ES2015)：15年发布</li>
<li>ES7(ES2016)：16年发布(变化不大)</li>
</ul>
<h2 id="ES5"><a href="#ES5" class="headerlink" title="ES5"></a>ES5</h2><h3 id="1-1-严格模式"><a href="#1-1-严格模式" class="headerlink" title="1.1 严格模式"></a>1.1 严格模式</h3><p>除了正常运行模式，ES5 添加了第二种模式“严格模式”，使得 JS 在更严格的语法条件下运行。</p>
<p>目的：消除 JS 语法的不合理/不严谨/不安全之处，为代码的安全运行保驾护航。</p>
<a id="more"></a>

<p>使用：</p>
<ul>
<li>在全局或函数的第一条语句定义为：’use strict’</li>
<li>如果浏览器不支持，只解析为一条简单的语句，没有任何副作用</li>
</ul>
<p>语法和行为改变：</p>
<ul>
<li>必须使用 var 声明变量</li>
<li>禁止自定义的函数中的 this 指向 window</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;use strict&#39;</span><br><span class="line">function Person(name, age) &#123;</span><br><span class="line">  this.name &#x3D; name;</span><br><span class="line">  this.age &#x3D; age;</span><br><span class="line">&#125;</span><br><span class="line">new Person(&#39;kb&#39;, 39)&#x2F;&#x2F; 不加上new</span><br><span class="line">&#x2F;&#x2F; 报错Uncaught TypeError: Cannot set property &#39;name&#39; of undefined</span><br><span class="line"></span><br><span class="line">new Person(&#39;kb&#39;, 39) &#x2F;&#x2F; 加上new</span><br><span class="line">&#x2F;&#x2F; 不报错Person &#123;name: &quot;kb&quot;, age: 39&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为此时 Person 中的 this 指向的是 window；只有加上 new，this 才指向 new 出来的一个实例对象</p>
</blockquote>
<ul>
<li>创建 eval 作用域(目前不推荐使用)</li>
<li>对象不能有重名的属性</li>
</ul>
<h3 id="1-2-JSON-对象"><a href="#1-2-JSON-对象" class="headerlink" title="1.2 JSON 对象"></a>1.2 JSON 对象</h3><ol>
<li><p>JSON.stringify(obj/arr)</p>
<p>将 js 对象(数组)转换为 json 对象(数组)</p>
</li>
<li><p>JSON.parse(json)</p>
<p>将 json 对象(数组)转换为 js 对象(数组)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;username: &#39;kb&#39;&#125;; &#x2F;&#x2F; 创建一个js对象</span><br><span class="line"></span><br><span class="line">obj &#x3D; JSON.stringify(obj); &#x2F;&#x2F; 转换成JSON对象</span><br><span class="line">console.log(obj) &#x2F;&#x2F; &#123;&quot;username&quot;:&quot;kb&quot;&#125;</span><br><span class="line">console.log(typeof obj) &#x2F;&#x2F; string</span><br><span class="line"></span><br><span class="line">obj &#x3D; JSON.parse(obj) &#x2F;&#x2F; 转换成JS对象</span><br><span class="line">console.log(obj) &#x2F;&#x2F; &#123;username: &quot;kb&quot;&#125;</span><br><span class="line">console.log(typeof obj) &#x2F;&#x2F; object</span><br></pre></td></tr></table></figure>
<h3 id="1-3-Object-对象方法扩展"><a href="#1-3-Object-对象方法扩展" class="headerlink" title="1.3 Object 对象方法扩展"></a>1.3 Object 对象方法扩展</h3><p>ES5 给 Object 扩展了一些静态方法，常用的2个：</p>
<h4 id="object-create-prototype-descriptors"><a href="#object-create-prototype-descriptors" class="headerlink" title="object.create(prototype, [descriptors])"></a>object.create(prototype, [descriptors])</h4><p>作用：以指定对象为原型创建新的对象</p>
<p>为新的对象指定新的属性，并对实行进行描述</p>
<ul>
<li>value：指定值</li>
<li>writable：标识当前属性值是否可修改，默认为false</li>
<li>configurable：标识当前属性是否可以被删除，默认为false</li>
<li>enumerable：标识当前属性是否能用for in 枚举，默认为false</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;username: &#39;dm&#39;, age: 30&#125;;</span><br><span class="line">var obj1 &#x3D; &#123;&#125;;</span><br><span class="line">obj1 &#x3D; Object.create(obj, &#123;</span><br><span class="line">  sex: &#123; &#x2F;&#x2F; 扩展的新属性</span><br><span class="line">    value: &#39;male&#39;,</span><br><span class="line">    writable: true, &#x2F;&#x2F; 只有指定writable为true才能修改sex的值</span><br><span class="line">    configurable: true, &#x2F;&#x2F; 只有指定configurable为true才能删除sex的值</span><br><span class="line">    enumerable: true &#x2F;&#x2F; 只有指定enumerable为true才能枚举sex的值</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line">console.log(obj1.age); &#x2F;&#x2F; 30</span><br><span class="line">console.log(obj1);</span><br><span class="line">&#x2F;*</span><br><span class="line">  sex: &quot;male&quot;</span><br><span class="line"> &gt;__proto__:</span><br><span class="line">    age: 30</span><br><span class="line">    username: &quot;dm&quot;</span><br><span class="line">*&#x2F;</span><br><span class="line">console.log(obj1.sex); &#x2F;&#x2F; male</span><br><span class="line">obj1.sex &#x3D; &#39;female&#39;;</span><br><span class="line">console.log(obj1.sex); &#x2F;&#x2F; female</span><br><span class="line">&#x2F;&#x2F;delete obj1.sex;</span><br><span class="line">&#x2F;&#x2F;console.log(obj1.sex); &#x2F;&#x2F; undefined</span><br><span class="line">for(var i in obj1) &#123;</span><br><span class="line">  console.log(i) &#x2F;&#x2F; sex也能打印出来</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Object-defineProperties-object-descriptors"><a href="#Object-defineProperties-object-descriptors" class="headerlink" title="Object.defineProperties(object, descriptors)"></a>Object.defineProperties(object, descriptors)</h4><p>作用：为指定对象定义扩展多个属性</p>
<p>get：用来获取当前<strong>属性值</strong>的回调函数</p>
<p>set：监听当前<strong>属性值</strong>的回调函数(属性值发生变化会自动调用)，调用后会将修改后的值作为实参注入到 set 函数</p>
<p>存取器属性：setter，getter 一个用来存值，一个用来取值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj2 &#x3D; &#123;firstName: &#39;kb&#39;, lastName: &#39;brt&#39;&#125;;</span><br><span class="line">Object.defineProperties(obj2, &#123;</span><br><span class="line">  fullName: &#123;</span><br><span class="line">    get: function() &#123; &#x2F;&#x2F; 获取当前扩展属性的值的回调函数，每次获取属性值时get方法自动调用</span><br><span class="line">      console.log(&#39;get()&#39;);</span><br><span class="line">      return this.firstName + &#39; &#39; + this.lastName;</span><br><span class="line">    &#125;,</span><br><span class="line">    set: function(data) &#123; &#x2F;&#x2F; 监听当前扩展属性，只有当他发生变化时才自动调用(data就是想要修改成的值)</span><br><span class="line">      console.log(&#39;set()&#39;, data) &#x2F;&#x2F; set() tim dc</span><br><span class="line">      var names &#x3D; data.split(&#39; &#39;); &#x2F;&#x2F; 不能直接改变fullName的值但是可以通过这种方式间接改变</span><br><span class="line">      this.firstName &#x3D; names[0];</span><br><span class="line">      this.lastName &#x3D; names[1];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(obj2.fullName)</span><br><span class="line">obj2.fullName &#x3D; &#39;tim dc&#39; &#x2F;&#x2F; 修改fullName属性的值</span><br><span class="line">console.log(obj2.fullName)</span><br><span class="line">&#x2F;&#x2F; get()</span><br><span class="line">&#x2F;&#x2F; kb ret</span><br><span class="line">&#x2F;&#x2F; set(), tim dc</span><br><span class="line">&#x2F;&#x2F; get()</span><br><span class="line">&#x2F;&#x2F; tim dc</span><br></pre></td></tr></table></figure>
<h4 id="对象本身的两个方法"><a href="#对象本身的两个方法" class="headerlink" title="对象本身的两个方法"></a>对象本身的两个方法</h4><p>get propertyName() {}：用来得到当前属性值的回调函数</p>
<p>set propertyName() {} ：用来监听当前属性值变化的回调函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;</span><br><span class="line">  firstName: &#39;cr&#39;,</span><br><span class="line">  lastName: &#39;stp&#39;,</span><br><span class="line">  get fullName() &#123;</span><br><span class="line">    return this.firstName + &#39; &#39; + this.lastName;</span><br><span class="line">  &#125;,</span><br><span class="line">  set fullName(data) &#123;</span><br><span class="line">    var names &#x3D; data.split(&#39; &#39;);</span><br><span class="line">    this.firstName &#x3D; names[0];</span><br><span class="line">    this.lastName &#x3D; names[1];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(obj);</span><br><span class="line">obj.fullName &#x3D; &#39;kb brt&#39;;</span><br><span class="line">console.log(obj.fullName);</span><br></pre></td></tr></table></figure>
<p><strong>这两种写法不同但是结果是完全相同的。</strong></p>
<h3 id="1-4-Array-扩展"><a href="#1-4-Array-扩展" class="headerlink" title="1.4 Array 扩展"></a>1.4 Array 扩展</h3><p>Array.prototype.indexOf(value)：得到值在数组中的第一个下标</p>
<p>Array.prototype.lastIndexOf(value)：得到值在数组中的最后一个下标</p>
<p>Array.prototype.forEach(function(item, index) {})：遍历数组</p>
<p>Array.prototype.map(function(item, index) {})：遍历数组返回一个新的数组，返回加工之后的值</p>
<p>Array.prototype.filter(function(item, index) {})：遍历过滤出一个新的子数组，返回条件为true的值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 输出第一个6的下标</span><br><span class="line">&#x2F;&#x2F; 输出最后一个6的下标</span><br><span class="line">&#x2F;&#x2F; 输出所有元素的值和下标</span><br><span class="line">&#x2F;&#x2F; 根据arr产生一个新数组，要求每个元素都比原来大10</span><br><span class="line">&#x2F;&#x2F; 根据arr产生一个新数组，返回的每个元素要大于4</span><br><span class="line">var arr &#x3D; [5,7,6,4,5,1,6,2,3,8]</span><br><span class="line">console.log(arr.indexOf(6))</span><br><span class="line">console.log(arr.lastIndexOf(6))</span><br><span class="line">arr.forEach((item, index) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(item, index)</span><br><span class="line">&#125;)</span><br><span class="line">var arr1 &#x3D; arr.map(item &#x3D;&gt; &#123;</span><br><span class="line">  return item + 10</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr1)</span><br><span class="line">var arr2 &#x3D; arr.filter(item &#x3D;&gt; &#123;</span><br><span class="line">  return item &gt; 4</span><br><span class="line">&#125;)</span><br><span class="line">console.log(arr2)</span><br></pre></td></tr></table></figure>
<h3 id="1-5-Function-扩展——call、apply、bind用法详解"><a href="#1-5-Function-扩展——call、apply、bind用法详解" class="headerlink" title="1.5 Function 扩展——call、apply、bind用法详解"></a>1.5 Function 扩展——call、apply、bind用法详解</h3><p>Function.prototype.bind(obj)：将函数内的 this 绑定为 obj，并将函数返回</p>
<p>区别 bind()、call() 和 apply()：</p>
<p> 都能指定函数中的 this</p>
<p> call()/apply() 是立即调用函数，bind() 是将函数返回</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;username: &#39;wy&#39;&#125;;</span><br><span class="line">function foo() &#123;</span><br><span class="line">    console.log(this)</span><br><span class="line">&#125;</span><br><span class="line">foo() &#x2F;&#x2F; window</span><br><span class="line">foo.call(obj) &#x2F;&#x2F; &#123;username: &quot;wy&quot;&#125;</span><br><span class="line">foo.apply(obj) &#x2F;&#x2F; &#123;username: &quot;wy&quot;&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>不传参时，call 和 apply 的用法相同。</p>
</blockquote>
<p>传入参数的形式不同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;username: &#39;wy&#39;&#125;;</span><br><span class="line">function foo(data) &#123;</span><br><span class="line">    console.log(this, data)</span><br><span class="line">&#125;</span><br><span class="line">foo.call(obj, 33) &#x2F;&#x2F; &#123;username: &quot;wy&quot;&#125; 33</span><br><span class="line">foo.apply(obj, [33]) &#x2F;&#x2F; &#123;username: &quot;wy&quot;&#125; 33</span><br></pre></td></tr></table></figure>
<blockquote>
<p>call：直接从第二个参数开始，依次传入</p>
<p>apply：第二参数必须是数组，传入值放在数组里</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;username: &#39;wy&#39;&#125;</span><br><span class="line">function foo(data) &#123;</span><br><span class="line">    console.log(this, data)</span><br><span class="line">&#125;</span><br><span class="line">foo.bind(obj, 33) &#x2F;&#x2F; 没有输出</span><br><span class="line">foo.bind(obj, 33)() &#x2F;&#x2F; &#123;username: &quot;wy&quot;&#125; 33</span><br></pre></td></tr></table></figure>
<blockquote>
<p>bind 的特点：绑定完 this 不会立即调用当前的函数，而是将函数返回。</p>
<p>传参的方式和 call 一样</p>
</blockquote>
<p>什么时候用 bind：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; &#123;username: &#39;wy&#39;&#125;</span><br><span class="line">setTimeout(function() &#123;</span><br><span class="line">  console.log(this)</span><br><span class="line">&#125;.bind(obj), 1000)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue的$set</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/set/vue/11-%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84($set)/</url>
    <content><![CDATA[<h1 id="Vue里面交换数组两个元素的位置"><a href="#Vue里面交换数组两个元素的位置" class="headerlink" title="Vue里面交换数组两个元素的位置"></a>Vue里面交换数组两个元素的位置</h1><h3 id="后移"><a href="#后移" class="headerlink" title="后移"></a>后移</h3><p><code>i</code>和<code>i+1</code>.交换相当于是i后移一位</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &lt; basket.questions.length - <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tempOption = basket.questions[i + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">this</span>.$set(basket.questions, i + <span class="number">1</span>, basket.questions[i])</span><br><span class="line">    <span class="built_in">this</span>.$set(basket.questions, i, tempOption)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="前移"><a href="#前移" class="headerlink" title="前移"></a>前移</h3><p><code>i</code>和<code>i-1</code>.交换相当于是i前移一位</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tempOption = basket.questions[i - <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">this</span>.$set(basket.questions, i - <span class="number">1</span>, basket.questions[i]);</span><br><span class="line">    <span class="built_in">this</span>.$set(basket.questions, i, tempOption)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="原因-由于vue2中数据双向绑定的原理是Object-defineProperty该方法无法监听到对象新添加的属性以及数组通过下标操作-但是对于数组vue重新封装了可修改原数组的pop、push、shift、unshift、splice、sort、reverse方法所以需要对数组进行操作时可使用以上方法或使用this-set-Vue-set-该方法传入三个参数参数一是需要操作的对象或数组-参数二是需要操作的对象属性名或数组下标-参数三是需要修改的值"><a href="#原因-由于vue2中数据双向绑定的原理是Object-defineProperty该方法无法监听到对象新添加的属性以及数组通过下标操作-但是对于数组vue重新封装了可修改原数组的pop、push、shift、unshift、splice、sort、reverse方法所以需要对数组进行操作时可使用以上方法或使用this-set-Vue-set-该方法传入三个参数参数一是需要操作的对象或数组-参数二是需要操作的对象属性名或数组下标-参数三是需要修改的值" class="headerlink" title="原因:由于vue2中数据双向绑定的原理是Object.defineProperty该方法无法监听到对象新添加的属性以及数组通过下标操作,但是对于数组vue重新封装了可修改原数组的pop、push、shift、unshift、splice、sort、reverse方法所以需要对数组进行操作时可使用以上方法或使用this.$set(Vue.set)该方法传入三个参数参数一是需要操作的对象或数组,参数二是需要操作的对象属性名或数组下标,参数三是需要修改的值"></a>原因:由于vue2中数据双向绑定的原理是Object.defineProperty该方法无法监听到对象新添加的属性以及数组通过下标操作,但是对于数组vue重新封装了可修改原数组的pop、push、shift、unshift、splice、sort、reverse方法所以需要对数组进行操作时可使用以上方法或使用this.$set(Vue.set)该方法传入三个参数参数一是需要操作的对象或数组,参数二是需要操作的对象属性名或数组下标,参数三是需要修改的值</h3>]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
        <category>$set</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>回调函数-Promise</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/13.%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0-Promise/</url>
    <content><![CDATA[<h2 id="一、准备"><a href="#一、准备" class="headerlink" title="一、准备"></a>一、准备</h2><h3 id="1-1-区别实例对象与函数对象"><a href="#1-1-区别实例对象与函数对象" class="headerlink" title="1.1 区别实例对象与函数对象"></a>1.1 区别实例对象与函数对象</h3><ol>
<li>实例对象：new 函数产生的对象，称为实例对象，简称为对象</li>
<li>函数对象：将函数作为对象使用时，称为函数对象</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function Fn() &#123; &#x2F;&#x2F; Fn只能称为函数</span><br><span class="line">&#125;</span><br><span class="line">const fn &#x3D; new Fn() &#x2F;&#x2F; Fn只有new过的才可以称为构造函数</span><br><span class="line">&#x2F;&#x2F;fn称为实例对象</span><br><span class="line">console.log(Fn.prototype)&#x2F;&#x2F; Fn作为对象使用时，才可以称为函数对象</span><br><span class="line">Fn.bind(&#123;&#125;) &#x2F;&#x2F;Fn作为函数对象使用</span><br><span class="line">$(&#39;#test&#39;) &#x2F;&#x2F; $作为函数使用</span><br><span class="line">$.get(&#39;&#x2F;test&#39;) &#x2F;&#x2F; $作为函数对象使用</span><br></pre></td></tr></table></figure>
<blockquote>
<p>()的左边必然是函数，点的左边必然是对象</p>
</blockquote>
<a id="more"></a>

<h3 id="1-2-回调函数"><a href="#1-2-回调函数" class="headerlink" title="1.2 回调函数"></a>1.2 回调函数</h3><h4 id="同步回调"><a href="#同步回调" class="headerlink" title="同步回调"></a>同步回调</h4><p>定义：立即执行，完全执行完了才结束，不会放入回调队列中</p>
<p>举例：数组遍历相关的回调 / Promise的excutor函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [1, 3, 5];</span><br><span class="line">arr.forEach(item &#x3D;&gt; &#123; &#x2F;&#x2F; 遍历回调，同步回调，不会放入队列，一上来就要执行</span><br><span class="line">  console.log(item);</span><br><span class="line">&#125;)</span><br><span class="line">console.log(&#39;forEach()之后&#39;)</span><br><span class="line">&#x2F;&#x2F; 1</span><br><span class="line">&#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; 5</span><br><span class="line">&#x2F;&#x2F; &quot;forEach()之后&quot;</span><br></pre></td></tr></table></figure>
<h4 id="异步回调"><a href="#异步回调" class="headerlink" title="异步回调"></a>异步回调</h4><p>定义：不会立即执行，会放入回调队列中将来执行</p>
<p>举例：定时器回调 / ajax回调 / Promise成功或失败的回调</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 定时器回调</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 异步回调，会放入队列中将来执行</span><br><span class="line">  console.log(&#39;timeout callback()&#39;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">console.log(&#39;setTimeout()之后&#39;)</span><br><span class="line">&#x2F;&#x2F; “setTimeout()之后”</span><br><span class="line">&#x2F;&#x2F; “timeout callback()”</span><br><span class="line">&#x2F;&#x2F; Promise 成功或失败的回调</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)</span><br><span class="line">&#125;).then(</span><br><span class="line">  value &#x3D;&gt; &#123;console.log(&#39;value&#39;, value)&#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;console.log(&#39;reason&#39;, reason)&#125;</span><br><span class="line">)</span><br><span class="line">console.log(&#39;----&#39;)</span><br><span class="line">&#x2F;&#x2F; ----</span><br><span class="line">&#x2F;&#x2F; value 1</span><br></pre></td></tr></table></figure>
<p><strong>js 引擎是先把初始化的同步代码都执行完成后，才执行回调队列中的代码</strong></p>
<h3 id="1-3-JS-的-error-处理"><a href="#1-3-JS-的-error-处理" class="headerlink" title="1.3 JS 的 error 处理"></a>1.3 JS 的 error 处理</h3><h4 id="错误的类型"><a href="#错误的类型" class="headerlink" title="错误的类型"></a>错误的类型</h4><p>Error：所有错误的父类型</p>
<p>ReferenceError：引用的变量不存在</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(a) &#x2F;&#x2F; ReferenceError:a is not defined</span><br></pre></td></tr></table></figure>
<p>TypeError：数据类型不正确</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let b</span><br><span class="line">console.log(b.xxx)</span><br><span class="line">&#x2F;&#x2F; TypeError:Cannot read property &#39;xxx&#39; of undefined</span><br><span class="line">let b &#x3D; &#123;&#125;</span><br><span class="line">b.xxx()</span><br><span class="line">&#x2F;&#x2F; TypeError:b.xxx is not a function</span><br></pre></td></tr></table></figure>
<p>RangeError：数据值不在其所允许的范围内</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn() &#123;</span><br><span class="line">  fn()</span><br><span class="line">&#125;</span><br><span class="line">fn()</span><br><span class="line">&#x2F;&#x2F; RangeError:Maximum call stack size exceeded</span><br></pre></td></tr></table></figure>
<p>SyntaxError：语法错误</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const c &#x3D; &quot;&quot;&quot;&quot;</span><br><span class="line">&#x2F;&#x2F; SyntaxError:Unexpected string</span><br></pre></td></tr></table></figure>
<h4 id="错误处理"><a href="#错误处理" class="headerlink" title="错误处理"></a>错误处理</h4><p>捕获错误：try … catch</p>
<p>抛出错误：throw error</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function something() &#123;</span><br><span class="line">  if (Date.now()%2&#x3D;&#x3D;&#x3D;1) &#123;</span><br><span class="line">    console.log(&#39;当前时间为奇数，可以执行任务&#39;)</span><br><span class="line">  &#125; else &#123; &#x2F;&#x2F;如果时间为偶数抛出异常，由调用来处理</span><br><span class="line">    throw new Error(&#39;当前时间为偶数，无法执行任务&#39;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 捕获处理异常</span><br><span class="line">try &#123;</span><br><span class="line">  something()</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  alert(error.message)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="错误对象"><a href="#错误对象" class="headerlink" title="错误对象"></a>错误对象</h4><p>massage 属性：错误相关信息</p>
<p>stack 属性：函数调用栈记录信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">  let d</span><br><span class="line">  console.log(d.xxx)</span><br><span class="line">&#125; catch (error) &#123;</span><br><span class="line">  console.log(error.message)</span><br><span class="line">  console.log(error.stack)</span><br><span class="line">&#125;</span><br><span class="line">console.log(&#39;出错之后&#39;)</span><br><span class="line">&#x2F;&#x2F; Cannot read property &#39;xxx&#39; of undefined</span><br><span class="line">&#x2F;&#x2F; TypeError:Cannot read property &#39;xxx&#39; of undefined</span><br><span class="line">&#x2F;&#x2F; 出错之后</span><br></pre></td></tr></table></figure>
<blockquote>
<p>因为错误被捕获处理了，后面的代码才能运行下去，打印出‘出错之后’</p>
</blockquote>
<h2 id="二、Promise-的理解和使用"><a href="#二、Promise-的理解和使用" class="headerlink" title="二、Promise 的理解和使用"></a>二、Promise 的理解和使用</h2><h3 id="2-1-Promise-是什么"><a href="#2-1-Promise-是什么" class="headerlink" title="2.1 Promise 是什么"></a>2.1 Promise 是什么</h3><h4 id="2-1-1-Promise-的理解"><a href="#2-1-1-Promise-的理解" class="headerlink" title="2.1.1 Promise 的理解"></a>2.1.1 Promise 的理解</h4><p>抽象表达：Promise 是 JS 中进行异步编程的新的解决方案</p>
<p>具体表达：</p>
<ol>
<li>语法上：Promise 是一个构造函数</li>
<li>功能上：Promise 对象用来封装一个异步操作并可以获取其结果</li>
</ol>
<h4 id="2-1-2-Promise-的状态改变"><a href="#2-1-2-Promise-的状态改变" class="headerlink" title="2.1.2 Promise 的状态改变"></a>2.1.2 Promise 的状态改变</h4><ol>
<li>pending 变为 resolved</li>
<li>pending 变为 rejected</li>
</ol>
<p>只有这两种，且一个 promise 对象只能改变一次。无论成功还是失败，都会有一个结果数据。成功的结果数据一般称为 value，而失败的一般称为 reason。</p>
<h4 id="2-1-3-Promise-的基本流程"><a href="#2-1-3-Promise-的基本流程" class="headerlink" title="2.1.3 Promise 的基本流程"></a>2.1.3 Promise 的基本流程</h4><p><img src="https://img-blog.csdnimg.cn/20200703144207912.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70" alt="img"></p>
<h4 id="2-1-4-Promise-的基本使用"><a href="#2-1-4-Promise-的基本使用" class="headerlink" title="2.1.4 Promise 的基本使用"></a>2.1.4 Promise 的基本使用</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建一个新的p对象promise</span><br><span class="line">const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123; &#x2F;&#x2F; 执行器函数</span><br><span class="line">  &#x2F;&#x2F; 执行异步操作任务</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    const time &#x3D; Date.now() </span><br><span class="line">    &#x2F;&#x2F; 如果当前时间是偶数代表成功，否则失败</span><br><span class="line">    if (time % 2 &#x3D;&#x3D; 0) &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果成功，调用resolve(value)</span><br><span class="line">      resolve(&#39;成功的数据，time&#x3D;&#39; + time)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      &#x2F;&#x2F; 如果失败，调用reject(reason)</span><br><span class="line">      reject(&#39;失败的数据，time&#x3D;&#39; + time)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, 1000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">p.then(</span><br><span class="line">  value &#x3D;&gt; &#123; &#x2F;&#x2F; 接收得到成功的value数据 onResolved</span><br><span class="line">    console.log(&#39;成功的回调&#39;, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123; &#x2F;&#x2F; 接收得到失败的reason数据 onRejected</span><br><span class="line">    console.log(&#39;失败的回调&#39;, reason)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>.then() 和执行器(excutor)同步执行，.then() 中的回调函数异步执行</p>
<h3 id="2-2-为什么要用-Promise"><a href="#2-2-为什么要用-Promise" class="headerlink" title="2.2 为什么要用 Promise"></a>2.2 为什么要用 Promise</h3><h4 id="1-指定回调函数的方式更加灵活"><a href="#1-指定回调函数的方式更加灵活" class="headerlink" title="1.指定回调函数的方式更加灵活"></a>1.指定回调函数的方式更加灵活</h4><p>旧的：必须在启动异步任务前指定</p>
<p>promise：启动异步任务 =&gt; 返回promise对象 =&gt; 给promise对象绑定回调函数(甚至可以在异步任务结束后指定)</p>
<h4 id="2-支持链式调用，可以解决回调地狱问题"><a href="#2-支持链式调用，可以解决回调地狱问题" class="headerlink" title="2.支持链式调用，可以解决回调地狱问题"></a>2.支持链式调用，可以解决回调地狱问题</h4><h5 id="什么是回调地狱？"><a href="#什么是回调地狱？" class="headerlink" title="什么是回调地狱？"></a>什么是回调地狱？</h5><p>回调函数嵌套调用，<strong>外部回调函数</strong>异步执行的结果是其<strong>内部嵌套的回调函数</strong>执行的条件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doSomething(function(result) &#123;</span><br><span class="line">  doSomethingElse(result, function(newResult) &#123;</span><br><span class="line">    doThirdThing(newResult, function(finalResult) &#123;</span><br><span class="line">      console.log(&#39;Got the final result:&#39; + finalResult)</span><br><span class="line">    &#125;, failureCallback)</span><br><span class="line">  &#125;, failureCallback)</span><br><span class="line">&#125;, failureCallback)</span><br></pre></td></tr></table></figure>
<h5 id="回调地狱的缺点？"><a href="#回调地狱的缺点？" class="headerlink" title="回调地狱的缺点？"></a>回调地狱的缺点？</h5><p>不便于阅读 / 不便于异常处理</p>
<h5 id="解决方案？"><a href="#解决方案？" class="headerlink" title="解决方案？"></a>解决方案？</h5><p>promise 链式调用</p>
<h5 id="终极解决方案？"><a href="#终极解决方案？" class="headerlink" title="终极解决方案？"></a>终极解决方案？</h5><p>async/await</p>
<h5 id="使用-promise-的链式调用解决回调地狱"><a href="#使用-promise-的链式调用解决回调地狱" class="headerlink" title="使用 promise 的链式调用解决回调地狱"></a>使用 promise 的链式调用解决回调地狱</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">doSomething()</span><br><span class="line">  .then(result &#x3D;&gt; doSomethingElse(result))</span><br><span class="line">  .then(newResult &#x3D;&gt; doThirdThing(newResult))</span><br><span class="line">  .then(finalResult &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&#39;Got the final result:&#39; + finalResult)</span><br><span class="line">&#125;)</span><br><span class="line">  .catch(failureCallback)</span><br></pre></td></tr></table></figure>
<p>回调地狱的终极解决方案 async/await</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function request() &#123;</span><br><span class="line">  try&#123;</span><br><span class="line">    const result &#x3D; await doSomething()</span><br><span class="line">    const newResult &#x3D; await doSomethingElse(result)</span><br><span class="line">    const finalResult &#x3D; await doThirdThing(newResult)</span><br><span class="line">    console.log(&#39;Got the final result:&#39; + finalResult)</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    failureCallback(error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-3-如何使用-Promise"><a href="#2-3-如何使用-Promise" class="headerlink" title="2.3 如何使用 Promise"></a>2.3 如何使用 Promise</h3><h4 id="API"><a href="#API" class="headerlink" title="API"></a>API</h4><ol>
<li><p>Promise 构造函数：Promise(excutor) {}</p>
<p>excutor 函数：同步执行 (resolve, reject) =&gt; {}</p>
<p>resolve 函数：内部定义成功时调用的函数 resove(value)</p>
<p>reject 函数：内部定义失败时调用的函数 reject(reason)</p>
<p>说明：excutor 是执行器，会在 Promise 内部立即同步回调，异步操作 <code>resolve/reject</code> 就在 excutor 中执行</p>
</li>
<li><p>Promise.prototype.then 方法：p.then(onResolved, onRejected)</p>
<p>1）onResolved 函数：成功的回调函数 (value) =&gt; {}</p>
<p>2）onRejected 函数：失败的回调函数 (reason) =&gt; {}</p>
<p>说明：指定用于得到成功 value 的成功回调和用于得到失败 reason 的失败回调，返回一个新的 promise 对象</p>
</li>
<li><p>Promise.prototype.catch 方法：p.catch(onRejected)</p>
<p>1）onRejected 函数：失败的回调函数 (reason) =&gt; {}</p>
<p>说明：<strong>then() 的语法糖</strong>，相当于 then(undefined, onRejected)</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123; &#x2F;&#x2F; excutor执行器函数</span><br><span class="line"> setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">   if(...) &#123;</span><br><span class="line">     resolve(&#39;成功的数据&#39;) &#x2F;&#x2F; resolve()函数</span><br><span class="line">   &#125; else &#123; </span><br><span class="line">     reject(&#39;失败的数据&#39;) &#x2F;&#x2F;reject()函数</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;, 1000)</span><br><span class="line">&#125;).then(</span><br><span class="line"> value &#x3D;&gt; &#123; &#x2F;&#x2F; onResolved()函数</span><br><span class="line">  console.log(value)</span><br><span class="line">&#125;</span><br><span class="line">).catch(</span><br><span class="line"> reason &#x3D;&gt; &#123; &#x2F;&#x2F; onRejected()函数</span><br><span class="line">  console.log(reason)</span><br><span class="line">&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Promise.resolve 方法：Promise.resolve(value)</p>
<p>value：将被 <code>Promise</code> 对象解析的参数，也可以是一个成功或失败的 <code>Promise</code> 对象</p>
<p>返回：返回一个带着给定值解析过的 <code>Promise</code> 对象，如果参数本身就是一个 <code>Promise</code> 对象，则直接返回这个 <code>Promise</code> 对象。</p>
</li>
<li><p>Promise.reject 方法：Promise.resolve(reason)</p>
<p>reason：失败的原因</p>
<p>说明：返回一个失败的 promise 对象</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;产生一个成功值为1的promise对象</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line"> resolve(1)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F;相当于</span><br><span class="line">const p1 &#x3D; Promise.resolve(1)</span><br><span class="line">const p2 &#x3D; Promise.resolve(2)</span><br><span class="line">const p3 &#x3D; Promise.reject(3)</span><br><span class="line"></span><br><span class="line">p1.then(value &#x3D;&gt; &#123;console.log(value)&#125;) &#x2F;&#x2F; 1</span><br><span class="line">p2.then(value &#x3D;&gt; &#123;console.log(value)&#125;) &#x2F;&#x2F; 2</span><br><span class="line">p3.catch(reason &#x3D;&gt; &#123;console.log(reason)&#125;) &#x2F;&#x2F; 3</span><br></pre></td></tr></table></figure>
<p><code>Promise.resolve()/Promise.reject()</code> 方法就是一个<strong>语法糖</strong></p>
<ol>
<li><p>Promise.all 方法：Promise.all(iterable)</p>
<p>iterable：包含 n 个 promise 的可迭代对象，如 <code>Array</code> 或 <code>String</code></p>
<p>说明：返回一个新的 promise，只有所有的 promise 都成功才成功，只要有一个失败了就直接失败</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const pAll &#x3D; Promise.all([p1, p2, p3])</span><br><span class="line">const pAll2 &#x3D; Promise.all([p1, p2])</span><br><span class="line">&#x2F;&#x2F;因为其中p3是失败所以pAll失败</span><br><span class="line">pAll.then(</span><br><span class="line">value &#x3D;&gt; &#123;</span><br><span class="line">   console.log(&#39;all onResolved()&#39;, value)</span><br><span class="line"> &#125;,</span><br><span class="line">reason &#x3D;&gt; &#123;</span><br><span class="line">   console.log(&#39;all onRejected()&#39;, reason) </span><br><span class="line"> &#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; all onRejected() 3</span><br><span class="line">pAll2.then(</span><br><span class="line">values &#x3D;&gt; &#123;</span><br><span class="line">   console.log(&#39;all onResolved()&#39;, values)</span><br><span class="line"> &#125;,</span><br><span class="line">reason &#x3D;&gt; &#123;</span><br><span class="line">   console.log(&#39;all onRejected()&#39;, reason) </span><br><span class="line"> &#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; all onResolved() [1, 2]</span><br></pre></td></tr></table></figure>
<ol>
<li><p>Promise.race方法：Promise.race(iterable)</p>
<p>iterable：包含 n 个 promise 的可迭代对象，如 <code>Array</code> 或 <code>String</code></p>
<p>说明：返回一个新的 promise，第一个完成的 promise 的结果状态就是最终的结果状态</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const pRace &#x3D; Promise.race([p1, p2, p3])</span><br><span class="line">&#x2F;&#x2F; 谁先完成就输出谁(不管是成功还是失败)</span><br><span class="line">const p1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line"> setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">   resolve(1)</span><br><span class="line"> &#125;, 1000)</span><br><span class="line">&#125;)</span><br><span class="line">const p2 &#x3D; Promise.resolve(2)</span><br><span class="line">const p3 &#x3D; Promise.reject(3)</span><br><span class="line"></span><br><span class="line">pRace.then(</span><br><span class="line">value &#x3D;&gt; &#123;</span><br><span class="line">   console.log(&#39;race onResolved()&#39;, value)</span><br><span class="line"> &#125;,</span><br><span class="line">reason &#x3D;&gt; &#123;</span><br><span class="line">   console.log(&#39;race onRejected()&#39;, reason) </span><br><span class="line"> &#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F;race onResolved() 2</span><br></pre></td></tr></table></figure>
<h4 id="Promise-的几个关键问题"><a href="#Promise-的几个关键问题" class="headerlink" title="Promise 的几个关键问题"></a>Promise 的几个关键问题</h4><h5 id="1-如何改变-promise-的状态？"><a href="#1-如何改变-promise-的状态？" class="headerlink" title="1.如何改变 promise 的状态？"></a>1.如何改变 promise 的状态？</h5><p>(1)resolve(value)：如果当前是 pending 就会变为 resolved</p>
<p>(2)reject(reason)：如果当前是 pending 就会变为 rejected</p>
<p>(3)抛出异常：如果当前是 pending 就会变为 rejected</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;resolve(1) &#x2F;&#x2F; promise变为resolved成功状态</span><br><span class="line">  &#x2F;&#x2F;reject(2) &#x2F;&#x2F; promise变为rejected失败状态</span><br><span class="line">  throw new Error(&#39;出错了&#39;) &#x2F;&#x2F; 抛出异常，promise变为rejected失败状态，reason为抛出的error</span><br><span class="line">&#125;)</span><br><span class="line">p.then(</span><br><span class="line">  value &#x3D;&gt; &#123;&#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;console.log(&#39;reason&#39;,reason)&#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; reason Error:出错了</span><br></pre></td></tr></table></figure>
<h5 id="2-一个-promise-指定多个成功-失败回调函数，都会调用吗？"><a href="#2-一个-promise-指定多个成功-失败回调函数，都会调用吗？" class="headerlink" title="2.一个 promise 指定多个成功/失败回调函数，都会调用吗？"></a>2.一个 promise 指定多个成功/失败回调函数，都会调用吗？</h5><p>当 promise 改变为对应状态时都会调用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  &#x2F;&#x2F;resolve(1)</span><br><span class="line">  reject(2)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(</span><br><span class="line">  value &#x3D;&gt; &#123;&#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;console.log(&#39;reason&#39;,reason)&#125;</span><br><span class="line">)</span><br><span class="line">p.then(</span><br><span class="line">  value &#x3D;&gt; &#123;&#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;console.log(&#39;reason2&#39;,reason)&#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; reason 2</span><br><span class="line">&#x2F;&#x2F; reason2 2</span><br></pre></td></tr></table></figure>
<h5 id="3-改变-promise-状态和指定回调函数谁先谁后？"><a href="#3-改变-promise-状态和指定回调函数谁先谁后？" class="headerlink" title="3.改变 promise 状态和指定回调函数谁先谁后？"></a>3.改变 promise 状态和指定回调函数谁先谁后？</h5><ol>
<li><p>都有可能，常规是先指定回调再改变状态，但也可以先改状态再指定回调</p>
</li>
<li><p>如何先改状态再指定回调？</p>
<p>(1)在执行器中直接调用 resolve()/reject()</p>
<p>(2)延迟更长时间才调用 then()</p>
</li>
<li><p>什么时候才能得到数据？</p>
<p>(1)如果先指定的回调，那当状态发生改变时，回调函数就会调用得到数据</p>
<p>(2)如果先改变的状态，那当指定回调时，回调函数就会调用得到数据</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(1) &#x2F;&#x2F; 改变状态</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;).then( &#x2F;&#x2F; 指定回调函数</span><br><span class="line">  value &#x3D;&gt; &#123;&#125;,</span><br><span class="line">  reason &#x3D;&gt;&#123;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>此时，先指定回调函数，保存当前指定的回调函数；后改变状态(同时指定数据)，然后异步执行之前保存的回调函数。</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1) &#x2F;&#x2F; 改变状态</span><br><span class="line">&#125;).then( &#x2F;&#x2F; 指定回调函数</span><br><span class="line">  value &#x3D;&gt; &#123;&#125;,</span><br><span class="line">  reason &#x3D;&gt;&#123;&#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p><strong>这种写法，先改变的状态(同时指定数据)，后指定回调函数(不需要再保存)，直接异步执行回调函数</strong></p>
<h5 id="4-promise-then-返回的新-promise-的结果状态由什么决定？"><a href="#4-promise-then-返回的新-promise-的结果状态由什么决定？" class="headerlink" title="4.promise.then() 返回的新 promise 的结果状态由什么决定？"></a>4.promise.then() 返回的新 promise 的结果状态由什么决定？</h5><p>(1)简单表达：由 then() 指定的回调函数执行的结果决定</p>
<p>(2)详细表达：</p>
<p> ① 如果抛出异常，新 promise 变为 rejected，reason 为抛出的异常</p>
<p> ② 如果返回的是非 promise 的任意值，新 promise 变为 resolved，value 为返回的值</p>
<p> ③ 如果返回的是另一个新 promise，此 promise 的结果就会成为新 promise 的结果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)</span><br><span class="line">&#125;).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved1()&#39;, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected1()&#39;, reason)</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved2()&#39;, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected2()&#39;, reason)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; onResolved1() 1</span><br><span class="line">&#x2F;&#x2F; onResolved2() undefined</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  resolve(1)</span><br><span class="line">&#125;).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved1()&#39;, value)</span><br><span class="line">    &#x2F;&#x2F;return 2                   &#x2F;&#x2F; onResolved2() 2</span><br><span class="line">    &#x2F;&#x2F;return Promise.resolve(3)  &#x2F;&#x2F; onResolved2() 3</span><br><span class="line">    &#x2F;&#x2F;return Promise.reject(4)   &#x2F;&#x2F; onRejected2() 4</span><br><span class="line">    &#x2F;&#x2F;throw 5                    &#x2F;&#x2F; onRejected2() 5</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected1()&#39;, reason)</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved2()&#39;, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected2()&#39;, reason)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; onResolved1() 1</span><br><span class="line">&#x2F;&#x2F; 对应输出如上所示</span><br></pre></td></tr></table></figure>
<h5 id="5-promise-如何串联多个操作任务？"><a href="#5-promise-如何串联多个操作任务？" class="headerlink" title="5.promise 如何串联多个操作任务？"></a>5.promise 如何串联多个操作任务？</h5><p>(1)promise 的 then() 返回一个新的 promise，可以并成 then() 的链式调用</p>
<p>(2)通过 then 的链式调用串联多个同步/异步任务</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;执行任务1(异步)&#39;)</span><br><span class="line">    resolve(1)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">&#125;).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;任务1的结果&#39;, value)</span><br><span class="line">    console.log(&#39;执行任务2(同步)&#39;)</span><br><span class="line">    return 2 &#x2F;&#x2F; 同步任务直接return返回结果</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;任务2的结果&#39;, value)</span><br><span class="line">    return new Promise((resolve, reject) &#x3D;&gt; &#123; &#x2F;&#x2F; 异步任务需要包裹在Promise对象中</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;执行任务3(异步)&#39;)</span><br><span class="line">        resolve(3)</span><br><span class="line">      &#125;, 1000)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;任务3的结果&#39;, value)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; 执行任务1(异步)</span><br><span class="line">&#x2F;&#x2F; 任务1的结果 1</span><br><span class="line">&#x2F;&#x2F; 执行任务2(同步)</span><br><span class="line">&#x2F;&#x2F; 任务2的结果 2</span><br><span class="line">&#x2F;&#x2F; 执行任务3(异步)</span><br><span class="line">&#x2F;&#x2F; 任务3的结果 3</span><br></pre></td></tr></table></figure>
<h5 id="6-Promise-异常穿透-传透-？"><a href="#6-Promise-异常穿透-传透-？" class="headerlink" title="6.Promise 异常穿透(传透)？"></a>6.Promise 异常穿透(传透)？</h5><p>(1)当使用 promise 的 then 链式调用时，可以在最后指定失败的回调</p>
<p>(2)前面任何操作出了异常，都会传到最后失败的回调中处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">   &#x2F;&#x2F;resolve(1)</span><br><span class="line">   reject(1)</span><br><span class="line">&#125;).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved1()&#39;, value)</span><br><span class="line">    return 2</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved2()&#39;, value)</span><br><span class="line">    return 3</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved3()&#39;, value)</span><br><span class="line">  &#125;</span><br><span class="line">).catch(</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected1()&#39;, reason)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; onRejected1() 1</span><br></pre></td></tr></table></figure>
<p>相当于这种写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">   &#x2F;&#x2F;resolve(1)</span><br><span class="line">   reject(1)</span><br><span class="line">&#125;).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved1()&#39;, value)</span><br><span class="line">    return 2</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;throw reason&#125; &#x2F;&#x2F; 抛出失败的结果reason</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved2()&#39;, value)</span><br><span class="line">    return 3</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;throw reason&#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved3()&#39;, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;throw reason&#125;</span><br><span class="line">).catch(</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected1()&#39;, reason)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; onRejected1() 1</span><br></pre></td></tr></table></figure>
<p>所以失败的结果是一层一层处理下来的，最后传递到 catch 中。</p>
<p>或者，将 <code>reason =&gt; &#123;throw reason&#125;</code> 替换为 <code>reason =&gt; Promise.reject(reason)</code> 也是一样的</p>
<h5 id="7-中断-promise-链？"><a href="#7-中断-promise-链？" class="headerlink" title="7.中断 promise 链？"></a>7.中断 promise 链？</h5><p>当使用 promise 的 then 链式调用时，在中间中断，不再调用后面的回调函数</p>
<p>办法：在回调函数中返回一个 pending 状态的 promise 对象</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">   &#x2F;&#x2F;resolve(1)</span><br><span class="line">   reject(1)</span><br><span class="line">&#125;).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved1()&#39;, value)</span><br><span class="line">    return 2</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved2()&#39;, value)</span><br><span class="line">    return 3</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved3()&#39;, value)</span><br><span class="line">  &#125;</span><br><span class="line">).catch(</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected1()&#39;, reason)</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved4()&#39;, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected2()&#39;, reason)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; onRejected1() 1</span><br><span class="line">&#x2F;&#x2F; onResolved4() undefined</span><br></pre></td></tr></table></figure>
<p>为了在 catch 中就中断执行，可以这样写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">   &#x2F;&#x2F;resolve(1)</span><br><span class="line">   reject(1)</span><br><span class="line">&#125;).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved1()&#39;, value)</span><br><span class="line">    return 2</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved2()&#39;, value)</span><br><span class="line">    return 3</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved3()&#39;, value)</span><br><span class="line">  &#125;</span><br><span class="line">).catch(</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected1()&#39;, reason)</span><br><span class="line">    return new Promise(() &#x3D;&gt; &#123;&#125;) &#x2F;&#x2F; 返回一个pending的promise</span><br><span class="line">  &#125;</span><br><span class="line">).then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved4()&#39;, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected2()&#39;, reason)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; onRejected1() 1</span><br></pre></td></tr></table></figure>
<p>在 catch 中返回一个新的 promise，且这个 promise 没有结果。</p>
<p>由于，返回的新的 promise 结果决定了后面 then 中的结果，所以后面的 then 中也没有结果。</p>
<p>这就实现了中断 promise 链的效果。</p>
<h2 id="三、自定义-手写-Promise"><a href="#三、自定义-手写-Promise" class="headerlink" title="三、自定义(手写)Promise"></a>三、自定义(手写)Promise</h2><p>代码见<a href="https://github.com/Woc12138/Promise-study">Github</a></p>
<h2 id="四、async-与-await"><a href="#四、async-与-await" class="headerlink" title="四、async 与 await"></a>四、async 与 await</h2><h3 id="4-1-async-函数"><a href="#4-1-async-函数" class="headerlink" title="4.1 async 函数"></a>4.1 async 函数</h3><ol>
<li>函数的返回值为 promise 对象</li>
<li>promise 对象的结果由 async 函数执行的返回值决定</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function fn1() &#123;</span><br><span class="line">  &#x2F;&#x2F;return 1</span><br><span class="line">  &#x2F;&#x2F; 返回一个Promise对象（PromiseStatus为resolved，PromiseValue为1）</span><br><span class="line">  throw 2</span><br><span class="line">  &#x2F;&#x2F; 返回一个Promise对象（PromiseStatus为rejected，PromiseValue为2）</span><br><span class="line">&#125;</span><br><span class="line">const result &#x3D; fn1()</span><br><span class="line">console.log(result)</span><br></pre></td></tr></table></figure>
<p>这时，可以将 result.then()：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function fn1() &#123;</span><br><span class="line">  &#x2F;&#x2F;return 1</span><br><span class="line">  throw 2</span><br><span class="line">&#125;</span><br><span class="line">const result &#x3D; fn1()</span><br><span class="line">result.then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved()&#39;, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected()&#39;, reason)</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; onRejected() 2</span><br></pre></td></tr></table></figure>
<p>也可以在异步函数中返回一个 promise</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function fn1() &#123;</span><br><span class="line">  &#x2F;&#x2F;return Promise.reject(3)</span><br><span class="line">  return Promise.resolve(3)</span><br><span class="line">&#125;</span><br><span class="line">const result &#x3D; fn1()</span><br><span class="line">result.then(</span><br><span class="line">  value &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onResolved()&#39;, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected()&#39;, reason)</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; onResolved() 3</span><br></pre></td></tr></table></figure>
<p>也就是说，一旦在函数前加 async，它返回的值都将被包裹在 Promise 中，这个 Promise 的结果由函数执行的结果决定。</p>
<p>上面的栗子都是立即成功/失败的 promise，也可以返回延迟成功/失败的 promise：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function fn1() &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve(4)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">const result &#x3D; fn1()</span><br><span class="line">result.then(</span><br><span class="line">  value &#x3D;&gt; &#123; &#x2F;&#x2F; 过1s后才异步执行回调函数 onResolved()</span><br><span class="line">    console.log(&#39;onResolved()&#39;, value)</span><br><span class="line">  &#125;,</span><br><span class="line">  reason &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&#39;onRejected()&#39;, reason)</span><br><span class="line">  &#125;,</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; onResolved() 4</span><br></pre></td></tr></table></figure>
<h3 id="4-2-await-表达式"><a href="#4-2-await-表达式" class="headerlink" title="4.2 await 表达式"></a>4.2 await 表达式</h3><h4 id="MDN"><a href="#MDN" class="headerlink" title="MDN"></a>MDN</h4><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function">async</a></p>
<p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await">await</a></p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><p>[return_value] = await expression;</p>
<p><strong>表达式</strong></p>
<p> 一个 <code>Promise</code> 对象或者任何要<strong>等待</strong>的<code>值</code>。</p>
<p><strong>返回值</strong></p>
<p> 返回 Promise 对象的处理结果。如果<strong>等待</strong>的不是 Promise 对象，则返回该值本身。</p>
<p><strong>解释</strong></p>
<p><strong>await 表达式会暂停当前 async function 的执行，等待 Promise 处理完成。</strong></p>
<ol>
<li>await 右侧的表达式一般为 promise 对象，但也可以是其他的值</li>
<li>如果表达式是 promise 对象，await 返回的是 promise 成功的值</li>
<li>如果表达式是其他值，直接将此值作为 await 的返回值</li>
</ol>
<p>注意：</p>
<p>await 必须写在 async 函数中，但 async 函数中可以没有 await</p>
<p>如果 await 的 promise 失败了，就会抛出异常，需要通过 try…catch 来捕获处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn2() &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      resolve(5)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn4() &#123;</span><br><span class="line">  return 6</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn3() &#123;</span><br><span class="line">  &#x2F;&#x2F;const p &#x3D; fn2() &#x2F;&#x2F; 这种写法只能得到一个promise对象</span><br><span class="line">  const value &#x3D; await fn2() &#x2F;&#x2F; value 5</span><br><span class="line">  &#x2F;&#x2F;const value &#x3D; await fn4() &#x2F;&#x2F; value 6</span><br><span class="line">  console.log(&#39;value&#39;, value)</span><br><span class="line">&#125;</span><br><span class="line">fn3()</span><br></pre></td></tr></table></figure>
<p>不写 await，只能得到一个 promise 对象。在表达式前面加上 await，1s后将得到 promise 的结果5，但是要用 await 必须在函数上声明 async。</p>
<p>await 右侧表达式 fn2() 为 promise，得到的结果就是 promise 成功的 value；await 右侧表达式 fn4() 不是 promise，得到的结果就是这个值本身。</p>
<p>Promise 对象的结果也有可能失败：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn2() &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      reject(5)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;) </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn3() &#123;</span><br><span class="line">  const value &#x3D; await fn2()</span><br><span class="line">  console.log(&#39;value&#39;, value)</span><br><span class="line">&#125;</span><br><span class="line">fn3()</span><br><span class="line">&#x2F;&#x2F; 报错：Uncaught (in promise) 5</span><br></pre></td></tr></table></figure>
<p>await 只能得到成功的结果，要想得到失败的结果就要用try/catch：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function fn2() &#123;</span><br><span class="line">  return new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">      reject(5)</span><br><span class="line">    &#125;, 1000)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function fn3() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const value &#x3D; await fn2()</span><br><span class="line">     console.log(&#39;value&#39;, value)</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.log(&#39;得到失败的结果&#39;, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn3()</span><br><span class="line">&#x2F;&#x2F; 得到失败的结果 5</span><br></pre></td></tr></table></figure>
<p>下面这个栗子中，fn1 是第 2 种情况，fn2 是第 3 种情况，fn3 也是第 3 种情况</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function fn1() &#123; &#x2F;&#x2F;async声明的异步回调函数将返回一个promise</span><br><span class="line">  return 1</span><br><span class="line">&#125;</span><br><span class="line">function fn2() &#123;</span><br><span class="line">  return 2</span><br><span class="line">&#125;</span><br><span class="line">function fn3() &#123;</span><br><span class="line">  throw 3 &#x2F;&#x2F; 抛出异常</span><br><span class="line">&#125;</span><br><span class="line">async function fn3() &#123;</span><br><span class="line">  try &#123;</span><br><span class="line">    const value &#x3D; await fn1() &#x2F;&#x2F; value 1</span><br><span class="line">    &#x2F;&#x2F;const value &#x3D; await fn2() &#x2F;&#x2F; value 2</span><br><span class="line">    &#x2F;&#x2F;const value &#x3D; await fn3() &#x2F;&#x2F; 得到失败的结果 3</span><br><span class="line">    console.log(&#39;value&#39;, value)</span><br><span class="line">  &#125; catch (error) &#123;</span><br><span class="line">    console.log(&#39;得到失败的结果&#39;, error)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">fn3()</span><br></pre></td></tr></table></figure>
<h2 id="五、JS异步之宏队列与微队列"><a href="#五、JS异步之宏队列与微队列" class="headerlink" title="五、JS异步之宏队列与微队列"></a>五、JS异步之宏队列与微队列</h2><p><img src="https://img-blog.csdnimg.cn/20200703144207979.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70" alt="img"></p>
<ol>
<li><p>JS 中用来存储待执行回调函数的队列包含2个不同特定的队列</p>
</li>
<li><p>宏队列：用来保存待执行的宏任务（回调），比如：定时器回调/DOM 事件回调/ajax 回调</p>
</li>
<li><p>微队列：用来保存待执行的微任务（回调），比如：promise 的回调/MutationObserver 的回调</p>
</li>
<li><p>JS 执行时会区别这2个队列</p>
<p>(1) JS 引擎首先必须执行所有的初始化同步任务代码</p>
<p>(2) 每次准备取出第一个宏任务前，都要将所有的微任务一个一个取出来执行</p>
</li>
</ol>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 会立即被放入宏队列</span><br><span class="line">  console.log(&#39;timeout callback1()&#39;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 会立即被放入宏队列</span><br><span class="line">  console.log(&#39;timeout callback2()&#39;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">Promise.resolve(1).then(</span><br><span class="line">  value &#x3D;&gt; &#123; &#x2F;&#x2F; 会立即被放入微队列</span><br><span class="line">    console.log(&#39;Promise onResolved1()&#39;, value)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">Promise.resolve(1).then(</span><br><span class="line">  value &#x3D;&gt; &#123; &#x2F;&#x2F; 会立即被放入微队列</span><br><span class="line">    console.log(&#39;Promise onResolved2()&#39;, value)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; Promise onResolved1() 1</span><br><span class="line">&#x2F;&#x2F; Promise onResolved2() 1</span><br><span class="line">&#x2F;&#x2F; timeout callback1()</span><br><span class="line">&#x2F;&#x2F; timeout callback2()</span><br></pre></td></tr></table></figure>
<p>先执行所有的同步代码，再执行队列代码。队列代码中，微队列中的回调函数优先执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 会立即被放入宏队列</span><br><span class="line">  console.log(&#39;timeout callback1()&#39;)</span><br><span class="line">  Promise.resolve(1).then(</span><br><span class="line">  value &#x3D;&gt; &#123; &#x2F;&#x2F; 会立即被放入微队列</span><br><span class="line">    console.log(&#39;Promise onResolved3()&#39;, value)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, 0)</span><br><span class="line">setTimeout(() &#x3D;&gt; &#123; &#x2F;&#x2F; 会立即被放入宏队列</span><br><span class="line">  console.log(&#39;timeout callback2()&#39;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">Promise.resolve(1).then(</span><br><span class="line">  value &#x3D;&gt; &#123; &#x2F;&#x2F; 会立即被放入微队列</span><br><span class="line">    console.log(&#39;Promise onResolved1()&#39;, value)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">Promise.resolve(1).then(</span><br><span class="line">  value &#x3D;&gt; &#123; &#x2F;&#x2F; 会立即被放入微队列</span><br><span class="line">    console.log(&#39;Promise onResolved2()&#39;, value)</span><br><span class="line">  &#125;</span><br><span class="line">)</span><br><span class="line">&#x2F;&#x2F; Promise onResolved1() 1</span><br><span class="line">&#x2F;&#x2F; Promise onResolved2() 1</span><br><span class="line">&#x2F;&#x2F; timeout callback1()</span><br><span class="line">  &#x2F;&#x2F; Promise onResolved3() 1</span><br><span class="line">&#x2F;&#x2F; timeout callback2()</span><br></pre></td></tr></table></figure>
<p>执行完 <code>timeout callback1()</code> 后 <code>Promise onResolved3()</code> 会立即被放入微队列。在执行 <code>timeout callback2()</code> 前，<code>Promise onResolved3()</code> 已经在微队列中了，所以先执行 <code>Promise onResolved3()</code>。</p>
<h2 id="六、相关面试题"><a href="#六、相关面试题" class="headerlink" title="六、相关面试题"></a>六、相关面试题</h2><h3 id="6-1-面试题1"><a href="#6-1-面试题1" class="headerlink" title="6.1 面试题1"></a>6.1 面试题1</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(1)</span><br><span class="line">&#125;, 0)</span><br><span class="line">new Promise((resolve) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(2)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(3)</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(4)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(5)</span><br><span class="line">&#x2F;&#x2F; 2 5 3 4 1</span><br><span class="line">&#x2F;*</span><br><span class="line">同步：[2,5]</span><br><span class="line">异步：</span><br><span class="line">宏队列：[1]</span><br><span class="line">微队列：[3,4]</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<p><strong>2 是 excutor 执行器，是同步回调函数，所以在同步代码中。.then() 中的函数才是异步回调</strong></p>
<p>其中，执行完 2 后改变状态为 resolve，第一个 .then() 中的 3 会放入微队列，但还没执行（promise 是 pending 状态），就不会把结果给第二个 then()，这时，4 就会缓存起来但不会被放入微队列。只有在微队列中的 3 执行完后才把 4 放入微队列。</p>
<p>所以顺序是：</p>
<p>1 放入宏队列，2 执行，3 放入微队列，4 缓存起来等待 Promise 的状态改变，5 执行，微队列中的 3 执行，4 放入微队列，微队列中的 4 执行，宏队列中的 1 执行。</p>
<h3 id="6-2-面试题2"><a href="#6-2-面试题2" class="headerlink" title="6.2 面试题2"></a>6.2 面试题2</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const first &#x3D; () &#x3D;&gt; ( &#x2F;&#x2F; 省略return所以不用&#123;&#125;而用()</span><br><span class="line">  new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(3)</span><br><span class="line">    let p &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(7)</span><br><span class="line">      setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">        console.log(5)</span><br><span class="line">        resolve(6) &#x2F;&#x2F;没用，状态只能改变一次，在resolve(1)时就改变了</span><br><span class="line">      &#125;, 0)</span><br><span class="line">      resolve(1)</span><br><span class="line">    &#125;)</span><br><span class="line">    resolve(2)</span><br><span class="line">    p.then((arg) &#x3D;&gt; &#123;</span><br><span class="line">      console.log(arg)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line">first().then((arg) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(arg)</span><br><span class="line">&#125;)</span><br><span class="line">console.log(4)</span><br><span class="line">&#x2F;&#x2F; 3 7 4 1 2 5</span><br><span class="line">&#x2F;*</span><br><span class="line">宏：[5]</span><br><span class="line">微：[1,2]</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="6-3-面试题3"><a href="#6-3-面试题3" class="headerlink" title="6.3 面试题3"></a>6.3 面试题3</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;0&quot;)</span><br><span class="line">&#125;, 0)</span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;1&quot;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;2&quot;)</span><br><span class="line">  new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;3&quot;)</span><br><span class="line">    resolve()</span><br><span class="line">  &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;4&quot;)</span><br><span class="line">  &#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">    console.log(&quot;5&quot;)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;6&quot;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;7&quot;)</span><br><span class="line">  resolve()</span><br><span class="line">&#125;).then(() &#x3D;&gt; &#123;</span><br><span class="line">  console.log(&quot;8&quot;)</span><br><span class="line">&#125;)</span><br><span class="line">&#x2F;&#x2F; 1 7 2 3 8 4 6 5 0</span><br><span class="line">&#x2F;*</span><br><span class="line">宏：[0]</span><br><span class="line">微：[2, 8, 4, 6, 5]</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<p>顺序：</p>
<p>0 放入宏队列，同步执行 1，2 放入微队列，6 缓存到内部，同步执行 7，8 放入微队列，取出微队列中的 2 执行，同步执行 3，4 放入微队列，5 缓存到内部，6 放入微队列(因为 6 的前一个 promise 已经执行完了返回成功结果 undefined)，取出微队列中的 8 执行，取出微队列中的 4 执行，5 放入微队列，取出微队列中的 6 执行，取出微队列中的 5 执行，取出宏队列中的 0 执行</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1MJ41197Eu?p=1">尚硅谷Promise教程(promise前端进阶必学)</a></p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js类</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/4.apply()%E3%80%81call()%E3%80%81prototype%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="apply和call区别"><a href="#apply和call区别" class="headerlink" title="apply和call区别"></a>apply和call区别</h2><p>**apply:**能劫持另外一个对象的方法，继承另外一个对象的属性。</p>
<blockquote>
<p>Function.apply(obj, args)</p>
<p>obj: 这个对象将代替Function类里this对象</p>
<p>args: 这个是数组，它将作为参数传给Function(args–&gt;arguments)</p>
</blockquote>
<p>**call:**和apply的意思一样，只不过是参数列表不一样</p>
<blockquote>
<p>Function.call(obj, [param1[, param2[,…[,paramN]]]])</p>
<p>obj:这个对象将代替Function类里的this对象</p>
<p>params:这个是一个参数列表</p>
</blockquote>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><a id="more"></a>

<p>(实现一个简单的new方法示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">let</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newMethod = <span class="function"><span class="keyword">function</span> (<span class="params">Parent, ...rest</span>) </span>&#123; <span class="comment">//...rest为不定变量，指剩下的所有参数</span></span><br><span class="line">    <span class="comment">// 1.以构造器的prototype属性为原型，创建新对象；</span></span><br><span class="line">    <span class="keyword">let</span> child = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">    <span class="comment">// 2.将this和调用参数传给构造器执行</span></span><br><span class="line">    Parent.apply(child, rest);</span><br><span class="line">    <span class="comment">// 3.返回第一步的对象</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建一个实例，将构造函数Parent与形参作为参数传入</span></span><br><span class="line"><span class="keyword">const</span> child = newMethod(Parent, <span class="string">&#x27;echo&#x27;</span>, <span class="number">26</span>);</span><br><span class="line">child.sayName() <span class="comment">//&#x27;echo&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后检验，与使用new的效果相同</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent<span class="comment">//true</span></span><br><span class="line">child.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)<span class="comment">//true</span></span><br><span class="line">child.hasOwnProperty(<span class="string">&#x27;age&#x27;</span>)<span class="comment">//true</span></span><br><span class="line">child.hasOwnProperty(<span class="string">&#x27;sayName&#x27;</span>)<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>Parent.apply(child, rest)：</strong><br>传入的rest为[‘echo’, 26]<br>child去执行Parent类里面的内容，也就是把Parent中的属性引入新创建的child对象中。</p>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, grade</span>) </span>&#123;</span><br><span class="line">    People.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">    <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;大三&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(student.name + student.age + student.grade);<span class="comment">//小明21大三</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们并没有给<code>Student</code>的<code>name</code>和<code>age</code>赋值，但是存在这两个属性的值，这还是要归功于<code>call()</code>方法，它可以改变<code>this</code>的指向。</p>
<p><strong>People.call(this, name, age):</strong></p>
<p><code>this</code>代表的是<code>Student</code>，这也就是之前说的，使得<code>Student</code>可以调用<code>People</code>中的方法，因为<code>People</code>中有<code>this.name = name;</code>等语句，这样就将<code>name</code>和<code>age</code>属性创建到了<code>Student</code>中。</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p><code>call()</code>和<code>apply()</code>的不同点就是<strong>接收参数的方式不同</strong>。</p>
<p><strong>apply()方法</strong>接收两个参数，一个是函数运行的作用域（<code>this</code>），另一个是参数数组。</p>
<p><strong>call()方法</strong>不一定接受两个参数，第一个参数也是函数运行的作用域（<code>this</code>），但是传递给函数的参数必须列举出来。</p>
<h3 id="apply妙用"><a href="#apply妙用" class="headerlink" title="apply妙用"></a>apply妙用</h3><h5 id="1）-Math-max可以实现得到数组中最大的一项"><a href="#1）-Math-max可以实现得到数组中最大的一项" class="headerlink" title="1） Math.max可以实现得到数组中最大的一项"></a>1） Math.max可以实现得到数组中最大的一项</h5><p>但是因为<code>Math.max</code>参数里面不支持<code>Math.max([param1,param2])</code>，也就是数组，但是它支持<code>Math.max(param1,param2,param3…)</code>，所以可以根据<code>apply</code>的那个特点来解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, array);</span><br><span class="line"><span class="built_in">console</span>.log(max);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>这样轻易的可以得到一个数组中最大的一项，<code>apply</code>会将一个数组转换为一个参数接一个参数的传递给方法，这块在调用的时候第一个参数给了一个<code>null</code>，这个是因为没有对象去调用这个方法，我们只需要用这个方法帮我运算，得到返回的结果就行，所以直接传递了一个<code>null</code>过去，当然，第一个参数使用<code>this</code>也是可以的</p>
<p>同理 Math.min() 也是一样的</p>
<h5 id="2）Array-prototype-push可以实现两个数组合并"><a href="#2）Array-prototype-push可以实现两个数组合并" class="headerlink" title="2）Array.prototype.push可以实现两个数组合并"></a>2）Array.prototype.push可以实现两个数组合并</h5><p>同样的，<code>push</code>方法没有提供<code>push</code>一个数组，但是它提供了<code>push(param1,param,…paramN)</code>所以同样也可以通过<code>apply</code>来装换一下这个数组，即:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">//[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr1.push.apply(arr1, arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">//[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>
<p>还有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">[].push.apply(arr1, arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">//[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>当目标函数只需要n个参数列表，不接收一个数组的形式（<code>[param1[,param2[,…[,paramN]]]]</code>）时，我们就可以通过<code>apply</code>的方式来巧妙地解决。</p>
<h2 id="prototype用法"><a href="#prototype用法" class="headerlink" title="prototype用法"></a>prototype用法</h2><p>注意点：new实例创建之后，再使用<strong>对象字面量</strong>重新赋值给prototype，<strong>prototype</strong>的指向地址换成了<strong>新的</strong>object的地址。而之前那个<strong>实例</strong>指向的还是<strong>原有的</strong>默认的prototype地址，使得之前的实例指向的曾经的prototype<strong>变得不可联系</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果要在实例之后用prototype的话不要用对象字面量方法：</span></span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    saySomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;What&#x27;s up?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//而要用对prototype的属性直接赋值的方式：</span></span><br><span class="line">Person.prototype.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">20</span>;</span><br><span class="line">Person.prototype.saySomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;What&#x27;s up?&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">&quot;Mike&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(man.name);</span><br></pre></td></tr></table></figure>
<p>结果为<strong>John</strong>,如果不直接给man添加一个自己的name属性的话，他会变成永远的John。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">Person.prototype = &#123; <span class="comment">//使用对象字面量，指向地址变化</span></span><br><span class="line">    name:<span class="string">&quot;Mike&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person(); <span class="comment">//创建的实例指向的是新的地址</span></span><br><span class="line">Person.prototype.name = <span class="string">&quot;Tom&quot;</span>; <span class="comment">//使用直接赋值的方式改变name</span></span><br><span class="line"><span class="built_in">console</span>.log(man.name);</span><br></pre></td></tr></table></figure>
<p>结果为<strong>Tom</strong>,new创建新实例在已经改变为新地址之后。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">&quot;Mike&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(man.name);</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Tom&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>结果为<strong>Mike</strong>，同样，实例创建在地址变化之后，而打印name在变为Tom之前。</p>
<p>所以对象字面量重写会使得之前创建的实例与之后创建的实例实际指向不同的prototype。慎用之。</p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js面向对象、基于对象</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/2.JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="对象的基本特征"><a href="#对象的基本特征" class="headerlink" title="对象的基本特征"></a>对象的基本特征</h2><ol>
<li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li>
<li>对象有状态：同一对象可能处于不同状态之下。</li>
<li>对象有行为：对象的状态可能因为它的行为产生变迁。</li>
</ol>
<h3 id="第一个特征："><a href="#第一个特征：" class="headerlink" title="第一个特征："></a>第一个特征：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">a</span> : <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;<span class="attr">a</span> : <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o1 == o2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="第二个和第三个特征："><a href="#第二个和第三个特征：" class="headerlink" title="第二个和第三个特征："></a>第二个和第三个特征：</h3><table>
<thead>
<tr>
<th>JS</th>
<th>C++</th>
<th>JAVA</th>
</tr>
</thead>
<tbody><tr>
<td>状态</td>
<td>成员变量</td>
<td>属性</td>
</tr>
<tr>
<td>行为</td>
<td>成员函数</td>
<td>方法</td>
</tr>
</tbody></table>
<p>js中状态和行为统一抽象为“属性”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  f: <span class="number">1</span>,</span><br><span class="line">  <span class="function"><span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>o是对象，d和函数f，尽管写法不太相同，但是在js中就都是普通属性。</p>
<h2 id="JS中对象独有特征"><a href="#JS中对象独有特征" class="headerlink" title="JS中对象独有特征"></a>JS中对象独有特征</h2><p>对象具有高度的动态性，因为js赋予了使用者在运行时为对象添加状态和行为的能力。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span> : <span class="number">1</span>&#125;;</span><br><span class="line">o.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.a,o.b); <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>
<h2 id="JS对象的两类属性"><a href="#JS对象的两类属性" class="headerlink" title="JS对象的两类属性"></a>JS对象的两类属性</h2><p>js属性并非知识简单的名称和值，js用一组特征(attribute)来描述属性(property)</p>
<h3 id="第一类属性：数据属性"><a href="#第一类属性：数据属性" class="headerlink" title="第一类属性：数据属性"></a>第一类属性：数据属性</h3><p>它具有四个<strong>特征</strong>：</p>
<ul>
<li>value: 属性的值。</li>
<li>writable: 决定属性能否被赋值。</li>
<li>enumerable: 决定for in能否枚举该属性。</li>
<li>configurable: 决定该属性能否被删除或者改变特征值。</li>
</ul>
<h3 id="第二类属性：访问器-getter-setter-属性"><a href="#第二类属性：访问器-getter-setter-属性" class="headerlink" title="第二类属性：访问器(getter/setter)属性"></a>第二类属性：访问器(getter/setter)属性</h3><p>它也具有四个<strong>特征</strong>：</p>
<ul>
<li>getter: 函数或undefined，在取属性值时被调用。</li>
<li>setter: 函数或undefined，在设置属性值时被调用。</li>
<li>enumerable: 决定for in能否枚举该属性。</li>
<li>configurable: 决定该属性能否被删除或者改变特征值。</li>
</ul>
<p>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p>
<p>我们通常在用代码定义属性时，会产生数据属性。其中的writable、enumerable、configurable 都默认为 true。</p>
<p><strong>使用对象直接量创建的属性，writable、enumerable和configurable特性默认为true。</strong></p>
<p>我们可以使用<strong>内置函数 Object.getOwnPropertyDescripter</strong> 来<strong>查看</strong> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">o.b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//a和b皆为数据属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="comment">// &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;b&quot;</span>))</span><br><span class="line"><span class="comment">// &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果我们要想<strong>改变属性的特征</strong>，或者<strong>定义访问器属性</strong>，我们可以使用 <strong>Object.defineProperty</strong>:</p>
<p><strong>在使用Object.defineProperty、Object.defineProperties 或 Object.create 函数的情况下添加数据属性，writable、enumerable和configurable默认值为false。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;b&quot;</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">false</span>, <span class="attr">enumerable</span>: <span class="literal">false</span>,<span class="attr">configurable</span>: <span class="literal">true</span>&#125;); </span><br><span class="line"><span class="comment">//a和b都是数据属性，但特征值变化了 </span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;a&quot;</span>); </span><br><span class="line"><span class="comment">//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125; Object.getOwnPropertyDescriptor(o,&quot;b&quot;); </span></span><br><span class="line"><span class="comment">//&#123;value: 2, writable: false, enumerable: false, configurable: true&#125; </span></span><br><span class="line">o.b = <span class="number">3</span>; <span class="comment">//这时想重新赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 2，因为writable被改为了false</span></span><br></pre></td></tr></table></figure>
<p>在创建对象时，也可以使用 get 和 set 关键字来创建访问器属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>js对象运行时是一个“属性的集合”：</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>字符串/Symbol</td>
<td>数据属性特征值/访问器属性特征值</td>
</tr>
</tbody></table>
<p>以上面的对象 o 为例:</p>
<p>key:a</p>
<p>value:{writable:true,value:1,configurable:true,enumerable:true}</p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js类</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/3.JS%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>基于类的编程语言：C++、Java</strong>提倡使用一个关注分类和类之间关系开发模型。 总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。</p>
<p><strong>基于原型：JS</strong>更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。</p>
<h2 id="JS的原型模拟类"><a href="#JS的原型模拟类" class="headerlink" title="JS的原型模拟类"></a>JS的原型模拟类</h2><p>用两条概括：</p>
<ul>
<li>如果所有对象都有私有字段([prototype])，就是对象的原型；</li>
<li>读一个属性，如果对象本身没有，则会继续访问对象的原型，知道原型为空或者找到为止。</li>
</ul>
<p>ES6提供了一些列内置函数，以便更为直接地访问操纵原型。</p>
<p>三个方法分别为：</p>
<a id="more"></a>

<ul>
<li>Object.create 根据指定的原型创建新对象，原型可以是null;</li>
<li>Object.getPrototypeOf 获得一个对象的原型</li>
<li>Object.setPrototypeOf 设置一个对象的原型；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;meow~&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">jump</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;jump&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tiger = <span class="built_in">Object</span>.create(cat, &#123;</span><br><span class="line">  say: &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;roar!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherCat = <span class="built_in">Object</span>.create(cat);</span><br><span class="line">anotherCat.say(); <span class="comment">// meow~</span></span><br><span class="line"><span class="keyword">var</span> anotherTiger = <span class="built_in">Object</span>.create(tiger);</span><br><span class="line">anotherTiger.say(); <span class="comment">// roar!</span></span><br></pre></td></tr></table></figure>
<h3 id="new-运算"><a href="#new-运算" class="headerlink" title="new 运算"></a>new 运算</h3><p>new 运算接受一个构造函数和一组调用参数，实际上做了几件事：</p>
<ul>
<li>以构造器的 prototype 属性为原型，创建新对象；</li>
<li>将构造函数的作用域赋给新对象(因此 this 就指向了这个新对象)；</li>
<li>执行构造函数中的代码(为这个新对象添加属性) ；</li>
<li>如果构造函数返回的是对象，则返回，否则返回第一步创建的对象。</li>
</ul>
<p>接下来我们就封装一个函数来模拟 new 操作符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFunc</span>(<span class="params">fn, ...argv</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> o = &#123;&#125; <span class="comment">// 创建一个新对象</span></span><br><span class="line">    o.__proto__ = fn.prototype <span class="comment">// 新对象的原型指向构造函数的原型</span></span><br><span class="line">    <span class="keyword">const</span> val = fn.apply(o, argv)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> ? val : o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = newFunc(Person, <span class="string">&#x27;wy&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name, person.age) <span class="comment">// wy 18</span></span><br><span class="line">person.say() <span class="comment">// hello!</span></span><br></pre></td></tr></table></figure>
<p>也可以运用ES6 中的一些新特性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFunc</span>(<span class="params">fn, ...argv</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> o = <span class="built_in">Object</span>.create(fn.prototype)</span><br><span class="line">    <span class="keyword">const</span> val = fn.apply(o, argv)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> ? val : o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 构造函数返回一个对象</span></span><br><span class="line">        name: name,</span><br><span class="line">        age: age,</span><br><span class="line">        <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = newFunc(Person, <span class="string">&#x27;wy&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name, person.age) <span class="comment">// wy 18</span></span><br><span class="line">person.say() <span class="comment">// Hi!</span></span><br></pre></td></tr></table></figure>
<h2 id="ES6中的类"><a href="#ES6中的类" class="headerlink" title="ES6中的类"></a>ES6中的类</h2><p>ES5中没有类的概念，所以只能new function搭配，ES6 中加入了新特性 class</p>
<h3 id="类的基本写法"><a href="#类的基本写法" class="headerlink" title="类的基本写法"></a>类的基本写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造器</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.calcArea();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Method</span></span><br><span class="line">  <span class="function"><span class="title">calcArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的是，类提供了<strong>继承能力</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; makes a noise.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name); <span class="comment">// call the super class constructor and pass in the name parameter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; barks.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Dog(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.speak(); <span class="comment">// Mitzie barks.</span></span><br></pre></td></tr></table></figure>
<p>使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。</p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>Array、String、Object、Math、Number常用方法总结</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/17.Array%E3%80%81String%E3%80%81Object%E3%80%81Math%E3%80%81Number%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Array"><a href="#Array" class="headerlink" title="Array"></a>Array</h2><h3 id="1-concat"><a href="#1-concat" class="headerlink" title="1.concat()"></a>1.concat()</h3><p>用于连接两个或多个数组。返回一个新的数组</p>
<blockquote>
<p>语法：arrayObject.concat(arrayX,arrayX,……,arrayX)</p>
<p>arrayX 必需，该参数可以是具体的值，也可以是数组对象。可以是任意多个。</p>
<p>注意：该方法<strong>不会改变原有的数组</strong> arrayObject，而仅仅会返回一个新，该数组是通过把所有 arrayX 参数添加到 arrayObject 中生成的。如果要进行 concat() 操作的参数是数组，那么添加的是数组中的元素，而不是数组。</p>
</blockquote>
<a id="more"></a>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; [1, 2, 13]</span><br><span class="line">const b &#x3D; [7, 9, 3]</span><br><span class="line">const c &#x3D; a.concat(65, b)</span><br><span class="line">console.log(c) &#x2F;&#x2F; [1,2,13,65,7,9,3]</span><br></pre></td></tr></table></figure>
<h3 id="2-join"><a href="#2-join" class="headerlink" title="2.join()"></a>2.join()</h3><p>用于把数组中的所有元素放入一个字符串。返回一个字符串,不改变原数组。</p>
<blockquote>
<p>语法：arrayObject.join(separator)</p>
<p>separator 可选，指定要使用的分隔符。如果省略该参数，则使用逗号作为分隔符。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 13]</span><br><span class="line">const str &#x3D; arr.join(&#39;|&#39;)</span><br><span class="line">console.log(str) &#x2F;&#x2F; &quot;1|2|13&quot;</span><br></pre></td></tr></table></figure>
<h3 id="3-reverse"><a href="#3-reverse" class="headerlink" title="3.reverse()"></a>3.reverse()</h3><p>用于颠倒数组中元素的顺序，该方法会改变原来的数组，而不会创建新的数组。</p>
<blockquote>
<p>语法：arrayObject.reverse()</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const a &#x3D; [1, 2, 13]</span><br><span class="line">a.reverse()</span><br><span class="line">console.log(a) &#x2F;&#x2F; [13,2,1]</span><br></pre></td></tr></table></figure>
<h3 id="4-slice-和-splice"><a href="#4-slice-和-splice" class="headerlink" title="4.slice() 和 splice()"></a>4.slice() 和 splice()</h3><h4 id="slice"><a href="#slice" class="headerlink" title="slice()"></a>slice()</h4><p>从已有的数组中返回选定的元素构成一个新的数组。不改变原数组。</p>
<blockquote>
<p>语法：arrayObject.slice(start,end) <strong>返回的新数组包含从 start 到 end （不包括该元素）的 arrayObject 中的元素。</strong></p>
<p>start 必需，规定从何处开始选取。如果是负数，那么它规定从数组尾部开始算起的位置。也就是说，-1 指最后一个元素，-2 指倒数第二个元素，以此类推。</p>
<p>end 可选，。规定从何处结束选取。该参数是数组片断结束处的数组下标。如果没有指定该参数，那么切分的数组包含从 start 到数组结束的所有元素。如果这个参数是负数，那么它规定的是从数组尾部开始算起的元素。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [1, 2, 13, 15, 13, 45, 32, 55, 7, 5]</span><br><span class="line">const newArr &#x3D; arr.slice(-5, -1)</span><br><span class="line">console.log(newArr) &#x2F;&#x2F; [45, 32, 55, 7]</span><br></pre></td></tr></table></figure>
<h4 id="splice"><a href="#splice" class="headerlink" title="splice()"></a>splice()</h4><p>向/从数组中添加/删除项目，然后返回被删除的项目组成的数组。该方法会改变原始数组。</p>
<blockquote>
<p>语法：arrayObject.splice(index,howmany,item1,…..,itemX)</p>
<p>删除从 index 处开始的 howmany 个元素，并且可用列表中声明的一个或者多个值（item1,…..,itemX）来替换那些被删除的元素。</p>
<p>index 必需，整数，规定添加/删除项目的位置，使用负数可从数组结尾处规定位置。</p>
<p>howmany 必需，要删除的项目数量。如果设置为 0，则不会删除项目。</p>
<p>item1,…..,itemX 可选，向数组添加的新项目。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [10, 20, 1, 2, 7, 32];</span><br><span class="line">const newArr &#x3D; arr.splice(1, 1)</span><br><span class="line">console.log(newArr); &#x2F;&#x2F; 20</span><br><span class="line">console.log(arr); &#x2F;&#x2F; 10, 1, 2, 7, 32</span><br><span class="line">console.log(arr.splice(-2, 2, 66, 66)); &#x2F;&#x2F; 7, 32</span><br><span class="line">console.log(arr); &#x2F;&#x2F; 10, 1, 2, 66, 66</span><br></pre></td></tr></table></figure>
<h4 id="slice-和-splice-异同"><a href="#slice-和-splice-异同" class="headerlink" title="slice() 和 splice() 异同"></a>slice() 和 splice() 异同</h4><ol>
<li>都会返回一个新数组</li>
<li>slice() 将从原数组中截取出来的一些元素作为新数组返回，而 splice() 是返回被删除的元素组成的新数组</li>
<li>splice() 还可以在原数组中删除的元素的位置添加新元素</li>
<li>splice() 会改变原数组，slice() 不会</li>
</ol>
<h3 id="5-sort"><a href="#5-sort" class="headerlink" title="5.sort()"></a>5.sort()</h3><p>使数组中的元素按照一定的顺序进行重新排序，该方法会改变原来的数组。</p>
<blockquote>
<p>语法：arrayObject.sort(sortby)</p>
<p>sortby 可选，若使用时未传入参数，默认排序规则，是按照字符编码的顺序进行排序；若使用该参数，必须是函数（比较函数）规定排序顺序，即接收一个比较函数来实现自定义的排序。</p>
<p>比较函数要比较两个值，应该具有两个参数 a 和 b，然后返回一个用于说明这两个值的相对顺序的数字。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var sortby &#x3D; function(a,b)&#123;</span><br><span class="line">    return a - b;   </span><br><span class="line">  &#x2F;&#x2F; 注：开始时 a&#x3D;arrayObject[0],b&#x3D;arrayObject[1];然后a&#x3D;调整后的arrayObject[1],b&#x3D;调整后的arrayObject[2]；以此类推，直到数组合中的元素全部循环判断一遍</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其返回值如下：</p>
<ul>
<li>若 a 小于 b，在排序后的数组中 a 应该出现在 b 之前，则返回一个小于 0 的值，此时不调换 a、b 顺序。</li>
<li>若 a 等于 b，则返回 0，此时不调换 a、b 顺序。</li>
<li>若 a 大于 b，则返回一个大于 0 的值，此时调换 a、b 的顺序。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr &#x3D; [10, 20, 1, 2];</span><br><span class="line">&#x2F;&#x2F;将数组中的元素按从小到大排列</span><br><span class="line">arr.sort(function(a, b)&#123;</span><br><span class="line">    return a - b; &#x2F;&#x2F; &lt;0</span><br><span class="line">&#125;);</span><br><span class="line">document.write(arr);&#x2F;&#x2F;1,2,10,20</span><br><span class="line">&#x2F;&#x2F;将数组中的元素按从大到小排列</span><br><span class="line">arr.sort(function(a, b)&#123;</span><br><span class="line">    return b - a; &#x2F;&#x2F; &gt;0</span><br><span class="line">&#125;);</span><br><span class="line">document.write(arr);&#x2F;&#x2F;20,10,2,1</span><br></pre></td></tr></table></figure>
<h3 id="6-forEach-、map-、reduce-和-filter"><a href="#6-forEach-、map-、reduce-和-filter" class="headerlink" title="6.forEach()、map()、reduce() 和 filter()"></a>6.forEach()、map()、reduce() 和 filter()</h3><h4 id="forEach"><a href="#forEach" class="headerlink" title="forEach()"></a>forEach()</h4><p>用于调用数组的每个元素，并将元素传递给回调函数。返回值为 undefined。</p>
<blockquote>
<p>语法：array.forEach(function(currentValue, index, arr), thisValue)</p>
</blockquote>
<h4 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h4><p>按照原始数组元素顺序依次处理元素，可以方便的遍历数组。返回一个新数组，不会改变原始数组。</p>
<blockquote>
<p>语法：arrayObject.map(function(currentValue,index,arr), thisValue)</p>
<ol>
<li><p>function(currentValue, index,arr) 必需，函数，数组中的每个元素都会执行这个函数。</p>
<p>map() 方法可给该回调函数传入三个值：</p>
<ul>
<li>currentValue （必选 当前元素的值）</li>
<li>index （可选，当前元素的索引）</li>
<li>arr（可选，当前元素属于的数组对象。后两者在回调函数中根据是否需要来决定是否作为参数传入）</li>
</ul>
</li>
<li><p>thisValue 可选，运行该函数的作用域对象，影响 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined”。一般用不到该参数。</p>
</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [10, 20, 1];</span><br><span class="line">const newArr &#x3D; arr.map((val) &#x3D;&gt; &#123;</span><br><span class="line">    return val + 1</span><br><span class="line">&#125;)</span><br><span class="line">console.log(newArr); &#x2F;&#x2F; 11,21,2</span><br><span class="line">console.log(arr); &#x2F;&#x2F; 10,20,1</span><br></pre></td></tr></table></figure>
<h4 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h4><p>接收一个函数作为累加器，数组中的每个值（从左到右）开始缩减，最终计算为一个值。reduce()方法可以方便的迭代数组。不会改变原数组。</p>
<blockquote>
<p>语法：arrayObject.reduce(function(previousValue, currentValue, currentIndex, arr), initialValue)</p>
<ol>
<li><p>function(previousValue, currentValue, currentIndex, arr) 必需，函数</p>
<p>reduce()方法可给该回调函数传入四个值：</p>
<ul>
<li>previousValue （必选，上一次调用回调返回的值，或者是提供的初始值（initialValue））</li>
<li>currentValue （必选， 数组中当前被处理的元素）</li>
<li>currentIndex（可选，当前元素在数组中的索引）</li>
<li>arr （可选，调用 reduce 的数组对象本身）</li>
</ul>
</li>
<li><p>initialValue 可选，若不设置。则初始值将变成数组中的第一项，而 currentValue 即从数组中的第二项开始。</p>
</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const arr &#x3D; [10, 20, 1];</span><br><span class="line">const val &#x3D; arr.reduce((preVal, currentVal) &#x3D;&gt; &#123;</span><br><span class="line">    return preVal + currentVal</span><br><span class="line">&#125;, 0)</span><br><span class="line">console.log(val); &#x2F;&#x2F; 31</span><br><span class="line">&#x2F;* 计算过程：</span><br><span class="line">0 + 10</span><br><span class="line">10 + 20</span><br><span class="line">30 + 1</span><br><span class="line">*&#x2F;</span><br></pre></td></tr></table></figure>
<h4 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h4><p>创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。filter()方法可以方便的遍历数组，对元素进行过滤。不会改变原始数组。</p>
<blockquote>
<p>语法：arrayObject.filter(function(currentValue,index,arr), thisValue)</p>
<ol>
<li><p>function(currentValue,index,arr) 必选，函数</p>
<p>filter() 方法可给该回调函数传入三个值：</p>
<ul>
<li>currentValue（必选，当前元素的值）</li>
<li>index（可选，当前元素在数组中的索引）</li>
<li>arr（可选，调用 filter 的数组对象本身）</li>
</ul>
</li>
<li><p>thisValue 可选，运行该函数的作用域对象，影响 “this” 的值。如果省略了 thisValue ，”this” 的值为 “undefined”。一般用不到该参数。</p>
</li>
</ol>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const oldArr &#x3D; [1,2,3,55,65,34];</span><br><span class="line">const newArr &#x3D; oldArr.filter((val) &#x3D;&gt; &#123;</span><br><span class="line">    return val &gt; 30;</span><br><span class="line">&#125;);</span><br><span class="line">5 document.write(newArr); &#x2F;&#x2F; 55,65,34</span><br></pre></td></tr></table></figure>
<h4 id="forEach-、reduce-、map-和-filter-异同"><a href="#forEach-、reduce-、map-和-filter-异同" class="headerlink" title="forEach() 、reduce()、map() 和 filter() 异同"></a>forEach() 、reduce()、map() 和 filter() 异同</h4><ol>
<li>都会对数组遍历</li>
<li>map() 和 filter() 返回一个经过处理的新数组（不会改变原数组），forEach() 返回 undefined，reduce() 返回一个经过计算的值</li>
</ol>
<h3 id="7-pop、push、shift-和-unshift"><a href="#7-pop、push、shift-和-unshift" class="headerlink" title="7.pop、push、shift 和 unshift"></a>7.pop、push、shift 和 unshift</h3><h4 id="arrayObject-pop"><a href="#arrayObject-pop" class="headerlink" title="arrayObject.pop()"></a>arrayObject.pop()</h4><p>移除 arrayObject 中的最后一个元素，并返回该元素，改变原数组</p>
<h4 id="arrayObject-push-item1-item2-…"><a href="#arrayObject-push-item1-item2-…" class="headerlink" title="arrayObject.push(item1,item2,….)"></a>arrayObject.push(item1,item2,….)</h4><p>将一个或多个参数 item 添加到数组 arrayObject 的尾部，改变原数组，并返回改变后的数组的长度</p>
<h4 id="arrayObject-shift"><a href="#arrayObject-shift" class="headerlink" title="arrayObject.shift()"></a>arrayObject.shift()</h4><p>移除 arrayObject 中的第一个元素，并返回该元素，改变原数组</p>
<h4 id="arrayObject-unshift-item1-item2-…"><a href="#arrayObject-unshift-item1-item2-…" class="headerlink" title="arrayObject.unshift(item1,item2,….)"></a>arrayObject.unshift(item1,item2,….)</h4><p>将一个或多个参数 item 添加到数组 arrayObject 的头部，改变原数组，并返回改变后的数组的长度</p>
<h3 id="8-every-和-some"><a href="#8-every-和-some" class="headerlink" title="8.every() 和 some()"></a>8.every() 和 some()</h3><h4 id="every"><a href="#every" class="headerlink" title="every()"></a>every()</h4><p>用于检测所有数组元素是否符合指定方法。如果数组中有一个元素不满足，剩余元素不再进行检测，直接返回 false。所有元素都满足则返回 true。</p>
<h4 id="some"><a href="#some" class="headerlink" title="some()"></a>some()</h4><p>用于检测数据中是否存在元素符合条件。如果有一个元素满足函数，剩余元素不再进行检测，直接返回 true。所有元素都不满足则返回 false。</p>
<h3 id="9-includes-、indexOf-和-lastIndexOf"><a href="#9-includes-、indexOf-和-lastIndexOf" class="headerlink" title="9.includes()、indexOf() 和 lastIndexOf()"></a>9.includes()、indexOf() 和 lastIndexOf()</h3><h4 id="includes-value"><a href="#includes-value" class="headerlink" title="includes(value)"></a>includes(value)</h4><p>判断数组中是否包含指定 value</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; [1, 4, 5, 6, &#39;abc&#39;]</span><br><span class="line">console.log(arr.includes(&#39;a&#39;)) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<h4 id="indexOf"><a href="#indexOf" class="headerlink" title="indexOf()"></a>indexOf()</h4><p>返回数组中第一个与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。</p>
<h4 id="lastIndexOf"><a href="#lastIndexOf" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h4><p>返回数组中最后一个（从右边数第一个）与指定值相等的元素的索引，如果找不到这样的元素，则返回 -1。</p>
<h3 id="10-Array-from-和-Array-of"><a href="#10-Array-from-和-Array-of" class="headerlink" title="10.Array.from() 和 Array.of()"></a>10.Array.from() 和 Array.of()</h3><h4 id="Array-from-v"><a href="#Array-from-v" class="headerlink" title="Array.from(v)"></a>Array.from(v)</h4><p>将伪数组对象或可遍历对象转换为真数组</p>
<h4 id="Array-of-v1-v2-v3"><a href="#Array-of-v1-v2-v3" class="headerlink" title="Array.of(v1, v2, v3)"></a>Array.of(v1, v2, v3)</h4><p>将一系列值转换成数组</p>
<h3 id="11-find-和-findIndex"><a href="#11-find-和-findIndex" class="headerlink" title="11.find() 和 findIndex()"></a>11.find() 和 findIndex()</h3><h4 id="find-function-value-index-arr-return-true"><a href="#find-function-value-index-arr-return-true" class="headerlink" title="find(function(value, index, arr) {return true})"></a>find(function(value, index, arr) {return true})</h4><p>找出第一个满足条件返回 true 的元素</p>
<h4 id="findIndex-function-value-index-arr-return-true"><a href="#findIndex-function-value-index-arr-return-true" class="headerlink" title="findIndex(function(value,index,arr) {return true})"></a>findIndex(function(value,index,arr) {return true})</h4><p>找出第一个满足条件返回 true 的元素下标</p>
<h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="1-charAt-、charCodeAt-和-formCharCode"><a href="#1-charAt-、charCodeAt-和-formCharCode" class="headerlink" title="1.charAt()、charCodeAt() 和 formCharCode()"></a>1.charAt()、charCodeAt() 和 formCharCode()</h3><h4 id="charAt"><a href="#charAt" class="headerlink" title="charAt()"></a>charAt()</h4><p>用于返回指定索引处的字符。返回的字符是长度为 1 的字符串。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str&#x3D;&quot;fighting 2020!&quot;;</span><br><span class="line">str.charAt(3); &#x2F;&#x2F; h</span><br></pre></td></tr></table></figure>
<h4 id="charCodeAt"><a href="#charCodeAt" class="headerlink" title="charCodeAt()"></a>charCodeAt()</h4><p>可返回指定位置的字符的 Unicode 编码。这个返回值是 0 - 65535 之间的整数。</p>
<blockquote>
<p>语法：stringObject.charCodeAt(index)</p>
<p>index 必需，表示字符串中某个位置的数字，即字符在字符串中的下标。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;Hello world!&quot;;</span><br><span class="line">str.charCodeAt(1); &#x2F;&#x2F; 101</span><br></pre></td></tr></table></figure>
<h4 id="formCharCode"><a href="#formCharCode" class="headerlink" title="formCharCode()"></a>formCharCode()</h4><p>接受一个指定的 Unicode 值，然后返回一个字符串。</p>
<blockquote>
<p>语法：String.fromCharCode(numX,numX,…,numX)</p>
<p>numX 必需，一个或多个 Unicode 值，即要创建的字符串中的字符的 Unicode 编码。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">String.fromCharCode(72,69,76,76,79) &#x2F;&#x2F; HELLO</span><br><span class="line">String.fromCharCode(65,66,67) &#x2F;&#x2F; ABC</span><br></pre></td></tr></table></figure>
<h3 id="2-indexOf-、lastIndexOf-和-includes"><a href="#2-indexOf-、lastIndexOf-和-includes" class="headerlink" title="2.indexOf()、lastIndexOf() 和 includes()"></a>2.indexOf()、lastIndexOf() 和 includes()</h3><h4 id="indexOf-1"><a href="#indexOf-1" class="headerlink" title="indexOf()"></a>indexOf()</h4><p>从字符串对象中返回首个被发现的给定值的索引值，如果没有找到则返回-1。</p>
<blockquote>
<p>语法：<code>stringObject.indexOf(str,startpos)</code></p>
<p>str 必需，给定的需要检索的字符串</p>
<p>startpos 可选的整数参数，规定在字符串中开始检索的位置。它的合法取值是 0 到 stringObject.length - 1。如省略该参数，则将从字符串的首字符开始检索。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;fighting 2020!&quot;;</span><br><span class="line">str.indexOf(&#39;i&#39;,2); &#x2F;&#x2F; 5</span><br></pre></td></tr></table></figure>
<h4 id="lastIndexOf-1"><a href="#lastIndexOf-1" class="headerlink" title="lastIndexOf()"></a>lastIndexOf()</h4><p>从字符串对象中返回最后一个被发现的给定值的索引值，如果没有找到则返回-1。</p>
<h4 id="includes-str"><a href="#includes-str" class="headerlink" title="includes(str)"></a>includes(str)</h4><p>判断是否包含指定的字符串</p>
<h3 id="3-split"><a href="#3-split" class="headerlink" title="3.split()"></a>3.split()</h3><p>将字符串分割成字符串数组，并返回此数组。</p>
<blockquote>
<p>语法：stringObject.split(separator,limit)</p>
<p>separator 必需，从该参数指定的地方分割。 limit 可选，分割的次数。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;fighting 2020 !&quot;;</span><br><span class="line">var a &#x3D; str.split(&#39; &#39;, 3) &#x2F;&#x2F; [&quot;fighting&quot;, &quot;2020&quot;, &quot;!&quot;]</span><br></pre></td></tr></table></figure>
<h3 id="4-substring-、substr-和-slice"><a href="#4-substring-、substr-和-slice" class="headerlink" title="4.substring()、substr() 和 slice()"></a>4.substring()、substr() 和 slice()</h3><h4 id="substring"><a href="#substring" class="headerlink" title="substring()"></a>substring()</h4><p>用于提取字符串中介于两个指定下标之间的字符，其内容是 start 处到 stop-1 处的所有字符，其长度为 stop 减 start。</p>
<blockquote>
<p>语法：stringObject.substring(start, stop)</p>
<p>start 必需，一个非负的整数，规定要提取的子串的第一个字符在 stringObject 中的位置。</p>
<p>stop 可选，一个非负的整数，比要提取的子串的最后一个字符在 stringObject 中的位置多 1。如果省略该参数，那么返回的子串会一直到字符串的结尾。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;fighting 2020!&quot;;</span><br><span class="line">str.substring(5) &#x2F;&#x2F; ing 2020!</span><br><span class="line">str.substring(3,5) &#x2F;&#x2F; ht</span><br></pre></td></tr></table></figure>
<h4 id="substr"><a href="#substr" class="headerlink" title="substr()"></a>substr()</h4><p>在字符串中抽取从 start 下标开始的指定数目的字符。</p>
<blockquote>
<p>语法：stringObject.substr(start,length)</p>
<p>start 必需，要抽取的子串的起始下标。必须是数值。如果是负数，那么该参数声明从字符串的尾部开始算起的位置。也就是说，-1 指字符串中最后一个字符，-2 指倒数第二个字符，以此类推。</p>
<p>length 可选，必须是数值。如果省略了该参数，那么返回从 <em>stringObject</em> 的开始位置到结尾的字串。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;fighting 2020!&quot;;</span><br><span class="line">str.substring(3,5) &#x2F;&#x2F; ht</span><br><span class="line">str.substr(3,5) &#x2F;&#x2F; hting</span><br><span class="line">str.substr(-5,5) &#x2F;&#x2F; 2020!</span><br></pre></td></tr></table></figure>
<h4 id="slice-1"><a href="#slice-1" class="headerlink" title="slice()"></a>slice()</h4><p>可提取字符串的某个部分，并以新的字符串返回被提取的部分。(与 array 中的相似)</p>
<h4 id="slice-、substr-与-substring-的异同："><a href="#slice-、substr-与-substring-的异同：" class="headerlink" title="slice()、substr() 与 substring() 的异同："></a>slice()、substr() 与 substring() 的异同：</h4><ol>
<li>slice()、substring() 和 substr() （不建议使用）都可返回字符串的指定部分</li>
<li>slice() 和 substring() 的参数都是 start end，但是 substr() 的第二个参数是 length。</li>
<li>slice() 和 substr() 允许使用负数作为参数，但 substring() 不可以。</li>
<li>还要注意的是，String.slice() 与 Array.slice() 相似。</li>
</ol>
<h3 id="5-replace"><a href="#5-replace" class="headerlink" title="5.replace()"></a>5.replace()</h3><p>用于在字符串中用一些字符替换掉另一些字符，或替换掉一个与正则表达式匹配的子串。<strong>返回经过替换操作后形成的新的字符串，不改变原字符串</strong>。</p>
<blockquote>
<p>语法：stringObject.replace(regexp/substr,newsubstr/function)</p>
<p>regexp/substr 必需，规定要替换掉的子字符串或要替换掉的模式的 RegExp 对象。</p>
<p>newsubstr/function 必需，规定了替换文本或生成替换文本的函数。</p>
<p>当为 stringObject.replace(substr,newsubstr) 时，只能替换掉<strong>第一次匹配</strong>的 substr；</p>
<p>stringObject.replace(regexp,newsubstr/function) 时，若 reg 有全局标志 g，则才替换所有匹配的子串。</p>
<p>注意：<code>stringObject.replace(regexp,function($,$1,$2...))</code>，<code>$</code>为匹配正则表达式的子串内容，<code>$1</code>、<code>$2</code>为捕获组对应的内容。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;fighting 2020!&quot;;</span><br><span class="line"></span><br><span class="line">str.replace(&#x2F;fighting&#x2F;, &#39;hello&#39;) &#x2F;&#x2F; hello 2020!</span><br><span class="line">str.replace(&#x2F;(\w+)\s*(\w+)&#x2F;, &quot;$2 $1&quot;) &#x2F;&#x2F; 2020 fighting!</span><br><span class="line"></span><br><span class="line">var name &#x3D; &quot;Doe  , John&quot;;</span><br><span class="line">name.replace(&#x2F;(\w+)\s*,\s*(\w+)&#x2F;, &quot;$2, $1&quot;) &#x2F;&#x2F; John, Doe</span><br></pre></td></tr></table></figure>
<h3 id="6-concat"><a href="#6-concat" class="headerlink" title="6.concat()"></a>6.concat()</h3><p>方法用于连接两个或多个字符串（stringObject.concat() 与 Array.concat() 很相似。）</p>
<h3 id="7-startsWith-、endsWith-和-repeat"><a href="#7-startsWith-、endsWith-和-repeat" class="headerlink" title="7.startsWith()、endsWith() 和 repeat()"></a>7.startsWith()、endsWith() 和 repeat()</h3><h4 id="startsWith-str-：判断是否以指定字符串开头"><a href="#startsWith-str-：判断是否以指定字符串开头" class="headerlink" title="startsWith(str)：判断是否以指定字符串开头"></a>startsWith(str)：判断是否以指定字符串开头</h4><h4 id="endsWith-str-：判断是否以指定字符串结尾"><a href="#endsWith-str-：判断是否以指定字符串结尾" class="headerlink" title="endsWith(str)：判断是否以指定字符串结尾"></a>endsWith(str)：判断是否以指定字符串结尾</h4><h4 id="repeat-count-：重复指定次数"><a href="#repeat-count-：重复指定次数" class="headerlink" title="repeat(count)：重复指定次数"></a>repeat(count)：重复指定次数</h4><h3 id="8-match-和-search"><a href="#8-match-和-search" class="headerlink" title="8.match() 和 search()"></a>8.match() 和 search()</h3><h4 id="match-searchvalue-Regexp"><a href="#match-searchvalue-Regexp" class="headerlink" title="match(searchvalue/Regexp)"></a>match(searchvalue/Regexp)</h4><p>只接受一个参数，由字符串或 RegExp 对象指定的一个正则表达式 ，返回存放结果的数组</p>
<h4 id="search-searchvalue-Regexp"><a href="#search-searchvalue-Regexp" class="headerlink" title="search(searchvalue/Regexp)"></a>search(searchvalue/Regexp)</h4><p>返回第一个与 regexp 相匹配的子串的起始位置。不执行全局匹配，它将忽略标志 g，总是从字符串的开始进行检索。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>string 和 array 都有的方法：concat slice indexOf lastIndexOf includes</p>
<p>只在 array 中有：join splice reverse sort</p>
<p>只在 string 中有：split</p>
<h2 id="Object-对象方法"><a href="#Object-对象方法" class="headerlink" title="Object 对象方法"></a>Object 对象方法</h2><p>Object.create()：使用指定的原型对象和属性创建一个新对象。</p>
<p>Object.assign(target,source1,source2..)：将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p>
<p>Object.defineProperty()：给对象添加一个属性并指定该属性的配置。</p>
<p>Object.getOwnPropertyDescriptor()：返回对象指定的属性配置。</p>
<p>Object.getOwnPropertyNames()：返回一个数组，它包含了指定对象所有的可枚举或不可枚举的属性名。</p>
<p>Object.is(v1,v2)：比较两个值是否相同（是以类型和字符串来判断的）。所有 NaN 值都相等（这与==和===不同）。</p>
<p>Object.keys()：返回一个所有元素为字符串的数组，其元素来自于从给定的<code>object</code>上面可直接枚举的属性。</p>
<p>Object.values()：返回一个给定对象自身的所有可枚举属性值的数组。</p>
<h2 id="Math"><a href="#Math" class="headerlink" title="Math"></a>Math</h2><h3 id="1-ceil-、floor-、-round-和-trunc"><a href="#1-ceil-、floor-、-round-和-trunc" class="headerlink" title="1.ceil()、floor() 、 round() 和 trunc()"></a>1.ceil()、floor() 、 round() 和 trunc()</h3><h4 id="ceil-：对一个数进行向上取整"><a href="#ceil-：对一个数进行向上取整" class="headerlink" title="ceil()：对一个数进行向上取整"></a>ceil()：对一个数进行向上取整</h4><p>语法：Math.ceil(x) 返回大于等于 x 并且与 x 最接近的整数</p>
<h4 id="floor-：对一个数进行向下取整"><a href="#floor-：对一个数进行向下取整" class="headerlink" title="floor()：对一个数进行向下取整"></a>floor()：对一个数进行向下取整</h4><p>语法：Math.floor(x) 返回小于等于 x 并且与 x 最接近的整数</p>
<h4 id="round-：对一个数进行四舍五入取整"><a href="#round-：对一个数进行四舍五入取整" class="headerlink" title="round()：对一个数进行四舍五入取整"></a>round()：对一个数进行四舍五入取整</h4><p>语法：Math.round(x) 返回最接近 x 的整数</p>
<h4 id="Math-trunc-：直接去除小数部分"><a href="#Math-trunc-：直接去除小数部分" class="headerlink" title="Math.trunc()：直接去除小数部分"></a>Math.trunc()：直接去除小数部分</h4><h3 id="2-random"><a href="#2-random" class="headerlink" title="2.random()"></a>2.random()</h3><p>返回介于 0 ~ 1 之间的一个随机数，不包括 0 和 1</p>
<p>语法：Math.random() 返回 0.0 ~ 1.0 之间的一个随机数。</p>
<blockquote>
<p>如果想大于这个范围的话，可以套用一下公式：</p>
<p> 值 = Math.floor(Math.random() * 总数 + 第一个值)</p>
<p>比如：Math.floor(Math.random() * 10 + 1) 表示随机产生一个 1~10 的整数</p>
</blockquote>
<h3 id="3-max-和-min"><a href="#3-max-和-min" class="headerlink" title="3.max() 和 min()"></a>3.max() 和 min()</h3><h4 id="max"><a href="#max" class="headerlink" title="max()"></a>max()</h4><p>返回指定的数中带有较大的值的那个数</p>
<p>语法：Math.max(x1,x2,…..) 返回 x1,x2,…..中带有最高值的数字，如果有某个参数为 NaN，或是不能转换成数字的非数字值，则返回 NaN。</p>
<h4 id="min"><a href="#min" class="headerlink" title="min()"></a>min()</h4><p>返回指定的数中带有较小的值的那个数</p>
<p>语法：Math.min(x1,x2,……) 返回 x1,x2,…..中带有最小值的数字，如果有某个参数为 NaN，或是不能转换成数字的非数字值，则返回 NaN。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Math.ceil(3.2);&#x2F;&#x2F;4</span><br><span class="line">Math.floor(3.7);&#x2F;&#x2F;3</span><br><span class="line">Math.round(3.5);&#x2F;&#x2F;4</span><br><span class="line">Math.trunc(123.123);&#x2F;&#x2F;123</span><br><span class="line">Math.random();&#x2F;&#x2F;一个随机数</span><br><span class="line">Math.max(3,6,6.2);&#x2F;&#x2F;6.2</span><br><span class="line">Math.min(3,4,34);&#x2F;&#x2F;3</span><br></pre></td></tr></table></figure>
<h2 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h2><ol>
<li>Number.isFinite(i)：判断是否是有限大的数</li>
<li>Number.isNaN(i)：判断是否是 NaN</li>
<li>Number.isInteger(i)：判断是否是整数</li>
<li>Number.parseInt(str)：将字符串转换为对应的数值</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>执行异步</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/7.%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<p>一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。</p>
<p>采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p>
<p>宏观任务的队列就相当于事件循环。</p>
<p>在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列。</p>
<p>Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。</p>
<a id="more"></a>

<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise是JS的一种标准化异步管理方式。总体思想是：</p>
<p>需要进行io、等待或其它异步操作的函数，不返回真实结果，而返回一个”承诺“。函数的调用方可以在合适的时机选择等待这个承诺兑现（通过Promise的then方法的回调）。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resole, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;finished&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>Promise 的 then 回调是一个异步的执行过程，下面我们就来研究一下 Promise 函数中的执行顺序。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>); </span><br><span class="line"> resolve() </span><br><span class="line">&#125;); </span><br><span class="line">r.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>); <span class="comment">//输出a,b,c</span></span><br></pre></td></tr></table></figure>
<p>在 console.log(“b”) 之前， r 已经得到了 resolve，但是 Promise 的 resolve 是异步操作，所以 c 无法出现在 b 之前。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&quot;d&quot;</span>), <span class="number">0</span>)</span><br><span class="line">r.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>) <span class="comment">//输出a，b，c，d</span></span><br></pre></td></tr></table></figure>
<p>不论代码顺序如何，d 必定发生在 c 之后，因为 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。微任务始终先于宏任务。</p>
<p>总结一下如何分析异步执行的顺序：</p>
<ul>
<li>首先我们分析有多少个宏任务；</li>
<li>在每个宏任务中，分析有多少个微任务；</li>
<li>根据调用次序，确定宏任务中的微任务执行次序；</li>
<li>根据宏任务的触发规则和调用次序，确定宏任务的执行次序；</li>
<li>确定整个顺序。</li>
</ul>
<h2 id="新特性：async-await"><a href="#新特性：async-await" class="headerlink" title="新特性：async/await"></a>新特性：async/await</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve,duration);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//输出a,c,2s后输出b</span></span><br></pre></td></tr></table></figure>
<p>async 函数强大之处在于，它是可以嵌套的<br>一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。</p>
<p>采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p>
<p>宏观任务的队列就相当于事件循环。</p>
<p>在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列。</p>
<p>Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。</p>
<h2 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h2><p>Promise是JS的一种标准化异步管理方式。总体思想是：</p>
<p>需要进行io、等待或其它异步操作的函数，不返回真实结果，而返回一个”承诺“。函数的调用方可以在合适的时机选择等待这个承诺兑现（通过Promise的then方法的回调）。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resole, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;finished&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>Promise 的 then 回调是一个异步的执行过程，下面我们就来研究一下 Promise 函数中的执行顺序。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>); </span><br><span class="line"> resolve() </span><br><span class="line">&#125;); </span><br><span class="line">r.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>); <span class="comment">//输出a,b,c</span></span><br></pre></td></tr></table></figure>
<p>在 console.log(“b”) 之前， r 已经得到了 resolve，但是 Promise 的 resolve 是异步操作，所以 c 无法出现在 b 之前。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&quot;d&quot;</span>), <span class="number">0</span>)</span><br><span class="line">r.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>) <span class="comment">//输出a，b，c，d</span></span><br></pre></td></tr></table></figure>
<p>不论代码顺序如何，d 必定发生在 c 之后，因为 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。微任务始终先于宏任务。</p>
<p>总结一下如何分析异步执行的顺序：</p>
<ul>
<li>首先我们分析有多少个宏任务；</li>
<li>在每个宏任务中，分析有多少个微任务；</li>
<li>根据调用次序，确定宏任务中的微任务执行次序；</li>
<li>根据宏任务的触发规则和调用次序，确定宏任务的执行次序；</li>
<li>确定整个顺序。</li>
</ul>
<h2 id="新特性：async-await-1"><a href="#新特性：async-await-1" class="headerlink" title="新特性：async/await"></a>新特性：async/await</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve,duration);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//输出a,c,2s后输出b</span></span><br></pre></td></tr></table></figure>
<p>async 函数强大之处在于，它是可以嵌套的</p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>对象分类</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/5.%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>对象可以分成几类：</p>
<ul>
<li>宿主对象：JS 宿主环境提供的对象，行为完全由素质环境决定。</li>
<li>内置对象：JS 提供的对象。<ul>
<li>固有对象：由标准规定，随着 JS 运行时创建而自动创建的对象实例。</li>
<li>原生对象：用户可以通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</li>
<li>普通对象：由{}语法、Object 构造器或者 class 关键字定义的对象，能被原型继承。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="宿主对象"><a href="#宿主对象" class="headerlink" title="宿主对象"></a>宿主对象</h2><p>浏览器环境中的宿主：全局对象是 window，window 上的属性一部分来自 JS，一部分来自浏览器环境。</p>
<h2 id="内置对象·固有对象"><a href="#内置对象·固有对象" class="headerlink" title="内置对象·固有对象"></a>内置对象·固有对象</h2><p>固有对象在 js 代码执行前就已经被创建了，它们扮演着类似基础库的角色。“类”就是固有对象的一种。</p>
<h2 id="内置对象·原生对象"><a href="#内置对象·原生对象" class="headerlink" title="内置对象·原生对象"></a>内置对象·原生对象</h2><p>js 中能够通过语言本身的构造器创建的对象。</p>
<p>js 提供了 30 多个<strong>构造器</strong>（内置对象），分成以下几个种类：</p>
<img src="https://static001.geekbang.org/resource/image/6c/d0/6cb1df319bbc7c7f948acfdb9ffd99d0.png" style="width: 100%;">

<p>通过这些构造器，我们可以用 new 运算创建新的对象。这些构造器就是原生对象。</p>
<p>几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承。</p>
<p>这些字段使得原型继承方法无法正常工作，所以，我们可以认为，所有这些原生对象都是为了特定能力或者性能，而设计出来的“<strong>特权对象</strong>”。</p>
<h2 id="用对象来模拟函数与构造器：函数对象与构造器对象"><a href="#用对象来模拟函数与构造器：函数对象与构造器对象" class="headerlink" title="用对象来模拟函数与构造器：函数对象与构造器对象"></a>用对象来模拟函数与构造器：函数对象与构造器对象</h2><p>函数对象的定义是：具有[[call]]私有字段的对象。</p>
<p>构造器对象的定义是：具有私有字段[[construct]]的对象。</p>
<p>任何对象只需要实现[[call]]，它就是一个函数对象，可以去作为函数被调用。而如果它能实现[[construct]]，它就是一个构造器对象，可以作为构造器被调用。</p>
<p>用户用 <strong>function</strong> 关键字创建的函数必定<strong>同时是函数和构造器</strong>。不过，它们表现出来的行为效果却并不相同。</p>
<p>对于用户使用 function 语法或者 Function 构造器创建的对象来说，[[call]]和[[construct]]行为总是相似的，它们执行同一段代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v = f(); <span class="comment">//把f作为函数调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> f(); <span class="comment">//把f作为构造器调用</span></span><br></pre></td></tr></table></figure>
<p>[[construct]]的执行过程如下：</p>
<ul>
<li>以 Object.prototype 为原型创建一个新对象；</li>
<li>以新对象为 this，执行函数的[[call]]；</li>
<li>如果[[call]]的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li>
</ul>
<p>这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cls</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">100</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回了一个新的对象</span></span><br><span class="line">        getValue:<span class="function">() =&gt;</span> &#123; <span class="comment">// 箭头函数的this继承外部函数的this</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> cls;</span><br><span class="line"><span class="built_in">console</span>.log(o.getValue()); <span class="comment">//100</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.a); <span class="comment">// 100</span></span><br><span class="line"><span class="comment">//这相当于一个闭包</span></span><br></pre></td></tr></table></figure>
<p>构造函数一般不应该用 return 来返回值。而这个构造函数 cls 用 return 来返回值。并且<strong>返回值是一个对象</strong>（函数也是对象）则会用这个对象代替自动创建的实例对象返回给 o。也就是说你设置的是实例对象的 a，返回给 o 的却是 getValue 一个箭头函数，箭头函数没有 a 属性。</p>
<p>如果想要访问 a 可以设置 getValue 为 cls 的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cls</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.getValue =<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> cls();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//100</span></span><br><span class="line"><span class="built_in">console</span>.log(o.getValue()); <span class="comment">//100</span></span><br></pre></td></tr></table></figure>
<h2 id="特殊行为的对象"><a href="#特殊行为的对象" class="headerlink" title="特殊行为的对象"></a>特殊行为的对象</h2><p>在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。</p>
<p>它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同。</p>
<ul>
<li>Array：Array 的 length 属性根据最大的下标自动发生变化。</li>
<li>Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。</li>
<li>String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。</li>
<li>Arguments：arguments 的非负整数型下标属性跟对应的变量联动。</li>
<li>模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li>
<li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li>
<li>bind 后的 function：跟原来的函数相关联。</li>
</ul>
<h2 id="创建对象的几种模式"><a href="#创建对象的几种模式" class="headerlink" title="创建对象的几种模式"></a>创建对象的几种模式</h2><h3 id="1、new-操作符-Object-创建对象"><a href="#1、new-操作符-Object-创建对象" class="headerlink" title="1、new 操作符 + Object 创建对象"></a>1、new 操作符 + Object 创建对象</h3><p>先创建空 Object 对象，再动态添加属性和方法</p>
<p><strong>适用场景：</strong>起始时不确定对象内部数据</p>
<p><strong>问题：</strong>语句太多</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">person.age = <span class="number">21</span>;</span><br><span class="line">person.family = [<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;wangwu&quot;</span>];</span><br><span class="line">person.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、字面式创建对象"><a href="#2、字面式创建对象" class="headerlink" title="2、字面式创建对象"></a>2、字面式创建对象</h3><p>使用 {} 创建对象，同时指定属性和方法</p>
<p><strong>适用场景：</strong>起始对象内部数据是确定的</p>
<p><strong>问题：</strong>如果创建多个对象时，会产生大量重复代码，为了解决此问题，工厂模式被开发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;lisi&quot;</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  family: [<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;wangwu&quot;</span>],</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// var o = function()&#123;&#125; 也可以</span></span><br></pre></td></tr></table></figure>
<h3 id="3、工厂模式"><a href="#3、工厂模式" class="headerlink" title="3、工厂模式"></a>3、工厂模式</h3><p>通过工厂函数动态创建对象并返回</p>
<p><strong>适用场景：</strong>需要创建多个对象</p>
<p><strong>问题：</strong>对象没有一个具体的类型，都是 Object 类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,family</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.family = family;</span><br><span class="line">    o.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  createPerson(<span class="string">&quot;lisi&quot;</span>,<span class="number">21</span>,[<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;wangwu&quot;</span>]);   <span class="comment">//instanceof无法判断它是谁的实例，只能判断他是对象，构造函数都可以判断出</span></span><br><span class="line"><span class="keyword">var</span> person2 =  createPerson(<span class="string">&quot;wangwu&quot;</span>,<span class="number">18</span>,[<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;lisi&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="4、构造函数模式"><a href="#4、构造函数模式" class="headerlink" title="4、构造函数模式"></a>4、构造函数模式</h3><p>自定义构造函数，通过 new 创建对象</p>
<p><strong>适用场景：</strong>需要创建多个类型确定的对象</p>
<p><strong>问题：</strong>每个对象都有相同的数据，浪费内存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,family</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.family = family;</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;lisi&quot;</span>,<span class="number">21</span>,[<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;wangwu&quot;</span>]);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;lisi&quot;</span>,<span class="number">21</span>,[<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;lisi&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor);      <span class="comment">//constructor 属性返回对创建此对象的构造函数的引用</span></span><br></pre></td></tr></table></figure>
<p>构造函数知道自己从哪里来（通过 instanceof 可以看出其既是 Object 的实例，又是 Person 的实例）</p>
<p>构造函数的缺陷是每个实例的方法是一样的但是每次 new 都会创建一个新的，浪费内存，因此产生了原型模式</p>
<h3 id="5、原型模式"><a href="#5、原型模式" class="headerlink" title="5、原型模式"></a>5、原型模式</h3><p><strong>好处</strong>：</p>
<p>方法是共享的了，所有的实例的方法都指向同一个。</p>
<p>问题：</p>
<p>1.<strong>引用类型</strong>的属性只要有一个实例对象修改了，其他也会跟着修改。因为所有实例对象的属性都是共用的。</p>
<p>2.所有都是共享的，没有办法创建实例自己的属性和方法，也没有办法像构造函数那样传递参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">21</span>;</span><br><span class="line">Person.prototype.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.family) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.family) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">person.arr.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.family) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.family) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h3 id="6、混合模式（构造函数模式-原型模式）"><a href="#6、混合模式（构造函数模式-原型模式）" class="headerlink" title="6、混合模式（构造函数模式+原型模式）"></a>6、混合模式（构造函数模式+原型模式）</h3><p><strong>优点</strong>：</p>
<ol>
<li>解决了原型模式没有办法传递参数的问题</li>
<li>保证了每个实例有自己的私有属性，解决了原型模式对于引用类型的属性的问题</li>
<li>通过原型链<code>__proto__</code>共享着对相同方法的引用，解决了构造函数模式不能共享方法的问题，最大限度的节省了内存。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,family</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.family = family;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;lisi&quot;</span>,<span class="number">21</span>,[<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;wangwu&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(person1); <span class="comment">// &#123;name: &quot;lisi&quot;, age: 21, family: Array(3)&#125;</span></span><br><span class="line">person1.say(); <span class="comment">// lisi</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>,[<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;lisi&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(person2); <span class="comment">// &#123;name: &quot;wangwu&quot;, age: 22, family: Array(3)&#125;</span></span><br><span class="line">person2.say(); <span class="comment">// wangwu</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：在使用 prototype 的时候，不要用字面量的写法。否则，会重新生成一个新对象，切断与之前的联系。</p>
</blockquote>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现继承的几种方式</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/6.JS%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1、借助原型链实现继承"><a href="#1、借助原型链实现继承" class="headerlink" title="1、借助原型链实现继承"></a>1、借助原型链实现继承</h2><p> <strong>步骤</strong>：</p>
<p> 1）定义父类型构造函数</p>
<p> 2）给父类型的原型添加方法</p>
<p> 3）定义子类型的构造函数</p>
<p> 4）创建父类型的实例对象赋给子类型的原型</p>
<p> 5）将子类型原型的构造属性设置为子类型（没有这一步也不影响继承，但是 constructor 的指向是错误的）</p>
<p> 6）给子类型原型添加方法</p>
<p> 7）创建子类型的实例对象：可以调用父类型的方法</p>
<a id="more"></a>

<p> <strong>关键</strong>：<strong>将父类的一个实例对象作为子类的原型</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;wo&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.gender = <span class="string">&#x27;男&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;晚餐时间到&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent() <span class="comment">// 关键</span></span><br><span class="line">Child.prototype.constructor = Child <span class="comment">// 让子类型的原型的constructor指向子类型，否则它指向的是Parent</span></span><br><span class="line">Child.prototype.sleep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;睡觉时间到&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="number">30</span>)</span><br><span class="line">child.eat() <span class="comment">// 晚餐时间到，eat 继承自父类型的原型，在 child.__proto__.__proto__ 上</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child.list) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.list) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">child.list.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child.list) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.list) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p> <strong>缺点</strong>：</p>
<p> 因为 Child 的原型对象都是 New Parent，所以实例化出来的对象的属性都是一样的。Parent 上面的<strong>引用类型</strong>的属性只要有一个实例对象修改了，其他也会跟着修改。因为他们原型对象都是共用的。并且创建子类实例时，无法向父类构造函数传参。</p>
<h2 id="2、借助构造函数实现继承（call）"><a href="#2、借助构造函数实现继承（call）" class="headerlink" title="2、借助构造函数实现继承（call）"></a>2、借助构造函数实现继承（call）</h2><p> <strong>步骤</strong>：</p>
<p> 1）定义父类型构造函数</p>
<p> 2）定义子类型构造函数</p>
<p> 3）在子类型构造函数中调用 call 或 apply 把 Parent 的 this 指向改变为是 Child 的 this 指向。这样就可以实现复制父类的实例属性给子类。</p>
<p> <strong>关键</strong>：<strong>在子类型构造函数中通过 call 调用父类型构造函数</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name, age) <span class="comment">// 相当于将 this.name = name; this.age = age; 这两行代码放在这里执行</span></span><br><span class="line">  <span class="built_in">this</span>.gender = gender</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="string">&#x27;王&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child.name, child.age) <span class="comment">// 王, 20</span></span><br><span class="line">child.sayHi() <span class="comment">// Uncaught TypeError:child.sayHi is not a function</span></span><br></pre></td></tr></table></figure>
<p> <strong>优点</strong>：可以向父类传递参数，而且解决了原型链继承中父类属性使用 this 声明的引用类型属性会在所有实例共享的问题。</p>
<p> <strong>缺点</strong>：只能解决父类型上的属性和方法的继承，但是父类型原型上的不能继承</p>
<h2 id="3、组合式继承（原型链-构造函数）"><a href="#3、组合式继承（原型链-构造函数）" class="headerlink" title="3、组合式继承（原型链 + 构造函数）"></a>3、组合式继承（原型链 + 构造函数）</h2><p> 组合上述两种方法，用<strong>原型链</strong>实现对原型属性和方法的继承，用<strong>构造函数</strong>技术来实现实例属性的继承。（常用）</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name) <span class="comment">// 实现Parent属性&quot;name&quot;的继承</span></span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent() <span class="comment">// 实现子继承父的所有属性和方法包括原型上的</span></span><br><span class="line">Child.prototype.constructor = Child <span class="comment">// prototype构造器指回自己，否则构造函数指向的是Parent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Child(<span class="string">&#x27;wy&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">c.say() <span class="comment">// say</span></span><br></pre></td></tr></table></figure>
<p> <strong>优点</strong>：</p>
<p> 1)可以继承父类原型上的属性，可以传参，可复用。</p>
<p> 2)每个新子类对象实例引入的构造函数属性是私有的。</p>
<p> <strong>缺点</strong>：</p>
<p> 1)两次调用父类函数（new Parent() 和 Parent.call(this)），造成一定的性能损耗。</p>
<p> 2)在使用子类创建实例对象时，其原型中会存在两份相同属性/方法的问题。</p>
<h2 id="4、原型式继承（Object-create-）"><a href="#4、原型式继承（Object-create-）" class="headerlink" title="4、原型式继承（Object.create()）"></a>4、原型式继承（Object.create()）</h2><p> 是组合式的优化</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jacky&#x27;</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  courses: [<span class="string">&#x27;前端&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(Parent)</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="built_in">Object</span>.create(Parent)</span><br><span class="line">child.courses.push(<span class="string">&#x27;后端&#x27;</span>)</span><br><span class="line">child2.courses.push(<span class="string">&#x27;全栈&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.courses) <span class="comment">//  [&quot;前端&quot;, &quot;后端&quot;, &quot;全栈&quot;]</span></span><br></pre></td></tr></table></figure>
<p> <strong>优点</strong>：解决了组合式继承中，父类的构造函数被调用了两次，会产生两组相同属性，一组在实例上 一组在原型上的问题。</p>
<p> <strong>缺点</strong>：与原型链继承一样。多个实例共享被继承对象的属性，存在篡改的可能。</p>
<h3 id="Object-create-也可以替换为-ES5-的写法"><a href="#Object-create-也可以替换为-ES5-的写法" class="headerlink" title="Object.create() 也可以替换为 ES5 的写法"></a>Object.create() 也可以替换为 ES5 的写法</h3> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 创建一个空的构造函数</span></span><br><span class="line">    F.prototype = o <span class="comment">// 原型指向o</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F() <span class="comment">// 返回的是new构造函数的实例对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加上构造函数的另一种写法"><a href="#加上构造函数的另一种写法" class="headerlink" title="加上构造函数的另一种写法"></a>加上构造函数的另一种写法</h3><p> 仅仅就是把组合式中的 new Parent() 替换为了原型式 Object.create()，这样就解决了引用类型值的属性会共享的问题</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, courses</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.courses = courses</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age, courses</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name, courses)</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype) <span class="comment">// 用Object.create复制了Parent的原型到Child的原型上</span></span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Child(<span class="string">&#x27;wy&#x27;</span>, <span class="number">18</span>, [<span class="number">1</span>])</span><br><span class="line"><span class="keyword">const</span> c2 = <span class="keyword">new</span> Child(<span class="string">&#x27;woo&#x27;</span>, <span class="number">18</span>, [<span class="number">1</span>])</span><br><span class="line"><span class="built_in">console</span>.log(c.courses) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.courses) <span class="comment">// [1]</span></span><br><span class="line">c.courses.push(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c.courses) <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.courses) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
<h2 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h2><p> 仅仅在原型式继承的基础上，创建一个封装继承过程的函数（创建、增强、返回）</p>
<p> 使用场景：专门为对象来做某种固定方式的增强。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(o)</span><br><span class="line">  clone.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 增加的新的方法和属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jacky&#x27;</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  courses: [<span class="string">&#x27;前端&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = createAnother(Parent)</span><br><span class="line"><span class="keyword">var</span> child2 = createAnother(Parent)</span><br><span class="line">child.courses.push(<span class="string">&#x27;后端&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.courses) <span class="comment">//  [&quot;前端&quot;, &quot;后端&quot;]</span></span><br><span class="line">child2.say() <span class="comment">// say</span></span><br></pre></td></tr></table></figure>
<p> <strong>优点</strong>：没有创建自定义构造函数类型，因为只是套了个壳子增加特定属性/方法返回对象，以达到增强对象的目的</p>
<p> <strong>缺点</strong>：同原型链继承相同，多个实例的引用类型属性指向相同，存在篡改的可能，也无法传递参数</p>
<h2 id="6、寄生-组合式继承"><a href="#6、寄生-组合式继承" class="headerlink" title="6、寄生-组合式继承"></a>6、寄生-组合式继承</h2><p> 借用<strong>寄生式</strong>实现封装，<strong>组合式</strong>实现继承。（<strong>构造函数</strong>（call）传递参数并实现继承父类自身属性/方法+ <strong>原型式</strong>（Object.create()）实现继承父类原型的属性/方法）</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name) <span class="comment">// 借用构造函数继承：继承父类通过this声明的属性和方法至子类实例的属性上</span></span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄生式继承：封装了child.prototype对象原型式继承parent.prototype的过程，并且增强了传入的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(parent.prototype) <span class="comment">// 原型式继承：浅拷贝parent原型对象到clone的隐式原型上</span></span><br><span class="line">    clone.constructor = child <span class="comment">// 增强对象，弥补child因重写原型而失去的默认的constructor属性</span></span><br><span class="line">    child.prototype = clone <span class="comment">// 将新创建的拷贝的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Child, Parent); <span class="comment">// 子类原型继承父类原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性，必须在执行过继承函数inheritPrototype之后</span></span><br><span class="line">Child.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;eat&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="string">&#x27;wy&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">c.say() <span class="comment">// say</span></span><br><span class="line">c.eat() <span class="comment">// eat</span></span><br><span class="line"><span class="comment">// c.__proto__ = clone</span></span><br><span class="line"><span class="comment">// clone.__proto__ = Parent.prototype</span></span><br></pre></td></tr></table></figure>
<p> <strong>优点</strong>：</p>
<p> 1）只调用一次父类 Parent 构造函数。不必为了指定子类的原型而调用构造函数，而是间接的使用原型式继承 Object.create 让 Parent.prototype 赋给 Child.prototype。保持了原型链上下文不变， instanceof 和 isPrototypeOf() 也能正常使用。</p>
<p> 2）避免在子类 prototype 上创建多余的属性（父类自身属性 name）。</p>
<p> 3）寄生组合式继承是最成熟的继承方法，也是现在最常用的继承方法，众多 JS 库采用的继承方案也是它。</p>
<p> 还可以这样写：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">  <span class="title">constructor</span>: &#123;</span><br><span class="line">    value: Child, <span class="comment">// constructor指回Child</span></span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="7、ES6-extends-继承（最优方式）"><a href="#7、ES6-extends-继承（最优方式）" class="headerlink" title="7、ES6 extends 继承（最优方式）"></a>7、ES6 extends 继承（最优方式）</h2> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">skill</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;父类的技能&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age, job</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age) <span class="comment">// 调用父类的constructor，只有调用super之后，才可以使用this关键字</span></span><br><span class="line">    <span class="built_in">this</span>.job = job</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age, <span class="built_in">this</span>.job)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;jacky&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;前端开发&#x27;</span>)</span><br><span class="line">son.skill() <span class="comment">// 父类的技能</span></span><br><span class="line">son.getInfo() <span class="comment">// jacky 22 前端开发</span></span><br></pre></td></tr></table></figure>
<p> 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。因为子类没有自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="ES5-继承"><a href="#ES5-继承" class="headerlink" title="ES5 继承"></a>ES5 继承</h3><ol>
<li><p>借助原型链实现继承：<code>Child.prototype = new Parent()</code></p>
</li>
<li><p>借助构造函数实现继承：<code>Parent.call(this)</code></p>
</li>
<li><p>组合式继承：综合上面两种方式，既有 <code>Child.prototype = new Parent()</code> 又有 <code>Parent.call(this)</code></p>
</li>
<li><p>原型式继承：优化版组合式，将 <code>new Parent()</code> 改为 <code>Object.create(Parent.prototype)</code></p>
</li>
<li><p>寄生式继承：在原型式外面套了个函数壳子（创建、增强、返回）</p>
</li>
<li><p>寄生-组合式：寄生式 + 构造函数的 call + 原型式的 Object.create()</p>
<h3 id="ES5-继承与-ES6-继承的区别"><a href="#ES5-继承与-ES6-继承的区别" class="headerlink" title="ES5 继承与 ES6 继承的区别"></a>ES5 继承与 ES6 继承的区别</h3></li>
<li><p>ES5 的继承实质上是先创建子类的实例对象，再将父类的方法添加到 this 上( Father.call(this) )。</p>
</li>
<li><p>ES6 的继承是先创建父类的实例对象 this，再用子类的构造函数修改 this。</p>
</li>
<li><p>因为子类没有自己的 this 对象，所以必须先调用父类的 super() 方法。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的异步操作</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/8.JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>先执行func1()，执行成功后callback()告知，再执行func2()。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    (callback &amp;&amp; <span class="keyword">typeof</span>(callback)===<span class="string">&#x27;function&#x27;</span>) &amp;&amp; callback();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">func1(func2);</span><br><span class="line"><span class="comment">//1 2</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>异步回调中最常见的形式是Ajax。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">&quot;/getmsg&quot;</span>,</span><br><span class="line">    type: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; ret.status) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">&#x27;Event&#x27;</span>);</span><br><span class="line">event.initEvent(<span class="string">&#x27;myEvent&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>); <span class="comment">// 定义事件名称myEvent</span></span><br><span class="line">elem.addEventListener(<span class="string">&#x27;myEvent&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">// 监听myEvent</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;触发事件&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">elem.dispatchEvent(event);  <span class="comment">// 使用目标对象去派发事件，可以是元素节点/事件对象</span></span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line"><span class="comment">//[object Event]</span></span><br></pre></td></tr></table></figure>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>它定义对象间的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发布-订阅</span></span><br><span class="line"><span class="comment">//有个消息池，存放所有消息</span></span><br><span class="line"><span class="keyword">let</span> pubsub = &#123;&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">myObj</span>) </span>&#123;</span><br><span class="line">    topics = &#123;&#125;</span><br><span class="line">    subId = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//发布者接受参数(消息名称，参数)</span></span><br><span class="line">    myObj.publish = <span class="function"><span class="keyword">function</span>(<span class="params">topic, msg</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//如果发布的该消息没有订阅者，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (!topics[topic]) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对该消息的所有订阅者，遍历去执行各自的回调函数</span></span><br><span class="line">            <span class="keyword">let</span> subs = topics[topic]</span><br><span class="line">            subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">                sub.func(topic, msg)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//订阅者接受参数：（消息名称，回调函数）</span></span><br><span class="line">    myObj.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">topic, func</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//如果订阅的该事件还未定义，初始化</span></span><br><span class="line">        <span class="keyword">if</span> (!topics[topic]) &#123;</span><br><span class="line">            topics[topic] = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用不同的token来作为订阅者的索引</span></span><br><span class="line">        <span class="keyword">let</span> token = (++subId).toString()</span><br><span class="line">        topics[topic].push(&#123;</span><br><span class="line">                token: token,</span><br><span class="line">                func: func</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line">    &#125;</span><br><span class="line">    myObj.unsubscribe = <span class="function"><span class="keyword">function</span>(<span class="params">token</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//对消息列表遍历查找该token是哪个消息中的哪个订阅者</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> t <span class="keyword">in</span> topics) &#123;</span><br><span class="line">            <span class="comment">//如果某个消息没有订阅者，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (!topics[t]) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#125;</span><br><span class="line">            topics[t].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub,index</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (sub.token === token) &#123;</span><br><span class="line">                    <span class="comment">//找到了，从订阅者的数组中去掉该订阅者</span></span><br><span class="line">                    topics[t].splice(index, <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(pubsub)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub1 = pubsub.subscribe(<span class="string">&#x27;Msg::Name&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">topic, msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;event is :&quot;</span> + topic + <span class="string">&quot;; data is :&quot;</span> + msg)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> sub2 = pubsub.subscribe(<span class="string">&#x27;Msg::Name&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">topic, msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this is another subscriber, data is :&quot;</span> + msg)</span><br><span class="line">&#125;);</span><br><span class="line">pubsub.publish(<span class="string">&#x27;Msg::Name&#x27;</span>, <span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pubsub.unsubscribe(sub2)</span><br><span class="line">pubsub.publish(<span class="string">&#x27;Msg::Name&#x27;</span>, <span class="string">&#x27;456&#x27;</span>)</span><br><span class="line"><span class="comment">//&gt; event is :Msg::Name; data is :123</span></span><br><span class="line"><span class="comment">//&gt; this is another subscriber, data is :123</span></span><br><span class="line"><span class="comment">//&gt; event is :Msg::Name; data is :456</span></span><br></pre></td></tr></table></figure>
<p>其中存储消息的结构用json可以表示为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">topics = &#123;</span><br><span class="line">  Msg::Name: [&#123;</span><br><span class="line">    token: <span class="number">0</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params">topic, msg</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;event is :&quot;</span> + topic + <span class="string">&quot;; data is :&quot;</span> + msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    token: <span class="number">1</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params">topic, msg</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;this is another subscriber, data is :&quot;</span> + msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  topic2: [&#123; <span class="attr">token</span>: <span class="number">2</span>, <span class="attr">func</span>: callback3 &#125;, &#123; <span class="attr">token</span>: <span class="number">3</span>, <span class="attr">func</span>: callback4 &#125;],</span><br><span class="line">  topic3: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息池的结构是发布订阅模式与事件监听模式的最大区别。每个消息也可以看做是一个个的事件，topics对象就相当于一个事件处理中心，每个事件都有各自的订阅者。<em>事件监听其实就是发布订阅模式的一个简化版本。</em></p>
<p>而发布订阅模式的优点就是我们可以查看消息中心的信息，了解有多少信号，每个信号有多少订阅者。</p>
<h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><p>很多情况下，我们都将观察者模式和发布-订阅模式混为一谈，因为都可用来进行异步通信，实现代码的解耦，而不再细究其不同，但是内部实现还是有很多不同的。</p>
<ol>
<li><strong>整体模型</strong>的不同：发布订阅模式是靠信息池作为发布者和订阅者的中转站的，订阅者订阅的是信息池中的某个信息；而观察者模式是直接将订阅者订阅到发布者内部的，目标对象需要负责维护观察者，也就是观察者模式中订阅者是依赖发布者的。</li>
<li><strong>触发回调的方式</strong>不同：发布-订阅模式中，订阅者通过监听特定消息来触发回调；而观察者模式是发布者暴露一个接口(方法)，当目标对象发生变化时调用此接口，以保持自身状态的及时改变。</li>
</ol>
<p>观察者模式很好的应用是MVC架构，当数据模型更新时，视图也发生变化。从数据模型中将视图解耦出来，从而减少了依赖。但是当观察者数量上升时，性能会有显著下降。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//观察者模式</span></span><br><span class="line"><span class="keyword">var</span> Subject=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.observers=[];</span><br><span class="line">&#125;</span><br><span class="line">Subject.prototype=&#123;</span><br><span class="line">    subscribe:<span class="function"><span class="keyword">function</span>(<span class="params">observer</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.observers.push(observer);</span><br><span class="line">    &#125;,</span><br><span class="line">    unsubscribe:<span class="function"><span class="keyword">function</span>(<span class="params">observer</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> index=<span class="built_in">this</span>.observers.indexOf(observer);</span><br><span class="line">        <span class="keyword">if</span> (index&gt;-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.observers.splice(index,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    notify:<span class="function"><span class="keyword">function</span>(<span class="params">observer,msg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> index=<span class="built_in">this</span>.observers.indexOf(observer);</span><br><span class="line">        <span class="keyword">if</span> (index&gt;-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.observers[index].notify(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    notifyAll:<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg) <span class="comment">//all notified</span></span><br><span class="line">        <span class="built_in">this</span>.observers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">observe,msg</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(msg) <span class="comment">//0 1 2 3,这里的msg相当于forEach的index</span></span><br><span class="line">            observe.notify(msg) </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Observer=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        notify:<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;received: &quot;</span>+msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> subject=<span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">var</span> observer0=<span class="keyword">new</span> Observer();</span><br><span class="line"><span class="keyword">var</span> observer1=<span class="keyword">new</span> Observer();</span><br><span class="line"><span class="keyword">var</span> observer2=<span class="keyword">new</span> Observer();</span><br><span class="line"><span class="keyword">var</span> observer3=<span class="keyword">new</span> Observer();</span><br><span class="line">subject.subscribe(observer0);</span><br><span class="line">subject.subscribe(observer1);</span><br><span class="line">subject.subscribe(observer2);</span><br><span class="line">subject.subscribe(observer3);</span><br><span class="line">subject.notifyAll(<span class="string">&#x27;all notified&#x27;</span>); <span class="comment">//received: 0, received: 1, received: 2, received: 3</span></span><br><span class="line">subject.notify(observer2,<span class="string">&#x27;asda&#x27;</span>); <span class="comment">//received: asda</span></span><br></pre></td></tr></table></figure>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise，就是一个<strong>对象</strong>，用来传递异步操作的消息。</p>
<p>Promise 对象代表一个异步操作，有<strong>三种状态</strong>：<code>Pending</code>（进行中）、<code>Resolved</code>（已完成，又称 Fulfilled）和 <code>Rejected</code>（已失败）。</p>
<p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段<strong>无法改变</strong>。</p>
<p><strong>resolve</strong>函数的作用是，将 Promise 对象的状态从 <code>未处理</code> 变成 <code>处理成功</code> (unresolved =&gt; resolved)， 在异步操作成功时调用，并将异步操作的<strong>结果</strong>作为参数<strong>传递出去</strong>。</p>
<p><strong>reject</strong>函数的作用是，将 Promise 对象的状态从 <code>未处理</code> 变成 <code>处理失败</code>(unresolved =&gt; rejected), 在异步操作失败时调用，并将异步操作报出的<strong>错误</strong>作为参数<strong>传递出去</strong>。</p>
<p>Promise 实例生成以后，可以用 <strong>then</strong> 方法和 <strong>catch</strong> 方法分别指定 resolved 状态和 rejected 状态的<strong>回调函数</strong>。</p>
<h3 id="做饭、吃饭、洗碗（cook、eat、wash）示例"><a href="#做饭、吃饭、洗碗（cook、eat、wash）示例" class="headerlink" title="做饭、吃饭、洗碗（cook、eat、wash）示例"></a>做饭、吃饭、洗碗（cook、eat、wash）示例</h3><p>定义这三个方法，它们是层层依赖的关系，下一步的的操作需要使用上一部操作的结果。（这里使用 setTimeout 模拟异步操作）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//做饭</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cook</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始做饭&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;        <span class="comment">//做一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;做饭完毕&#x27;</span>);</span><br><span class="line">            resolve(<span class="string">&#x27;鸡蛋炒饭&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//吃饭</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eat</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始吃饭：&#x27;</span> + data);</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;        <span class="comment">//做一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;吃饭完毕&#x27;</span>);</span><br><span class="line">            resolve(<span class="string">&#x27;一块碗一双筷子&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wash</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始洗碗：&#x27;</span> + data);</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;        <span class="comment">//做一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;洗碗完毕&#x27;</span>);</span><br><span class="line">            resolve(<span class="string">&#x27;干净的碗筷&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 then 链式调用这三个方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cook()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> eat(data);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wash(data);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//上面代码还可以简化成如下：</span></span><br><span class="line">cook()</span><br><span class="line">.then(eat)</span><br><span class="line">.then(wash)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//运行结果:</span></span><br><span class="line">开始做饭</span><br><span class="line">做饭完毕</span><br><span class="line">开始吃饭：鸡蛋炒饭</span><br><span class="line">吃饭完毕</span><br><span class="line">开始洗碗：一块碗一双筷子</span><br><span class="line">洗碗完毕</span><br><span class="line">干净的碗筷</span><br></pre></td></tr></table></figure>
<h3 id="再举一个需要多层回调的例子"><a href="#再举一个需要多层回调的例子" class="headerlink" title="再举一个需要多层回调的例子"></a>再举一个需要多层回调的例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>resolve(n+<span class="number">200</span>),n)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Promise的方式将其3个步骤处理为链式操作，每一步都返回一个promise对象，将输出的结果作为下一步新的输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dolt</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;dolt&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1=<span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">    .then(<span class="function"><span class="params">time2</span>=&gt;</span>step2(time2))</span><br><span class="line">    .then(<span class="function"><span class="params">time3</span>=&gt;</span>step3(time3))</span><br><span class="line">    .then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;dolt&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dolt();</span><br><span class="line"><span class="comment">//输出结果为:</span></span><br><span class="line">step1 <span class="keyword">with</span> <span class="number">300</span></span><br><span class="line">step2 <span class="keyword">with</span> <span class="number">500</span></span><br><span class="line">step3 <span class="keyword">with</span> <span class="number">700</span></span><br><span class="line">result is <span class="number">900</span></span><br><span class="line">dolt: <span class="number">1506.</span>291ms</span><br></pre></td></tr></table></figure>
<p>缺点：对于长的链式操作来说，看起来是一堆then方法的堆砌，代码冗余，语义也不清楚，靠着箭头函数才使得代码略微简短一些。还有一个痛点，就是传递参数太麻烦，尤其是需要传递多参数的情况下。</p>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>generator是一个封装的异步任务，在需要暂停的地方，使用yield语句注明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y=<span class="keyword">yield</span> x+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g=gen(<span class="number">1</span>);</span><br><span class="line">g.next(); <span class="comment">//&#123;value: 3, done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>调用generator函数返回的是内部的指针对象，调用next方法就会移动内部指针。Generator函数之所以能被用来处理异步操作，因为它可以暂停执行和恢复执行、函数体内外的数据交换和错误处理机制。</p>
<h3 id="前面多任务的例子，使用generator实现"><a href="#前面多任务的例子，使用generator实现" class="headerlink" title="前面多任务的例子，使用generator实现"></a>前面多任务的例子，使用generator实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">dolt</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;dolt&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">yield</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">yield</span> step2(time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">yield</span> step3(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;dolt&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Generator 函数的执行必须靠执行器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = genF();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> next = nextF();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v); &#125;);      </span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">spawn(dolt); <span class="comment">//输出相同</span></span><br></pre></td></tr></table></figure>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>async函数基于Generator又做了几点改进：</p>
<ul>
<li>内置执行器，将Generator函数和自动执行器进一步包装。</li>
<li>语义更清楚，async表示函数中有异步操作，await表示等待着紧跟在后边的表达式的结果。</li>
<li>适用性更广泛，await后面可以跟promise对象和原始类型的值(Generator中不支持)</li>
</ul>
<p>它基于Promise使用async/await来优化then链的调用,其实也是Generator函数的语法糖。 async 将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象， await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</p>
<h3 id="用async-await重写前面的回调任务"><a href="#用async-await重写前面的回调任务" class="headerlink" title="用async/await重写前面的回调任务"></a>用async/await重写前面的回调任务</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dolt</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;dolt&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1=<span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2=<span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3=<span class="keyword">await</span> step2(time2);</span><br><span class="line">    <span class="keyword">const</span> result=<span class="keyword">await</span> step3(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;dolt&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dolt(); <span class="comment">//输出相同</span></span><br></pre></td></tr></table></figure>
<p>await只能用在async函数中，否则会报错。</p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包和执行上下文</title>
    <url>/js/%E7%AC%94%E8%AE%B0/js/9.%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包其实只是一个绑定了执行环境的函数。<br>闭包包含两个部分：</p>
<ul>
<li>环境部分<ul>
<li>环境：函数的词法环境（执行上下文的一部分）</li>
<li>标识符列表：函数中用到的未声明的变量</li>
</ul>
</li>
<li>表达式部分：函数体</li>
</ul>
<a id="more"></a>

<h2 id="执行上下文：执行的基础设施"><a href="#执行上下文：执行的基础设施" class="headerlink" title="执行上下文：执行的基础设施"></a>执行上下文：执行的基础设施</h2><p>一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。<br>在 ES2018 中，执行上下文是这样的：</p>
<ul>
<li>lexical environment：词法环境，当获取变量或者 this 值时使用。</li>
<li>variable environment：变量环境，当声明变量时使用。</li>
<li>code evaluation state：用于恢复代码执行位置。</li>
<li>Function：执行的任务是函数时使用，表示正在被执行的函数。</li>
<li>ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。</li>
<li>Realm：使用的基础库和内置对象实例。</li>
<li>Generator：仅生成器上下文有这个属性，表示当前生成器。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>要想正确执行它，我们需要知道以下信息：</p>
<ol>
<li>var 把 b 声明到哪里；</li>
<li>b 表示哪个变量；</li>
<li>b 的原型是哪个对象；</li>
<li>let 把 c 声明到哪里；</li>
<li>this 指向哪个对象。</li>
</ol>
<h3 id="var-声明与赋值"><a href="#var-声明与赋值" class="headerlink" title="var 声明与赋值"></a>var 声明与赋值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>var 会穿透 for 、if 等语句。</p>
<p>在只有 var，没有 let 的旧 JavaScript 时代，诞生了一个技巧，叫做：立即执行的函数表达式（IIFE），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围。</p>
<p>比较推荐的写法是使用 void 关键字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>这有效避免了语法问题，同时，语义上 void 运算表示忽略后面表达式的值，变成 undefined，我们确实不关心 IIFE 的返回值，所以语义也更为合理。</p>
<p>使用 with 的时候，var 的特性会导致声明的变量和被赋值的变量是两个 b：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> env = &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;In function b:&quot;</span>, b); <span class="comment">//2</span></span><br><span class="line">    <span class="function"><span class="title">with</span>(<span class="params">env</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;In with b:&quot;</span>, b); <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Global b:&quot;</span>, b); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，利用立即执行的函数表达式（IIFE）构造了一个函数的执行环境。</p>
<p>在 Global function with 三个环境中，b 的值都不一样，而在 function 环境中，并没有出现 var b，这说明 with 内的 var b 作用到了 function 这个环境当中。</p>
<p>var b = {} 这样一句对两个域产生了作用，从语言的角度是个非常糟糕的设计，这也是一些人坚定地反对在任何场景下使用 with 的原因之一。</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>et 是 ES6 开始引入的新的变量声明模式。为了实现 let，JS在运行时引入了块级作用域。在 let 出现之前，JS 的 if for 等语句皆不产生作用域。</p>
<p>以下语句会产生 let 使用的作用域：</p>
<ul>
<li>for；</li>
<li>if；</li>
<li>switch；</li>
<li>try/catch/finally。</li>
</ul>
<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><p>在最新的标准（9.0）中，JavaScript 引入了一个新概念 Realm，它的中文意思是“国度”“领域”“范围”，但是都不太适合JS的语境。</p>
<p>Realm 中包含一组完整的内置对象，而且是复制关系。对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>)</span><br><span class="line"><span class="built_in">document</span>.documentElement.appendChild(iframe)</span><br><span class="line">iframe.src=<span class="string">&quot;javascript:var b = &#123;&#125;;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = iframe.contentWindow.b;</span><br><span class="line"><span class="keyword">var</span> b2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1, <span class="keyword">typeof</span> b2); <span class="comment">//object object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>, b2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//false true</span></span><br></pre></td></tr></table></figure>
<p>由于 b1、 b2 由同样的代码“ {} ”在不同的 Realm 中执行，所以表现出了不同的行为。</p>
]]></content>
      <categories>
        <category>js</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
</search>
