<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>01_HTML基础</title>
    <url>/HTML/%E7%AC%94%E8%AE%B0/HTML+CSS/01_HTML%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="1-什么是网页"><a href="#1-什么是网页" class="headerlink" title="1. 什么是网页"></a>1. 什么是网页</h3><p>HTML文件 + CSS文件 + JS文件 (W3C标准)</p>
<ul>
<li>HTML文件作用：给网页提供结构</li>
<li>CSS文件作用：美化布局网页</li>
<li>JS文件作用：给网页提供行为</li>
</ul>
<h3 id="2-什么是HTML"><a href="#2-什么是HTML" class="headerlink" title="2. 什么是HTML"></a>2. 什么是HTML</h3><p><font color="deeppink">超文本标记语言(Hyper Text Markup Language)</font></p>
<p>超文本：文字、图片、动画、音频、视频、超链接和程序等等</p>
<p>特点：简单、通用性、与平台无关</p>
<p><font color="blue">HTML不是一种编程语言</font></p>
<a id="more"></a>

<h3 id="3-HTML语法规范"><a href="#3-HTML语法规范" class="headerlink" title="3. HTML语法规范"></a>3. HTML语法规范</h3><ul>
<li>HTML中不区分大小写，但一般用小写</li>
<li>注释不能嵌套</li>
<li>HTML标签必须结构完整（要么成对出现，要么是自结束标签）</li>
<li>HTML标签可以嵌套但不能交叉嵌套</li>
<li>HTML标签中的属性必须有值，且值必须加引号</li>
</ul>
<h3 id="4-什么是语义化，为什么要语义化"><a href="#4-什么是语义化，为什么要语义化" class="headerlink" title="4. 什么是语义化，为什么要语义化"></a><font color="red">4. 什么是语义化，为什么要语义化</font></h3><h4 id="HTML语义化"><a href="#HTML语义化" class="headerlink" title="HTML语义化"></a><strong>HTML语义化</strong></h4><p>HTML的语义化总结为： 用最恰当的标签来标记内容。</p>
<p>该如何理解呢？比如需要加入一个标题，这个标题的字体比正文的要大写，还要加粗。能够实现这种效果的方法有很多，比如用CSS样式进行渲染。这样的效果看起来像是一个标题，但是他对浏览器来说，只是一个被渲染过的文本，无法知道他是一个标题。若要让浏览器知道他是一个标题，应该用hx标签来进行标记。从这个例子可以总结出： 语义化的HTML文档，不关心内容的显示效果。 说的通俗一点： 标题脱了CSS这层外衣，它还是一个标题。</p>
<h4 id="HTML语义化的原因"><a href="#HTML语义化的原因" class="headerlink" title="HTML语义化的原因"></a><strong>HTML语义化的原因</strong></h4><ul>
<li>即使在没有CSS样式的条件下，也能很好地呈现出内容结构、代码结构；</li>
<li>语义化HTML会使HTML结构变的清晰，有利于维护代码和添加样式；</li>
<li>方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页；</li>
<li>提升搜索引擎优化(SEO)的效果。和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重；</li>
<li>便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。</li>
<li>通常语义化HTML会使代码变的更少，使页面加载更快。</li>
</ul>
<h4 id="在写HTML代码时应该注意"><a href="#在写HTML代码时应该注意" class="headerlink" title="在写HTML代码时应该注意"></a><strong>在写HTML代码时应该注意</strong></h4><ul>
<li>尽可能少的使用无语义的标签div和span；</li>
<li>在语义不明显时，既可以使用div或者p时，尽量用p, 因为p在默认情况下有上下间距，对兼容特殊终端有利；</li>
<li>不要使用纯样式标签，如：b、font、u等，改用css设置。</li>
<li>需要强调的文本，可以包含在strong或者em标签中（浏览器预设样式，能用CSS指定就不用他们），strong默认样式是加粗（不要用b），em是斜体（不用i）；</li>
<li>使用表格时，标题要用caption，表头用thead，主体部分用tbody包围，尾部用tfoot包围。表头和一般单元格要区分开，表头用th，单元格用td；</li>
<li>表单域要用fieldset标签包起来，并用legend标签说明表单的用途；</li>
<li>每个input标签对应的说明文本都需要使用label标签，并且通过为input设置id属性，在lable标签中设置for=someld来让说明文本和相对应的input关联起来。</li>
</ul>
<h4 id="HTML5新增了哪些语义标签"><a href="#HTML5新增了哪些语义标签" class="headerlink" title="HTML5新增了哪些语义标签"></a><strong>HTML5新增了哪些语义标签</strong></h4><p>在HTML 5出来之前，我们用<code>div</code>来表示页面章节，但是这些<code>div</code>都没有实际意义。（即使我们用css样式的id和class形容这块内容的意义）。这些标签只是我们提供给浏览器的指令，只是定义一个网页的某些部分。但现在，那些之前没“意义”的标签因为因为html5的出现消失了，这就是我们平时说的“语义”。 </p>
<h5 id="html5的布局"><a href="#html5的布局" class="headerlink" title="html5的布局"></a><strong>html5的布局</strong></h5><p>嗯，如上图那个页面结构没有一个div，都是采用html5语义标签（用哪些标签，关键取决于你的设计目标）。</p>
<p>但是也不要因为html5新标签的出现，而随意用之，错误的使用肯定会事与愿违。所以有些地方还是要用div的，就是因为div没有任何意义的元素，他只是一个标签，仅仅是用来构建外观和结构。因此是最适合做容器的标签。</p>
<p>W3C定义了这些语义标签，不可能完全符合我们有时的设计目标，就像制定出来的法律不可能流传100年都不改变，更何况它才制定没多久，不可能这些语义标签对所以设计目标的适应。只是一定程度上的“通用”，我们的目标是让爬虫读懂重要的东西就够了。</p>
<p>结论：不能因为有了HTML 5标签就弃用了div，每个事物都有它的独有作用的。</p>
<p>节点元素标签因使用的地方不同，我将他们分为：节元素标签、文本元素标签、分组元素标签分开来讲解HTML5中新增加的语义化标签和使用总结。</p>
<h5 id="header元素"><a href="#header元素" class="headerlink" title="header元素"></a>header元素</h5><p>header 元素代表“网页”或“section”的页眉。<br>通常包含<code>h1-h6</code>元素或<code>hgroup</code>，作为整个页面或者一个内容块的标题。也可以包裹一节的目录部分，一个搜索框，一个<code>nav</code>，或者任何相关logo。</p>
<p>整个页面没有限制header元素的个数，可以拥有多个，可以为每个内容块增加一个header元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;header&gt;</span><br><span class="line">    &lt;hgroup&gt;</span><br><span class="line">        &lt;h1&gt;网站标题&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;h1&gt;网站副标题&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;&#x2F;hgroup&gt;</span><br><span class="line">&lt;&#x2F;header&gt;</span><br></pre></td></tr></table></figure>
<p><strong>header的示例代码</strong></p>
<p>header使用注意：</p>
<ul>
<li>可以是“网页”或任意“section”的头部部分；</li>
<li>没有个数限制。</li>
<li>如果hgroup或h1-h6自己就能工作的很好，那就不要用header。</li>
</ul>
<h5 id="footer元素"><a href="#footer元素" class="headerlink" title="footer元素"></a>footer元素</h5><p><code>footer</code>元素代表“网页”或“section”的页脚，通常含有该节的一些基本信息，譬如：作者，相关文档链接，版权资料。如果<code>footer</code>元素包含了整个节，那么它们就代表附录，索引，提拔，许可协议，标签，类别等一些其他类似信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;footer&gt;</span><br><span class="line">    COPYRIGHT@小北</span><br><span class="line">&lt;&#x2F;footer&gt;</span><br></pre></td></tr></table></figure>
<p><strong><code>footer</code>的示例代码</strong></p>
<p>footer使用注意：</p>
<ul>
<li>可以是“网页”或任意“section”的底部部分；</li>
<li>没有个数限制，除了包裹的内容不一样，其他跟header类似。</li>
</ul>
<h5 id="hgroup元素"><a href="#hgroup元素" class="headerlink" title="hgroup元素"></a>hgroup元素</h5><p><code>hgroup</code>元素代表“网页”或“section”的标题，当元素有多个层级时，该元素可以将<code>h1</code>到<code>h6</code>元素放在其内，譬如文章的主标题和副标题的组合</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;hgroup&gt;</span><br><span class="line">    &lt;h1&gt;这是一篇介绍HTML 5语义化标签和更简洁的结构&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;h2&gt;HTML 5&lt;&#x2F;h2&gt;</span><br><span class="line">&lt;&#x2F;hgroup&gt;</span><br></pre></td></tr></table></figure>
<p><strong><code>hgroup</code>示例代码</strong></p>
<p>hgroup使用注意：</p>
<ul>
<li>如果只需要一个h1-h6标签就不用hgroup</li>
<li>如果有连续多个h1-h6标签就用hgroup</li>
<li>如果有连续多个标题和其他文章数据，h1-h6标签就用hgroup包住，和其他文章元数据一起放入header标签</li>
</ul>
<h5 id="nav元素"><a href="#nav元素" class="headerlink" title="nav元素"></a><strong>nav元素</strong></h5><p><code>nav</code>元素代表页面的导航链接区域。用于定义页面的<strong>主要导航部分</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;nav&gt;</span><br><span class="line">    &lt;ul&gt;</span><br><span class="line">        &lt;li&gt;HTML 5&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;CSS3&lt;&#x2F;li&gt;</span><br><span class="line">        &lt;li&gt;JavaScript&lt;&#x2F;li&gt;</span><br><span class="line">    &lt;&#x2F;ul&gt;</span><br><span class="line">&lt;&#x2F;nav&gt;</span><br></pre></td></tr></table></figure>
<p><strong><code>nav</code>实例</strong></p>
<p>但是我在有些时候却情不自禁的想用它，譬如：侧边栏上目录，面包屑导航，搜索样式，或者下一篇上一篇文章，但是事实上规范上说nav只能用在页面主要导航部分上。页脚区域中的链接列表，虽然指向不同网站的不同区域，譬如服务条款，版权页等，这些footer元素就能够用了。</p>
<p>nav使用注意：</p>
<ul>
<li>用在整个页面主要导航部分上，不合适就不要用nav元素；</li>
</ul>
<h5 id="aside元素"><a href="#aside元素" class="headerlink" title="aside元素"></a><strong>aside元素</strong></h5><p><code>aside</code>元素被包含在article元素中作为主要内容的附属信息部分，其中的内容可以是与当前文章有关的相关资料、标签、名次解释等。（特殊的section）</p>
<p>在article元素之外使用作为页面或站点全局的附属信息部分。最典型的是侧边栏，其中的内容可以是日志串连，其他组的导航，甚至广告，这些内容相关的页面。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;article&gt;</span><br><span class="line">    &lt;p&gt;内容&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;aside&gt;</span><br><span class="line">        &lt;h1&gt;作者简介&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;小北，前端一枚&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;aside&gt;</span><br><span class="line">&lt;&#x2F;article&gt;</span><br></pre></td></tr></table></figure>
<p><strong><code>aside</code>实例</strong></p>
<p>aside使用总结：</p>
<ul>
<li>aside在article内表示主要内容的附属信息，</li>
<li>在article之外则可做侧边栏，没有article与之对应，最好不用。</li>
<li>如果是广告，其他日志链接或者其他分类导航也可以用</li>
</ul>
<h5 id="section元素"><a href="#section元素" class="headerlink" title="section元素"></a>section元素</h5><p><code>section</code>元素代表文档中的“节”或“段”，“段”可以是指一篇文章里按照主题的分段；“节”可以是指一个页面里的分组。</p>
<p>section通常还带标题，虽然html5中section会自动给标题h1-h6降级，但是最好手动给他们降级。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">    &lt;h1&gt;section是啥？&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;article&gt;</span><br><span class="line">        &lt;h2&gt;关于section&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;section的介绍&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;section&gt;</span><br><span class="line">            &lt;h3&gt;关于其他&lt;&#x2F;h3&gt;</span><br><span class="line">            &lt;p&gt;关于其他section的介绍&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;section&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
<p><strong><code>section</code>示例代码</strong></p>
<p>section使用注意：</p>
<p>一张页面可以用section划分为简介、文章条目和联系信息。不过在文章内页，最好用article。section不是一般意义上的容器元素，如果想作为样式展示和脚本的便利，可以用div。</p>
<ul>
<li>表示文档中的节或者段；</li>
<li>article、nav、aside可以理解为特殊的section，所以如果可以用article、nav、aside就不要用section，没实际意义的就用div</li>
</ul>
<h5 id="article元素"><a href="#article元素" class="headerlink" title="article元素"></a>article元素</h5><p><code>article</code>元素最容易跟<code>section</code>和<code>div</code>容易混淆，其实<code>article</code>代表一个在文档，页面或者网站中自成一体的内容，其目的是为了让开发者独立开发或重用。譬如论坛的帖子，博客上的文章，一篇用户的评论，一个互动的widget小工具。（特殊的section）</p>
<p>除了它的内容，<code>article</code>会有一个标题（通常会在<code>header</code>里），会有一个<code>footer</code>页脚。我们举几个例子介绍一下article，好更好区分article、section、div</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;article&gt;</span><br><span class="line">    &lt;h1&gt;一篇文章&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;文章内容..&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;footer&gt;</span><br><span class="line">        &lt;p&gt;&lt;small&gt;版权：html5jscss网所属，作者：小北&lt;&#x2F;small&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;footer&gt;</span><br><span class="line">&lt;&#x2F;article&gt;</span><br></pre></td></tr></table></figure>
<p><strong>一篇简单文章的article示例代码</strong></p>
<p>上例是最好简单的article标签使用情况，如果在article内部再嵌套article，那就代表内嵌的article是与它外部的内容有关联的，如博客文章下面的评论，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;article&gt;</span><br><span class="line"></span><br><span class="line">    &lt;header&gt;</span><br><span class="line">        &lt;h1&gt;一篇文章&lt;&#x2F;h1&gt;</span><br><span class="line">        &lt;p&gt;&lt;time pubdate datetime&#x3D;&quot;2012-10-03&quot;&gt;2012&#x2F;10&#x2F;03&lt;&#x2F;time&gt;&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;header&gt;</span><br><span class="line"></span><br><span class="line">    &lt;p&gt;文章内容..&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;article&gt;</span><br><span class="line">        &lt;h2&gt;评论&lt;&#x2F;h2&gt;</span><br><span class="line"></span><br><span class="line">        &lt;article&gt;</span><br><span class="line">            &lt;header&gt;</span><br><span class="line">                &lt;h3&gt;评论者: XXX&lt;&#x2F;h3&gt;</span><br><span class="line">                &lt;p&gt;&lt;time pubdate datetime&#x3D;&quot;2012-10-03T19:10-08:00&quot;&gt;~1 hour ago&lt;&#x2F;time&gt;&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;&#x2F;header&gt;</span><br><span class="line">            &lt;p&gt;哈哈哈&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">        &lt;article&gt;</span><br><span class="line">            &lt;header&gt;</span><br><span class="line">                &lt;h3&gt;评论者: XXX&lt;&#x2F;h3&gt;</span><br><span class="line">                &lt;p&gt;&lt;time pubdate datetime&#x3D;&quot;2012-10-03T19:10-08:00&quot;&gt;~1 hour ago&lt;&#x2F;time&gt;&lt;&#x2F;p&gt;</span><br><span class="line">            &lt;&#x2F;header&gt;</span><br><span class="line">            &lt;p&gt;哈？哈？哈？&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;article&gt;</span><br></pre></td></tr></table></figure>
<p><strong>文章里的评论，一个article嵌套article来表示的实例</strong></p>
<p>article内部嵌套article，有可能是评论或其他跟文章有关联的内容。那article内部嵌套section一般是什么情况呢。如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;article&gt;</span><br><span class="line"></span><br><span class="line">    &lt;h1&gt;前端技术&lt;&#x2F;h1&gt;</span><br><span class="line">    &lt;p&gt;前端技术有那些&lt;&#x2F;p&gt;</span><br><span class="line"></span><br><span class="line">    &lt;section&gt;</span><br><span class="line">        &lt;h2&gt;CSS&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p&gt;样式..&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line"></span><br><span class="line">    &lt;section&gt;</span><br><span class="line">        &lt;h2&gt;JS&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p&gt;脚本&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;section&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;article&gt;</span><br></pre></td></tr></table></figure>
<p><strong>文章里的章节，一个article里的section实例</strong></p>
<p>因为文章内section部分虽然也是独立的部分，但是它门只能算是<em>组成整体的一部分</em>，从属关系，article是大主体，section是构成这个大主体的一部分。本网站的全部文章都是article嵌套一个个section章节，这样能让浏览器更容易区分各个章节所包括的内容。</p>
<p>那section内部嵌套article又有哪些情况呢，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;section&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;h1&gt;介绍: 网站制作成员配备&lt;&#x2F;h1&gt;</span><br><span class="line"></span><br><span class="line">    &lt;article&gt;</span><br><span class="line">        &lt;h2&gt;设计师&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p&gt;设计网页的...&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">    &lt;article&gt;</span><br><span class="line">        &lt;h2&gt;程序员&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p&gt;后台写程序的..&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">    &lt;article&gt;</span><br><span class="line">        &lt;h2&gt;前端工程师&lt;&#x2F;h2&gt;</span><br><span class="line">        &lt;p&gt;给楼上两位打杂的..&lt;&#x2F;p&gt;</span><br><span class="line">    &lt;&#x2F;article&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;section&gt;</span><br></pre></td></tr></table></figure>
<p><strong>一个section里的article实例</strong></p>
<p>设计师、程序员、前端工程师都是一个独立的整体，他们组成了网站制作基本配备，当然还有其他成员~~。设计师、程序员、前端工程师就像article，是一个个独立的整体，而section将这些自成一体的article包裹，就组成了一个团体。</p>
<p>article和section和例子就例举这么多了，具体情况具体分析，不易深究。漏了<code>div</code>d，其实<code>div</code>就是只是想用来把元素组合或者给它们加样式时使用。</p>
<p>article使用注意：</p>
<ul>
<li>自身独立的情况下：用article</li>
<li>是相关内容：用section</li>
<li>没有语义的：用div</li>
</ul>
<h4 id="HTML5其他结构元素标签"><a href="#HTML5其他结构元素标签" class="headerlink" title="HTML5其他结构元素标签"></a><strong>HTML5其他结构元素标签</strong></h4><p>HTML5节元素标签包括<code>body article nav aside section header footer hgroup </code>，还有<code>h1-h6 address</code>。</p>
<ul>
<li><code>address</code>代表区块容器，必须是作为联系信息出现，邮编地址、邮件地址等等,一般出现在footer。</li>
<li><code>h1-h6</code>因为hgroup，section和article的出现，h1-h6定义也发生了变化，允许一张页面出现多个h1。</li>
</ul>
<h3 id="5-图片的格式"><a href="#5-图片的格式" class="headerlink" title="5. 图片的格式"></a>5. 图片的格式</h3><ul>
<li>JPEG(JPG)：支持颜色较多，图片可压缩，但不支持透明（一般用来保存照片等颜色丰富的图片）</li>
<li>GIF：支持颜色少，只支持简单透明，支持动态图（用来保存图片颜色单一或动图）</li>
<li>PNG：支持颜色多，支持复杂透明。（用来保存颜色复杂的透明图片）</li>
<li>Webp：这种格式是谷歌推出的专门用来表示网页中图片的一种格式，它具备其他图片格式的所有优点，而且文件还特别小。缺点是兼容性差。</li>
<li>base64：将图片使用base64编码，这样可以将图片转换为字符，通过字符的形式来引入图片，一般都是一些需要和网页一起加载的图片才会使用base64，他不是一种格式，任何格式的图片都可以转化为base64的形式。</li>
</ul>
<p><font color="deeppink">使用原则：效果不同使用效果好的，效果一致使用小的。</font></p>
<h3 id="6-实体（转义字符）"><a href="#6-实体（转义字符）" class="headerlink" title="6. 实体（转义字符）"></a>6. 实体（转义字符）</h3><p>在HTML中，一些 ‘&lt;’ 和 ‘&gt;’ 这样的特殊字符是不能直接使用的需要使用一些特殊的符号来表示这些字符,这些特殊的符号我们称为实体。</p>
<p>用法：&amp; + 实体名字 + ；</p>
<p>例如：&gt;    &amp;lt;    &gt;    &amp;gt;    空格    &amp;nbsp;    版权符号    &amp;copy;</p>
<h3 id="7-文档声明"><a href="#7-文档声明" class="headerlink" title="7. 文档声明"></a>7. 文档声明</h3><p>&lt;!DOCTYPE html&gt;<br><font color="deeppink">该标签写在html标签外</font></p>
<p>表示该网页的文档类型，并且告诉浏览器渲染模式。如果不设置则会导致浏览器进入怪异模式（怪异盒模型即border-box）</p>
<p>标准模式，近乎标准模式，怪异模式</p>
<ul>
<li>在ie9以上三种模式在渲染方面几乎没有区别</li>
<li>在ie7,8,9中理论上存在怪异模式，但实际上只有标准模式</li>
<li>在ie6以下，只有怪异模式</li>
</ul>
<h4 id="标准模式与怪异模式区别"><a href="#标准模式与怪异模式区别" class="headerlink" title="标准模式与怪异模式区别"></a><font color="red">标准模式与怪异模式区别</font></h4><p>1）盒模型：IE下标准模式为：content+padding+border+margin。怪异模式下为：content+margin(padding,border包含在content宽高中)</p>
<p>2）怪异模式中IE6/7/8都不识别！important声明</p>
<p>3）设置行内元素宽高，标准模式下不生效，怪异模式下生效</p>
<p>4）margin:0 auto,在标准模式下会水平居中，怪异模式下不会。</p>
<h3 id="8-meta标签"><a href="#8-meta标签" class="headerlink" title="8. meta标签"></a>8. meta标签</h3><p>&lt;meta charset=”utf-8”&gt;</p>
<p>字符集设置如果不设置浏览器会使用默认的解码方式（中文系统下是GB2312）进行解码，有可能出现乱码，所以使用meta标签声明该网页使用的编码格式。</p>
<p><font color="deeppink">编码方式是由编译器决定的</font></p>
]]></content>
      <categories>
        <category>HTML</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title>01_git 简介</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/01-git-%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<h3 id="集中式-svn"><a href="#集中式-svn" class="headerlink" title="集中式(svn)"></a>集中式(svn)</h3><p>svn因为每次存的都是差异 需要的硬盘空间会相对的小一点  可是回滚的速度会很慢<br>优点:<br>    代码存放在单一的服务器上 便于项目的管理</p>
<a id="more"></a>

<p>缺点:<br>    服务器宕机: 员工写的代码得不到保障<br>    服务器炸了: 整个项目的历史记录都会丢失</p>
<h3 id="分布式-git"><a href="#分布式-git" class="headerlink" title="分布式(git)"></a>分布式(git)</h3><p>git每次存的都是项目的完整快照 需要的硬盘空间会相对大一点<br>    (Git团队对代码做了极致的压缩 最终需要的实际空间比svn多不了太多 可是Git的回滚速度极快)<br>优点:<br>    完全的分布式<br>缺点:<br>    学习起来比SVN难一点</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>02_Git的基本理论</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/02-Git%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%90%86%E8%AE%BA/</url>
    <content><![CDATA[<h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>类似于qq的下一步 下一步</p>
<p>查看版本号</p>
<p>git –version</p>
<a id="more"></a>

<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>git config –global user.name ysj</p>
<p>git config –global user.email <a href="mailto:&#121;&#115;&#x6a;&#49;&#56;&#x30;&#x33;&#x37;&#x33;&#49;&#x36;&#x34;&#x33;&#x33;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;">&#121;&#115;&#x6a;&#49;&#56;&#x30;&#x33;&#x37;&#x33;&#49;&#x36;&#x34;&#x33;&#x33;&#64;&#49;&#x36;&#x33;&#46;&#x63;&#111;&#x6d;</a></p>
<p>git config –list</p>
<h3 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h3><p>​        Git 的核心部分是一个简单的键值对数据库。你可以向该数据库插入任意类型的内容，它会返回一个键值，通过该键值可以在任意时刻再次检索该内容</p>
<p>​        Git 存储内容的方式：一个文件对应一条内容。校验和的前两个字符用于命名子目录，余下的38个字符则用作文件名。</p>
<p>​        在 Git 中，<font color="deeppink"><strong>文件名并没有被保存</strong></font>——我们仅保存了文件的内容</p>
<p>​        <strong><font color="deeppink">解决方案：树对象</font></strong></p>
<p>​        树对象（tree object），它能解决文件名保存的问题，也允许我们将多个文件组织到一起。Git 以一种类似于 UNIX 文件系统的方式存储内容。所有内容均以树对象和数据对象<font color="red">(git对象)</font>的形式存储，其中树对象对应了 UNIX 中的目录项， 数据对象<font color="red">(git对象)</font>则大致上对应文件内容。一个树对象包含了一条或多条记录<font color="cornflowerblue">（每条记录含有一个指向git对象或者子树对象的SHA-1指针，以及相应的模式、类型、文件名信息）。</font>一个树对象也可以包含另一个树对象。</p>
<h3 id="区域（操作时的流程）"><a href="#区域（操作时的流程）" class="headerlink" title="区域（操作时的流程）"></a>区域（操作时的流程）</h3><p><font color="deeppink"><strong>工作区</strong></font>(沙箱环境Git不会管理)</p>
<p><font color="deeppink"><strong>暂存区</strong></font>（不在数据库中，存的是git对象的描述信息，也即在工作区执行（git add ./）命令时文件的描述信息，例如时间戳、内容的长度等，代表了此时文件的状态）(暂存区只有一个存放在根目录下的index文件中)</p>
<p><font color="deeppink"><strong>版本区</strong></font>（将以此版本的暂存区进行以此快照，并存入数据库中）</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p><font color="deeppink"><strong>Git对象</strong></font>（代表文件的一次次版本）只能存数据</p>
<p>​    key：val  组成的键值对（key是val对应的hash）</p>
<p>​                    键值对在Git内部是一个<font color="red"><strong>blob类型</strong></font></p>
<p><font color="deeppink"><strong>树对象</strong></font>（代表项目的一次次版本）</p>
<p><font color="deeppink"><strong>提交对象</strong></font>(对每次提交版本的封装，包括注释)</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>03_Git、linux基本操作</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/03-Git%E3%80%81linux%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h2><p>初始化新仓库：git init</p>
<p><font color="red"><strong>git 目录</strong></font></p>
<p><a href="https://imgchr.com/i/s9SUfK"><img src="https://s3.ax1x.com/2021/01/03/s9SUfK.png" alt="s9SUfK.png"></a></p>
<p>​                    hooks                        目录包含客户端或服务端的钩子脚本；</p>
<a id="more"></a>

<p>​                    info                            包含一个全局性排除文件</p>
<p>​                    logs                            保存日志信息</p>
<p>​                    <font color="red"><strong>objects                     目录存储所有数据内容；</strong></font></p>
<p>​                    <font color="red"><strong>refs                            目录存储指向数据的提交对象的指针（所有分支）</strong></font></p>
<p>​                    config                        文件包含项目特有的配置选项</p>
<p>​                    description                用来显示对仓库的描述信息</p>
<p>​                    <font color="red"><strong>head                        文件指示目前被检出的分支</strong></font></p>
<p>​                    <font color="red"><strong>index                        文件保存暂存区信息</strong></font></p>
<h3 id="git-底层命令："><a href="#git-底层命令：" class="headerlink" title="git 底层命令："></a>git 底层命令：</h3><p><strong>git 对象</strong></p>
<p>​        <font color="blue">git hash-object -w 文件路径</font>（生成一个key(hash值)和val的键值对，并将其<strong>存入.git/objects</strong>）</p>
<p><strong>tree对象</strong></p>
<p>​        <font color="blue">git update-index –add –cacheinfo 10064 hash值 text.txt </font>(此时没有生成树对象,只是向暂存区添加一条记录,让git对象对应上传文件名,并将其<strong>存入.git/index</strong>)</p>
<p>​        <font color="blue">git write-tree</font> (生成树对象,并将其<strong>存入.git/objects</strong>)</p>
<p><strong>commit对象</strong></p>
<p>​        <font color="blue">echo ‘内容’ / git commit-tree treehash值</font>  (生成一个提交对象并将其<strong>存入.git/objects</strong>)</p>
<p><strong>对以上对象的查询:</strong></p>
<p>​        <font color="blue">git cat-file -p hash值</font>  (拿对应对象的内容)</p>
<p>​        <font color="blue">git cat-file -t hash值</font>  (拿对应对象的类型)</p>
<p><strong>查看暂存区:</strong></p>
<p>​        <font color="cornflowerblue">git ls-files -s</font></p>
<h2 id="基础的linux命令"><a href="#基础的linux命令" class="headerlink" title="基础的linux命令"></a>基础的linux命令</h2><p><strong>clear</strong> ：清除屏幕</p>
<p><strong>echo ‘test content’**：往控制台输出信息 **echo ‘test content’ &gt; test.txt</strong></p>
<p><strong>ll</strong>：将当前目录下的 子文件&amp;子目录平铺在控制台</p>
<p><strong>find</strong> <strong>目录名</strong>： 将对应目录下的子孙文件&amp;子孙目录平铺在控制台</p>
<p><strong>find</strong> <strong>目录名</strong> <strong>-type f</strong> ：将对应目录下的文件平铺在控制台</p>
<p><strong>rm</strong>  <strong>文件名 ：</strong> 删除文件</p>
<p><strong>mv</strong> <strong>源文件 重命名文件</strong>: 重命名</p>
<p><strong>cat</strong> <strong>文件的</strong> <strong>url :</strong> 查看对应文件的内容</p>
<h4 id="vim-文件的-url-在英文模式下"><a href="#vim-文件的-url-在英文模式下" class="headerlink" title="vim 文件的 url(在英文模式下)"></a>vim 文件的 url(在英文模式下)</h4><ul>
<li>按 i 进插入模式 进行文件的编辑按 esc 键&amp;按:键 进行命令的执行</li>
<li>q!   强制退出（不保存）</li>
<li>wq  保存退出</li>
<li>set nu 设置行号</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
<p>​    </p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>05_代码风格</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/05-%E4%BB%A3%E7%A0%81%E9%A3%8E%E6%A0%BC/</url>
    <content><![CDATA[<h1 id="代码风格"><a href="#代码风格" class="headerlink" title="代码风格"></a>代码风格</h1><h2 id="Eslint-js代码检查工具"><a href="#Eslint-js代码检查工具" class="headerlink" title="Eslint(js代码检查工具)"></a>Eslint(js代码检查工具)</h2><h3 id="仅使用eslint"><a href="#仅使用eslint" class="headerlink" title="仅使用eslint"></a>仅使用eslint</h3><p><strong>创建package.json文件(npm init -y)</strong></p>
<p><strong>首先本地安装eslint</strong></p>
<p><font color="cornflowerblue"><strong>npm i eslint –save-dev</strong></font></p>
<a id="more"></a>



<p><strong>设置package.json文件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;lint&quot;</span>: <span class="string">&quot;eslint src&quot;</span>,</span><br><span class="line">  <span class="string">&quot;lint:create&quot;</span>: <span class="string">&quot;eslint --init&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>在终端中输入npm run lint:create(等价于执行npm eslint –init)</strong></p>
<p>出现的问题:</p>
<p>1.你想要怎么使用eslint (只是检查语法，检查语法找到问题，检查语法找到问题并强制保存编码风格)    3</p>
<p>2.哪一种模块化方案你要去使用    3</p>
<p>3.哪一种框架    3</p>
<p>4.你用不用typescript    n</p>
<p>5.你的项目跑在那儿(浏览器，node)    1</p>
<p>6.你想要怎么去定义一个风格(使用流行的向导，回答问题去自定义，导入配置文件)    1</p>
<p>7.哪一个向导你想要使用(Airbnb，标准，谷歌)    2</p>
<p>8.哪种配置文件你想要(js，yaml，json)    1</p>
<p>9.你希望让npm帮你装依赖的包吗    y</p>
<p><strong>完成后会生成 .eslintrc.js 文件。提供编码规则</strong></p>
<p><strong>装完之后以后在该项目的终端中输入npm run lint命令就会去验证跟根目录下的src文件夹下的js代码</strong></p>
<p>此时存在的问题是你可以不去通过eslint的约束而直接提交到git上</p>
<h3 id="eslint配合husky-哈士奇-和Git使用"><a href="#eslint配合husky-哈士奇-和Git使用" class="headerlink" title="eslint配合husky(哈士奇)和Git使用"></a>eslint配合husky(哈士奇)和Git使用</h3><p><strong>在装husky之前一定要先创建Git仓库，因为他要像git中添加钩子</strong></p>
<p><strong>安装husky</strong></p>
<p><font color="blue">npm i husky –save-dev</font></p>
<p><strong>设置package.json文件</strong></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;husky&quot;</span>: &#123;</span><br><span class="line">    <span class="string">&quot;hooks&quot;</span>: &#123;</span><br><span class="line">      <span class="string">&quot;pre-commit&quot;</span>: <span class="string">&quot;npm run lint&quot;</span></span><br><span class="line">      <span class="comment">//在git commit之前一定要通过npm run lint的检查</span></span><br><span class="line">      <span class="comment">// 只有npm run lint不报错时 commit才能真正的运行</span></span><br><span class="line">    &#125;</span><br><span class="line">	&#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置之后再向git提交就会自动调用eslint验证js代码</p>
<h2 id="Editor-Config"><a href="#Editor-Config" class="headerlink" title="Editor Config"></a>Editor Config</h2><p>​        EditorConfig 帮助开发人员定义和维护不同编辑器之间一致的编码风格。EditorConfig 项目由定义编码样式的文件格式和一组文本编辑器插件组成，这些插件使编辑器能够读取文件格式并坚持已定义的样式。编辑器配置文件易于阅读，并且可以很好地与版本控制系统一起工作</p>
<p>​        你只需配置一个 .editorconfig 文件，在其中设置好要遵守的代码规范，放在项目的根目录下，就能够在几乎所有的主流 IDE 和编辑器中复用了，可以将 .editorconfig 文件也提交到版本控制系统中，就不需要针对不同 IDE 和编辑器再单独进行设置了。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>06_远程仓库</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/06-%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93/</url>
    <content><![CDATA[<h3 id="三个必须懂的概念"><a href="#三个必须懂的概念" class="headerlink" title="三个必须懂的概念"></a>三个必须懂的概念</h3><p>本地分支<br>远程跟踪分支(remote/分支名)<br>远程分支</p>
<h3 id="忽略某些文件"><a href="#忽略某些文件" class="headerlink" title="忽略某些文件"></a>忽略某些文件</h3><p>创建一个 <strong>.gitignore</strong> 文件</p>
<a id="more"></a>

<p>所有空行或者以注释符号＃ 开头的行都会被 Git 忽略。</p>
<p>可以使用标准的 glob 模式匹配。</p>
<p>​    *代表匹配任意个字符</p>
<p>​    ？代表匹配任意一个字符</p>
<p>​    ** 代表匹配多级目录</p>
<p>匹配模式前跟反斜杠（/） 这个斜杠代表项目根目录</p>
<p>匹配模式最后跟反斜杠（/）说明要忽略的是目录。</p>
<p>要忽略指定模式以外的文件或目录，可以在模式前加上惊叹号（!）取反。</p>
<p><strong>GitHub 有一个十分详细的针对数十种项目及语言的 .gitignore 文件列表，你可以在 <a href="https://github.com/github/gitignore">https://github.com/github/gitignore</a> 找到它!!!</strong></p>
<h3 id="团队协作"><a href="#团队协作" class="headerlink" title="团队协作"></a>团队协作</h3><ol>
<li><p><strong>项目经理初始化远程仓库</strong><br>一定要初始化一个空的仓库; 在github上操作</p>
</li>
<li><p><strong>项目经理创建本地仓库（项目经理为远程仓库配置别名&amp;用户信息）</strong><br><font color="blue">git remote 别名 仓库地址(https)</font><strong>添加一个新的远程 Git 仓库，同时指定一个你可以轻松引用的简写</strong></p>
<p>git init ; 将源码复制进来</p>
<p>git add</p>
<p>git commit </p>
<p><font color="blue"><strong>git remote -v</strong></font>查看远程仓库使用的 Git别名和与其对应的URL</p>
<p><strong>git remote rename pb paul</strong>重命名</p>
<p>**git remote rm [remote-name]**如果因为一些原因想要移除一个远程仓库 - 你已经从服务器上搬走了或不再想使用某一个特定的镜像了，又或者某一个贡献者不再贡献了</p>
</li>
<li><p>项目经理推送本地仓库到远程仓库<br><font color="blue"><strong>git push  别名 分支名</strong></font>  (输入用户名 密码;推完之后会附带生成远程跟踪分支)</p>
</li>
<li><p>项目邀请成员 &amp; 成员接受邀请<br>在github上操作  </p>
</li>
<li><p>成员克隆远程仓库<br>git clone  仓库地址 (在本地生成.git文件 默认为远程仓库配了别名 orgin)</p>
<pre><code>        只有在克隆的时候 本地分支master 和 远程跟踪分支别名/master 是有同步关系的</code></pre>
</li>
<li><p>成员做出贡献<br>修改源码文件<br>git add<br>git commit<br>git push  别名 分支 (输入用户名 密码;推完之后会附带生成远程跟踪分支) </p>
</li>
<li><p>项目经理更新修改<br><strong>git fetch</strong> 别名 (将修改同步到远程跟踪分支上)<br>git merge 远程跟踪分支</p>
</li>
</ol>
<h3 id="本地分支"><a href="#本地分支" class="headerlink" title="本地分支"></a>本地分支</h3><p>正常的数据推送 和 拉取步骤<br>    1. 确保本地分支已经跟踪了远程跟踪分支<br>        2. 拉取数据 : git pull<br>        3. 上传数据: git push</p>
<p><font color="deeppink"><strong>一个本地分支怎么去跟踪一个远程跟踪分支</strong></font></p>
<ol>
<li><p>当克隆的时候 会自动生成一个master本地分支(已经跟踪了对应的远程跟踪分支)</p>
</li>
<li><p>在新建其他分支时 可以指定想要跟踪的远程跟踪分支<br> <font color="blue"><strong>git checkout -b 本地分支名 远程跟踪分支名</strong></font><br>  <font color="blue"><strong>git checkout –track  远程跟踪分支名</strong> </font></p>
</li>
<li><p>将一个已经存在的本地分支 改成 一个跟踪分支<br> <font color="blue"><strong>git branch -u 远程跟踪分支名</strong> </font></p>
</li>
<li><p><font color="cornflowerblue"><strong>git branch -vv</strong></font></p>
<p>查看设置的所有跟踪分支</p>
</li>
</ol>
<p>git remote remove origin 取消连接</p>
<p>git remote add origin https://… 连接本地仓库和远程仓库</p>
<h3 id="删除远程分支"><a href="#删除远程分支" class="headerlink" title="删除远程分支"></a>删除远程分支</h3><p><strong>git push origin –delete serverfix</strong>删除远程分支</p>
<p><strong>git remote prune origin –dry-run</strong>列出仍在远程跟踪但是远程已被删除的无用分支</p>
<p><strong>git remote prune origin</strong>清除上面命令列出来的远程跟踪</p>
<h3 id="冲突"><a href="#冲突" class="headerlink" title="冲突"></a>冲突</h3><p>git本地操作会不会有冲突?<br>    典型合并的时候<br>git远程协作的时候 会不会有冲突?<br>    push<br>    pull</p>
<h3 id="pull-request"><a href="#pull-request" class="headerlink" title="pull request"></a>pull request</h3><p>让第三方人员参与到项目中 fork</p>
<h3 id="SSH"><a href="#SSH" class="headerlink" title="SSH"></a>SSH</h3><p>​    ssh-keygen –t rsa –C  你的邮箱：生成公私钥</p>
<p>​    .ssh 文件位置：C:\Users\Administrator.ssh</p>
<p>​    ssh -T <a href="mailto:git@github.com">git@github.com</a> ：测试公私钥是否已经配对</p>
<h3 id="使用频率最高的五个命令"><a href="#使用频率最高的五个命令" class="headerlink" title="使用频率最高的五个命令"></a>使用频率最高的五个命令</h3><p>git status<br>git add<br>git commit<br>git push<br>git pull</p>
<p>经常用到的：<br>git pull origin 远程分支名:master 更新自己的代码到最新版<br>遇到冲突时：<br>git pull –rebase 拉下来master的代码 解决冲突后再<br>git rebase –continue</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>07_总结</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/07-%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<ol>
<li><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a><strong>安装</strong></h3><p>git –version</p>
</li>
<li><h3 id="初始化配置"><a href="#初始化配置" class="headerlink" title="初始化配置"></a><strong>初始化配置</strong></h3><p>git config –global user.name “damu”<br>git config –global user.email </p>
<p>git config –list</p>
<a id="more"></a>
</li>
<li><h3 id="初始化仓库"><a href="#初始化仓库" class="headerlink" title="初始化仓库"></a><strong>初始化仓库</strong></h3><p>git init</p>
</li>
<li><h3 id="C-新增"><a href="#C-新增" class="headerlink" title="C(新增)"></a><strong>C(新增)</strong></h3><p>在工作目录中新增文件<br>git status<br>git add ./<br>git commit -m “msg”  </p>
</li>
<li><h3 id="U-修改"><a href="#U-修改" class="headerlink" title="U(修改)"></a><strong>U(修改)</strong></h3><p>在工作目录中修改文件<br>git status<br>git add ./<br>git commit -m “msg”</p>
</li>
<li><h3 id="D-删除-amp-重命名"><a href="#D-删除-amp-重命名" class="headerlink" title="D(删除&amp;重命名)"></a><strong>D(删除&amp;重命名)</strong></h3><p>git rm 要删除的文件     git mv 老文件 新文件<br>git  status             git  status<br>git commit -m “msg”     git commit -m “msg”</p>
</li>
<li><h3 id="R-查询"><a href="#R-查询" class="headerlink" title="R(查询)"></a><strong>R(查询)</strong></h3><p>git  status   :  查看工作目录中文件的状态(已跟踪(已提交 已暂存 已修改) 未跟踪)<br>git  diff     :  查看未暂存的修改<br>git  diff –cache : 查看未提交的暂存<br>git  log –oneline : 查看提交记录</p>
</li>
<li><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a><strong>分支</strong></h3><p>分支的本质其实就是一个提交对象!!!<br>HEAD: </p>
<pre><code>是一个指针 它默认指向master分支 切换分支时其实就是让HEAD指向不同的分支
每次有新的提交时 HEAD都会带着当前指向的分支 一起往前移动</code></pre>
<p>git  log –oneline –decorate –graph –all : 查看整个项目的分支图<br>git branch : 查看分支列表<br>git branch -v: 查看分支指向的最新的提交<br>git branch name : 在当前提交对象上创建新的分支<br>git branch name commithash: 在指定的提交对象上创建新的分支<br>git checkout name :     切换分支<br>git branch -d name : 删除空的分支 删除已经被合并的分支<br>git branch -D name : 强制删除分支</p>
</li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据类型1</title>
    <url>/JS/%E7%AC%94%E8%AE%B0/js/1.1.JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>JavaScript 规定了 7 种语言类型，用于变量、函数参数、表达式、函数返回值等：</p>
<ol>
<li>Undefined</li>
<li>Null</li>
<li>Boolean</li>
<li>String</li>
<li>Number</li>
<li>Symbol</li>
<li>Object</li>
</ol>
<p>其中，又分为<strong>基本数据类型</strong>和<strong>引用数据类型</strong>：</p>
<a id="more"></a>

<h3 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h3><p>number、string、boolean、null、 undefined、symbol（ES6）</p>
<p>基本数据类型的变量是保存在栈内存中的，基本数据类型的值直接在栈内存中存储，值与值之间是独立存在的，修改一个变量不会影响其他的变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a &#x3D; 10</span><br><span class="line">var b &#x3D; a</span><br><span class="line">b &#x3D; 20</span><br><span class="line">console.log(a) &#x2F;&#x2F; 10</span><br><span class="line">console.log(b) &#x2F;&#x2F; 20</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201006133331604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="引用数据类型"><a href="#引用数据类型" class="headerlink" title="引用数据类型"></a>引用数据类型</h3><p>Object（在 JS 中除了基本数据类型以外的都是对象，数据是对象，函数是对象，正则表达式是对象）</p>
<p>对象是保存在堆内存中的，每创建一个新的对象，就会在堆内存中开辟出一个新的空间，而变量在栈内存中保存的是一个指针（指向对象在堆内存中的引用地址，通过这个引用地址可以快速查找到保存在堆内存中的对象）。如果两个变量保存的是同一个对象引用，当修改其中一个变量修改属性时，另一个也会受到影响。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj1 &#x3D; new Object()</span><br><span class="line">var obj2 &#x3D; obj1</span><br><span class="line">obj2.name &#x3D; &#39;我&#39;</span><br><span class="line">console.log(obj1.name) &#x2F;&#x2F; 我</span><br></pre></td></tr></table></figure>
<p><img src="https://img-blog.csdnimg.cn/20201006133331700.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="一、Undefined-Null"><a href="#一、Undefined-Null" class="headerlink" title="一、Undefined Null"></a>一、Undefined Null</h3><p>任何变量在赋值前都是 Undefined 类型，值为 undefined。</p>
<p>void 运算可以把任意一个表达式变成 undefined 值。</p>
<h4 id="void-运算符"><a href="#void-运算符" class="headerlink" title="void 运算符"></a>void 运算符</h4><p>对给定的表达式进行求值，然后返回 undefined</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function a() &#123;</span><br><span class="line">  console.log(&#39;aaa&#39;)</span><br><span class="line">&#125;</span><br><span class="line">console.log(void a())</span><br></pre></td></tr></table></figure>
<p>打印结果：aaa 和 undefined</p>
<h4 id="void-0-可以代替-undefined，好处"><a href="#void-0-可以代替-undefined，好处" class="headerlink" title="void 0 可以代替 undefined，好处"></a>void 0 可以代替 undefined，好处</h4><ol>
<li>void 0 比 undefined 省 3 个字节</li>
<li>避免 undefined 被重写(undefined 是一个变量，而并非是一个关键字，为避免无意中篡改)</li>
</ol>
<h4 id="Null"><a href="#Null" class="headerlink" title="Null"></a>Null</h4><p>null:定义了但是为空</p>
<p>编程中，我们一般不会把变量赋值为 undefined，为了保证所有值为 undefined 的变量都是从未赋值的自然状态。</p>
<p>Null 类型也只有一个值 null，与 undefined 不同，是 JavaScript 关键字。所以可以放心用 null 关键字来获取 null 值。</p>
<blockquote>
<p>undefined：定义了未赋值</p>
<p>null：定义了也赋值了，值为 null</p>
</blockquote>
<p><strong>什么时候给对象赋值为 null</strong></p>
<ol>
<li>初始赋值，表明变量将会被赋值为对象</li>
<li>结束前，切断变量与它此前引用的对象之间的联系，被垃圾回收器回收</li>
</ol>
<h3 id="二、Boolean"><a href="#二、Boolean" class="headerlink" title="二、Boolean"></a>二、Boolean</h3><p>Boolean 类型的两个值：true 和 false，表示逻辑意义上的真和假，同样都是关键字。</p>
<h3 id="三、String"><a href="#三、String" class="headerlink" title="三、String"></a>三、String</h3><p>字符串一旦构造出来，就永远无法变更。字符串的最大长度为 2^53-1(针对的是字符串的 UTF16 编码)</p>
<h3 id="四、Number"><a href="#四、Number" class="headerlink" title="四、Number"></a>四、Number</h3><p>基本符合双精度浮点数规则。Number 类型中有效的整数范围是 -0x1fffffffffffff 至 0x1fffffffffffff，所以 Number 无法精确表示此范围外的整数。</p>
<ul>
<li>NaN，代表非数字值的特殊值。该属性用于指示某个值不是数字。可以把 Number 对象设置为该值，来指示其不是数字值。</li>
<li>Infinity，无穷大</li>
<li>-Infinity，负无穷大</li>
</ul>
<p>根据浮点数的定义，非整数的 Number 类型无法用 ==（=== 也不行） 来比较 ：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(0.1 + 0.2 &#x3D;&#x3D; 0.3)</span><br></pre></td></tr></table></figure>
<p>输出结果为 false。</p>
<p>浮点运算的精度问题导致等式左右的结果并不是严格相等，而是相差了个微小的值。</p>
<p>正确的比较方法是使用 JavaScript 提供的最小精度值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(Math.abs(0.1 + 0.2 - 0.3) &lt;&#x3D; Number.EPSILON)</span><br></pre></td></tr></table></figure>
<p>检查等式左右两边差的绝对值是否小于最小精度，才是正确的比较浮点数的方法。这段代码结果是 true。</p>
<h3 id="五、Symbol"><a href="#五、Symbol" class="headerlink" title="五、Symbol"></a>五、Symbol</h3><p>Symbol 是 ES6 中引入的新类型，它是一切非字符串的对象 key 的集合。</p>
<p>创建 Symbol 的方式是使用全局的 Symbol 函数 :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var mySymbol &#x3D; Symbol(&#39;my symbol&#39;)</span><br></pre></td></tr></table></figure>
<p>Symbol.iterator(迭代器)可以自定义 for…of 在对象上的行为</p>
<h3 id="六、Object"><a href="#六、Object" class="headerlink" title="六、Object"></a>六、Object</h3><p>对象：属性的集合。属性分为数据属性和访问器属性，都是 key-value 结构。key 可以使字符串或者 Symbol 类型。</p>
<h3 id="对象类型"><a href="#对象类型" class="headerlink" title="对象类型"></a>对象类型</h3><p>这几个<strong>基本类型</strong>都在<strong>对象类型</strong>中有相似的“亲戚”：</p>
<ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Symbol</li>
</ul>
<p>所以，3 与 new Number(3) 是完全不同的值，前者是基本类型中的 Number 类型，后者是对象类型。</p>
<p>前三个的构造器是两用的，与 new 搭配时产生对象；直接调用时，表示强制类型转换。</p>
<p>而最后一个 Symbol 类型直接用 new 调用会抛出错误，但仍是 Symbol 对象的构造器。</p>
<p>JS 语言设计上试图模糊对象和基本类型之间的关系，日常代码可以把对象的方法在基本类型上使用，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">console.log(&#39;abc&#39;.charAt(0)) &#x2F;&#x2F;a</span><br></pre></td></tr></table></figure>
<p>甚至，我们在原型上添加的方法都可以应用于基本类型，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Symbol.prototype.hello &#x3D; () &#x3D;&gt; console.log(&#39;hello&#39;)</span><br><span class="line"></span><br><span class="line">var a &#x3D; Symbol(&#39;a&#39;)</span><br><span class="line">console.log(typeof a) &#x2F;&#x2F; symbol，a 并非对象类型</span><br><span class="line">a.hello() &#x2F;&#x2F; hello, 添加的方法有效</span><br></pre></td></tr></table></figure>
<p>所以我们能在基础类型上调用对应对象的方法，是因为运算符提供了装箱操作，它会根据基础类型构造一个临时对象。</p>
<h4 id="装箱"><a href="#装箱" class="headerlink" title="装箱"></a>装箱</h4><p>把基本类型转化为对应的对象类型的操作。</p>
<h4 id="拆箱"><a href="#拆箱" class="headerlink" title="拆箱"></a>拆箱</h4><p>将对象类型转换为对应的基本类型的值的操作。</p>
<p>它是通过所有对象都继承的两个转换方法 valueOf() 或者 toString() 来实现的：</p>
<p>**toString()**：它的作用是返回一个这个对象的字符串</p>
<p>**valueOf()**：它的作用是返回对象类型相应的原始值</p>
<p><img src="https://img-blog.csdnimg.cn/20201027094348515.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>调用顺序：</p>
<p>当遇到 <code>Number()、+、==、&lt;、&gt;</code> 等运算符时会先调用 valueOf()，没有返回基本类型再去调用 toString()；</p>
<p>当遇到 String()、alert() 等会先调用 toString()，没有返回基本类型再去调用 valueOf()；</p>
<p>如果 valueOf 和 toString 都不存在，或者没有返回基本类型，则会产生类型错误 TypeError。</p>
<h4 id="显性转换"><a href="#显性转换" class="headerlink" title="显性转换"></a>显性转换</h4><p>直接用 String()，Boolean()，Number() 来进行转换的</p>
<h4 id="隐性转换"><a href="#隐性转换" class="headerlink" title="隐性转换"></a>隐性转换</h4><p>在内部进行，甚至可能用到 String()，Boolean()，Number() 中的多个来进行转换：</p>
<p>1.当使用 <code>if，?:，&amp;&amp;，||</code> 等操作的时候进行 Boolean() 转换。</p>
<p>2.当使用 <code>+，-，*，/，==，&gt;，&lt;</code> 等操作符的时候进行 Number() 转换。</p>
<p>而 <code>+</code> 号比较特殊，因为它既可以作为字符串连接符号又可以作为数字的加号。因此就会有 1 + 1 结果为 2，而 1 + ‘1’ 结果为 ‘11’ 的情况，因为这个时候加号的作用不同。</p>
<p>各种类型在不同时候加号的不同含义：</p>
<p><img src="https://img-blog.csdnimg.cn/20201027094351583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<p>注意：</p>
<ol>
<li>Date 对象，本来 valueOf 返回的是时间戳，但是 + 1 的时候是先调用 toString 返回的字符串</li>
<li>自定义 Object，虽然 + ‘1’ 是属于字符串连接，但是先调用的是 valueOf() 返回的是 567</li>
<li>数组 [1,2,3] 遇到 + 1 的情况时，相当于 Number()，先调用 valueOf() 返回的是 [1,2,3] 不是基本类型，所以接着调用 toString() 返回 ‘1,2,3’</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>js数据类型2</title>
    <url>/JS/%E7%AC%94%E8%AE%B0/js/1.2.JS%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    <content><![CDATA[<h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><p>因为 JS 是弱类型语言，所以类型转换发生非常频繁。</p>
<p>在 <code>JS</code> 中类型转换只有三种情况，分别是：</p>
<ul>
<li>转换为布尔值</li>
<li>转换为数字</li>
<li>转换为字符串</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201027094718348.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="对象转原始类型"><a href="#对象转原始类型" class="headerlink" title="对象转原始类型"></a>对象转原始类型</h3><p>对象类型遇到原始类型时，就会多重隐性转换。（思路是：先将对象类型变成原始类型，再通过原始类型的转换来达到效果）</p>
<p>在转换类型的时候，会调用内置的 <code>[[ToPrimitive]]</code> 函数，对于该函数来说，算法逻辑一般来说如下：</p>
<ul>
<li>如果已经是用原始类型的构造函数 new 出来的，那就不需要转换了</li>
<li>先调用 <code>x.valueOf()</code> 转换为基本类型，就返回转换的值</li>
<li>然后调用 <code>x.toString()</code> 转换为基本类型，就返回转换的值</li>
<li>如果都没有返回原始类型，就报错</li>
</ul>
<p>也可以重写 <code>Symbol.toPrimitive</code>，该方法在转原始类型时调用优先级最高。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return 0</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return 1</span><br><span class="line">  &#125;,</span><br><span class="line">  [Symbol.toPrimitive]() &#123;</span><br><span class="line">    return 2</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(1 + a) &#x2F;&#x2F; 3</span><br><span class="line">&#x2F;&#x2F; 先重写,再valueOf,再toString</span><br></pre></td></tr></table></figure>
<h3 id="四则运算符"><a href="#四则运算符" class="headerlink" title="四则运算符"></a>四则运算符</h3><p>运算时进行隐式转换。它有以下几个特点：</p>
<ul>
<li>运算中其中一方为字符串，那么就会把另一方也转换为字符串</li>
<li>如果一方不是字符串或者数字，那么会将它转换为数字或者字符串</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1 + &#39;1&#39; &#x2F;&#x2F; &#39;11&#39; 触发特点一，将数字 1 转换为字符串</span><br><span class="line">true + true &#x2F;&#x2F; 2 触发特点二，将 true 转为数字 1</span><br><span class="line">4 + [1, 2, 3] &#x2F;&#x2F; &quot;41,2,3&quot; 触发特点二，将数组通过 toString 转为字符串 1,2,3</span><br></pre></td></tr></table></figure>
<ul>
<li>在加法中：<code>+ &#39;b&#39;</code> 等于 <code>NaN</code>， <code>+ &#39;1&#39;</code> 等于 1，可以用来快速获取 <code>number</code> 类型。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;a&#39; +</span><br><span class="line">  +&#39;b&#39; + &#x2F;&#x2F; -&gt; &#39;aNaN&#39;</span><br><span class="line">  &#39;1&#39; &#x3D;&#x3D;&#x3D;</span><br><span class="line">  1 &#x2F;&#x2F; -&gt; true</span><br></pre></td></tr></table></figure>
<ul>
<li>对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4 * &#39;3&#39; &#x2F;&#x2F; 12</span><br><span class="line">4 * [] &#x2F;&#x2F; 0</span><br><span class="line">4 * [1, 2] &#x2F;&#x2F; NaN</span><br></pre></td></tr></table></figure>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><ul>
<li>如果是对象，就通过 <code>toPrimitive</code> 转换对象</li>
<li>如果是字符串，就通过 <code>unicode</code> 字符索引来比较</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123;</span><br><span class="line">  valueOf() &#123;</span><br><span class="line">    return 0</span><br><span class="line">  &#125;,</span><br><span class="line">  toString() &#123;</span><br><span class="line">    return &#39;2&#39;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">console.log(a &gt; 1) &#x2F;&#x2F; false</span><br><span class="line">&#x2F;&#x2F; 因为 a 是对象，所以会通过 valueOf 转换为原始类型再比较值。</span><br><span class="line">&#x2F;&#x2F; 先</span><br></pre></td></tr></table></figure>
<h2 id="三种判断值数据类型的方法"><a href="#三种判断值数据类型的方法" class="headerlink" title="三种判断值数据类型的方法"></a>三种判断值数据类型的方法</h2><h3 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h3><p>只能判断为 number、string、boolean、symbol、undefined、function 这几种类型，</p>
<p>而遇到 <code>null</code>、<code>array</code>、<code>object</code> 以及函数实例 <code>new + 函数</code> 时，得到的都是 <code>object</code> ，</p>
<p>对于 null -&gt; “object” 的问题，仅仅 typeof 无解，记住有这么个坑即可。</p>
<p>而关于 array -&gt; “object” 的问题，可以使用 <code>Array.isArray([]) // true</code> 来判断。</p>
<p>由此引出 instanceof。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><code>typeof</code> 对于基本类型，除了 <code>null</code> 都可以显示正确的类型</p>
<p>typeof 对于对象，除了函数都会显示 object</p>
<h3 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h3><p>意为实例，这个运算符用来测试一个对象在其原型链中是否存在一个构造函数的 prototype 属性，返回值为 true 或 false</p>
<p>涉及的构造函数有这些基础类型：String、Number、Boolean、Undefined、Null、Symbol；</p>
<p>复杂类型：Array，Object；</p>
<p>其他类型：Function、RegExp、Date。</p>
<p>语法：[对象] instanceof [构造函数]，<strong>注意左侧必须是对象（object），如果不是，直接返回 false。</strong></p>
<blockquote>
<p>所以，instanceof 不能用来判断基本类型，但可以判断对象类型中用基本类型的构造函数 new 出来的</p>
</blockquote>
<h4 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h4><p>Number、String、Boolean、Symbol、Undefined、Null</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let num &#x3D; 1</span><br><span class="line">num instanceof Number &#x2F;&#x2F; false</span><br><span class="line"></span><br><span class="line">num &#x3D; new Number(1)</span><br><span class="line">num instanceof Number &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>明明都是 num，而且都是 1，只是因为第一个不是对象，是基本类型，所以直接返回 false，而第二个是封装成对象，所以 true。string、boolean，也是一样的。</p>
<blockquote>
<p>new String(1 )与 String(1) 是不同的，new 是封装成对象，而没有 new 的只是基础类型转换，还是基础类型</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let s &#x3D; new String(1) &#x2F;&#x2F; String &#123;&quot;1&quot;&#125;</span><br><span class="line">let w &#x3D; String(1) &#x2F;&#x2F; &quot;1&quot;</span><br><span class="line"></span><br><span class="line">console.log(typeof s) &#x2F;&#x2F;object</span><br><span class="line">console.log(typeof w) &#x2F;&#x2F;string</span><br><span class="line"></span><br><span class="line">console.log(s instanceof String) &#x2F;&#x2F;true</span><br><span class="line">console.log(w instanceof String) &#x2F;&#x2F;false</span><br></pre></td></tr></table></figure>
<h4 id="复杂类型"><a href="#复杂类型" class="headerlink" title="复杂类型"></a><strong>复杂类型</strong></h4><p>Array、Object</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let arr &#x3D; []</span><br><span class="line">arr instanceof Array &#x2F;&#x2F; true</span><br><span class="line">arr instanceof Object &#x2F;&#x2F; true</span><br><span class="line">Array.isArray(arr) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>因为字面量是直接生成构造函数的，所以不会像基本类型一样有两种情况，可以放心使用。</p>
<p>但是与 Object 对比时，由于 Object 在原型链的上层，所以都会返回 true</p>
<h4 id="其他类型"><a href="#其他类型" class="headerlink" title="其他类型"></a>其他类型</h4><p>或者是 RegExp、Date、HTMLDivElement</p>
<p>与上面的类型一样</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let reg &#x3D; new RegExp()</span><br><span class="line">reg instanceof RegExp &#x2F;&#x2F; true</span><br><span class="line">reg instanceof Object &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">let date &#x3D; new Date()</span><br><span class="line">date instanceof Date &#x2F;&#x2F; true</span><br><span class="line">date instanceof Object &#x2F;&#x2F; true</span><br><span class="line"></span><br><span class="line">let s &#x3D; document.getElementById(&#39;123&#39;)</span><br><span class="line">s instanceof HTMLDivElement &#x2F;&#x2F; true</span><br><span class="line">s instanceof Object &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>除了 Function，自定义的构造函数/类：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function A() &#123;&#125;</span><br><span class="line">let a &#x3D; new A()</span><br><span class="line"></span><br><span class="line">console.log(typeof a) &#x2F;&#x2F; object</span><br><span class="line">console.log(typeof A) &#x2F;&#x2F; function</span><br><span class="line"></span><br><span class="line">console.log(a instanceof Function) &#x2F;&#x2F; false</span><br><span class="line">console.log(a instanceof Object) &#x2F;&#x2F; true</span><br><span class="line">console.log(a instanceof A) &#x2F;&#x2F; true</span><br><span class="line">console.log(A instanceof Function) &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>这里要注意，<code>function A() &#123;&#125;</code> 相当于 <code>let A; A = function() &#123;&#125;</code>：</p>
<ol>
<li>a 是 new 出来，所以是经过构造，因此已经是对象，不再是函数</li>
<li>A 是个函数，因此没什么概念上的问题。但是要知道 <code>A.__proto__</code> 即 <code>Function.prototype</code> 是 <code>ƒ () &#123; [native code] &#125;</code>，这是与 object 一样处于原型链上层的存在，而且与 object 平级</li>
</ol>
<h3 id="Object-prototype-toString-call"><a href="#Object-prototype-toString-call" class="headerlink" title="Object.prototype.toString.call()"></a>Object.prototype.toString.call()</h3><p>可以判断 [object Number]、[object String]、[object Boolean]、[object Symbol]、[object Null]、[object Undefined]、[object RegExp]、[object Date]、[object Array]、[object HTMLDivElement]这几种类型，其他都是[object Object]</p>
<h2 id="相等比较"><a href="#相等比较" class="headerlink" title="相等比较"></a>相等比较</h2><h3 id><a href="#" class="headerlink" title="=="></a>==</h3><p>在比较的时候会强制转换左右两边的数据类型</p>
<ul>
<li><p>对象 == 对象：比较地址</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123;&#125;</span><br><span class="line">let b &#x3D; &#123;&#125;</span><br><span class="line">a &#x3D;&#x3D; b &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure></li>
<li><p>对象 == 字符串：对象转换为字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let a &#x3D; &#123;&#125;</span><br><span class="line">a &#x3D;&#x3D; &#39;[object Object]&#39; &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure></li>
<li><p>NaN == NaN：NaN 和自己以及其他值比较都不相等</p>
</li>
<li><p>null == undefined：在两个等于号下相等，三个等于号下不相等，并且和自己比较相等，和其他值比较都不相等</p>
</li>
<li><p>剩下的情况，只要两边类型不同，都转换为数字（遇到 <code>!</code> 会先转换为 boolean 再转换为数字）</p>
<ul>
<li><p>只有这 5 个可以转换为 boolean 的 false：<code>null</code>、<code>undefined</code>、<code>NaN</code>、<code>&#39;&#39;</code>（空字符串）、<code>0</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">!null &#x2F;&#x2F; true</span><br><span class="line">!undefined &#x2F;&#x2F; true</span><br><span class="line">!NaN &#x2F;&#x2F; true</span><br><span class="line">!&#39;&#39; &#x2F;&#x2F; true</span><br><span class="line">!0 &#x2F;&#x2F; true</span><br><span class="line">![] &#x2F;&#x2F; false 引用类型转boolean都为true</span><br><span class="line">!&#39; &#39; &#x2F;&#x2F; false &#x2F;&#x2F;字符串转boolean，除了空串都为true</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p>遇到 [] 时，先 .toString() 转为字符串，字符串再变成数字</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[] &#x3D;&#x3D; false &#x2F;&#x2F; true，都转为数字再进行比较：先把[].toString()转为字符串，空字符串再变成数字0（Number(&#39;&#39;) &#x3D;&#x3D;&gt; 0），false转换为数字是0</span><br><span class="line">[0] &#x3D;&#x3D; false &#x2F;&#x2F; true，Number([0].toString()) --&gt; 0</span><br><span class="line">[1] &#x3D;&#x3D; true &#x2F;&#x2F; true，Number([1].toString()) --&gt; 1</span><br><span class="line">[2] &#x3D;&#x3D; true &#x2F;&#x2F; false，Number([2].toString()) --&gt; 2</span><br><span class="line">[] &#x3D;&#x3D; ![] &#x2F;&#x2F; true</span><br><span class="line">&#39; &#39; &#x3D;&#x3D; !&#39; &#39; &#x2F;&#x2F; true，Number(&#39; &#39;) &#x3D;&#x3D;&gt; 0</span><br><span class="line">+0 &#x3D;&#x3D; -0 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<p>数组的 toString 转化为字符串，而对象的 toString 相当于 <code>Object.prototype.toString.call()</code> 结果是 <code>&quot;[object Object]&quot;</code></p>
</li>
</ul>
<p><img src="https://img-blog.csdnimg.cn/20201027111751868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h3 id="-1"><a href="#-1" class="headerlink" title="==="></a>===</h3><p>三等运算符更加严格并且不会将操作数进行强制类型转换。然而三等运算符也不是最好的解决方案，也存在问题：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">NaN &#x3D;&#x3D;&#x3D; NaN &#x2F;&#x2F; false</span><br><span class="line">+0 &#x3D;&#x3D;&#x3D; -0 &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>
<h3 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h3><p>在 ES6 中有一个新的 <code>Object.is()</code>，它更精确，它具有与 <code>===</code> 相同的功能，而且在某些特殊情况下，其表现还不错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Object.is(+0, -0) &#x2F;&#x2F; false</span><br><span class="line">Object.is(NaN, NaN) &#x2F;&#x2F; true</span><br><span class="line">Object.is(null, undefined) &#x2F;&#x2F; false</span><br><span class="line">Object.is([1], true) &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>
<h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><img src="https://img-blog.csdnimg.cn/20201006133331649.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQwNTA4ODMy,size_16,color_FFFFFF,t_70#pic_center" alt="img"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://qiutianaimeili.com/html/page/2017/08/ap8d1w6oml.html">js 的隐性类型转换与 valueOf 和 toString</a></p>
<p><a href="http://poetries1.gitee.io/fe-interview/docs/excellent.html#_2-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">FE-Inte-类型转换</a></p>
]]></content>
      <categories>
        <category>JS</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>执行函数和this</title>
    <url>/JS/%E7%AC%94%E8%AE%B0/js/10.%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E5%92%8Cthis/</url>
    <content><![CDATA[<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p><strong>第一种，普通函数：用 function 关键字定义的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第二种，箭头函数：用 =&gt; 运算符定义的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第三种，在 class 中定义的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第四种，生成器函数：用 function * 定义的函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第五种，类：用 class 定义的类，实际上也是函数</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">constructor</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>第六种，异步函数：普通函数、箭头函数和生成器函数加上 async 关键字</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">async</span> () =&gt; &#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对普通变量而言，这些函数并没有本质区别，都是遵循了“继承定义时环境”的规则，它们的一个行为差异在于 this 关键字。</p>
<h3 id="this-关键字的行为"><a href="#this-关键字的行为" class="headerlink" title="this 关键字的行为"></a>this 关键字的行为</h3><p>this 是执行上下文中很重要的一个组成部分。同一个函数调用方式不同，得到的 this 值也不同。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showThis</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    showThis: showThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// global</span></span><br><span class="line">o.showThis(); <span class="comment">// o</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，定义了函数 showThis，并把它赋值给一个对象 o 的属性，然后尝试分别使用两个引用来调用同一个函数，结果得到了不同的 this 值。</p>
<p><strong>调用函数时使用的引用，决定了函数执行时刻的 this 值。</strong></p>
<p>换成箭头函数，结果就不一样了：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> showThis = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    showThis: showThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// global</span></span><br><span class="line">o.showThis(); <span class="comment">// global</span></span><br></pre></td></tr></table></figure>
<p><strong>改为箭头函数后，不论用什么引用来调用它，都不影响它的 this 值。</strong></p>
<p>换成”方法”：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="title">showThis</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> C();</span><br><span class="line"><span class="keyword">var</span> showThis = o.showThis;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// undefined</span></span><br><span class="line">o.showThis(); <span class="comment">// o</span></span><br></pre></td></tr></table></figure>
<p>创建了一个类 C，并且实例化出对象 o，再把 o 的方法赋值给了变量 showThis。</p>
<p>使用 showThis 这个引用去调用方法时，得到了 undefined。</p>
<p>所以，在方法中， this 的行为也不太一样，它得到了 undefined 的结果。方法的行为跟普通函数有差异，是因为 <strong>class</strong> 设计成了默认按 <strong>strict 模式</strong>执行。</p>
<p>再举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;Jay Global&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">&#x27;Jay Person&#x27;</span>,</span><br><span class="line">    details: &#123;</span><br><span class="line">        name: <span class="string">&#x27;Jay Details&#x27;</span>,</span><br><span class="line">        print: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    print: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(person.details.print());  <span class="comment">// Jay Details</span></span><br><span class="line"><span class="built_in">console</span>.log(person.print());          <span class="comment">// Jay Person</span></span><br><span class="line"><span class="keyword">var</span> name1 = person.print;</span><br><span class="line"><span class="keyword">var</span> name2 = person.details;</span><br><span class="line"><span class="built_in">console</span>.log(name1()); <span class="comment">// Jay Global</span></span><br><span class="line"><span class="built_in">console</span>.log(name2.print()) <span class="comment">// Jay Details</span></span><br></pre></td></tr></table></figure>
<h3 id="this-关键字的机制"><a href="#this-关键字的机制" class="headerlink" title="this 关键字的机制"></a>this 关键字的机制</h3><h4 id="切换上下文"><a href="#切换上下文" class="headerlink" title="切换上下文"></a>切换上下文</h4><p>函数能够引用定义时的变量，如上文分析，函数也能记住定义时的 this，因此，函数内部必定有一个机制来保存这些信息。</p>
<p>在 JS 中，为函数规定了用来保存定义时上下文的私有属性[[Environment]]。当一个函数执行时，会创建一条新的执行环境记录，记录的外层词法环境（outer lexical environment）会被设置成函数的[[Environment]]。</p>
<p>这个动作就是<strong>切换上下文</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// foo.js 文件</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">exports</span>.foo = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(b); <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">console</span>.log(a); <span class="comment">// error</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// main.js 文件</span></span><br><span class="line"><span class="keyword">const</span> &#123; foo &#125; = <span class="built_in">require</span>(<span class="string">&#x27;./foo&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在Node环境下执行 main.js，b打印成功，a发生 ReferenceError错误</span></span><br></pre></td></tr></table></figure>
<p>这里的 foo 能够访问 b（定义时词法环境），却不能访问 a（执行时的词法环境），这就是执行上下文的切换机制。</p>
<p>JS 用一个栈来管理执行上下文，这个栈中的每一项又包含一个链表。当函数调用时，会入栈一个新的执行上下文，函数调用结束时，执行上下文被出栈。</p>
<p>而 this 则是一个更为复杂的机制，JavaScript 标准定义了 [[thisMode]] 私有属性。</p>
<p>[[thisMode]] 私有属性有三个取值。</p>
<ul>
<li>lexical：表示从上下文中找 this，这对应了箭头函数。</li>
<li>global：表示当 this 为 undefined 时，取全局对象，对应了普通函数。</li>
<li>strict：当严格模式时使用，this 严格按照调用时传入的值，可能为 null 或者 undefined。</li>
</ul>
<p>方法的行为跟普通函数有差异，恰恰是因为 class 设计成了默认按 strict 模式执行。</p>
<p>可以用 strict 达成与上一节中方法的例子一样的效果:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">showThis</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">    showThis: showThis</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">showThis(); <span class="comment">// undefined</span></span><br><span class="line">o.showThis(); <span class="comment">// o</span></span><br></pre></td></tr></table></figure>
<p>函数创建新的执行上下文中的词法环境记录时，会根据[[thisMode]]来标记新纪录的[[ThisBindingStatus]]私有属性。代码执行遇到 this 时，会逐层检查当前词法环境记录中的[[ThisBindingStatus]]，当找到有 this 的环境记录时获取 this 的值。</p>
<p>这样的规则的实际效果是，<strong>嵌套的箭头函数中的代码都指向外层 this</strong></p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;&#125;</span><br><span class="line">o.foo = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>); </span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123; </span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>); </span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="built_in">this</span>); </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">o.foo()()(); <span class="comment">// o, o, o</span></span><br></pre></td></tr></table></figure>
<p>这个例子中，我们定义了三层嵌套的函数，最外层为普通函数，两层都是箭头函数。这里调用三个函数，获得的 this 值是一致的，都是对象 o。</p>
<h3 id="操作-this-的内置函数"><a href="#操作-this-的内置函数" class="headerlink" title="操作 this 的内置函数"></a>操作 this 的内置函数</h3><p>Function.prototype.call 和 Function.prototype.apply 可以指定函数调用时传入的 this 值。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">    <span class="built_in">console</span>.log(a, b, c);</span><br><span class="line">&#125;</span><br><span class="line">foo.call(&#123;&#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//1 2 3</span></span><br><span class="line">foo.apply(&#123;&#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure>
<p>call 和 apply 作用是一样的，只是传参方式有区别。</p>
<p>此外，还有 Function.prototype.bind 它可以生成一个绑定过的函数，这个函数的 this 值固定了参数。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">a, b, c</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(a, b, c)</span><br><span class="line">&#125;</span><br><span class="line">foo.bind(&#123;&#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)();</span><br><span class="line"><span class="comment">//&#123;&#125;</span></span><br><span class="line"><span class="comment">//1 2 3</span></span><br></pre></td></tr></table></figure>
<p>call、bind 和 apply 用于不接受 this 的函数类型如箭头、class 都不会报错。这时候，它们无法实现改变 this 的能力，但是可以实现传参。</p>
<p>this 关键字是为了在 JS 中加入动态作用域而做的努力。 所谓动态作用域，就是说变量的作用范围，是根据函数调用的位置而定的。从这个角度来理解 this，就简单的多。</p>
<p>this 是 JS 中的动态作用域机制, 具体来说有四种, 优先级有低到高分别如下：</p>
<ol>
<li>默认的 this 绑定，就是说 在一个函数中使用了 this，但是没有为 this 绑定对象。这种情况下，非严格默认，this 就是全局变量 Node 环境中的 global，浏览器环境中的 window。严格模式下，默认的 this 就是 undefined 了。</li>
<li>隐式绑定: 使用 obj.foo() 这样的语法来调用函数的时候，函数 foo 中的 this 绑定到 obj 对象。</li>
<li>显示绑定: foo.call(obj, …)， foo.apply(obj,[…])，foo.bind(obj,…)</li>
<li>构造绑定: new foo() ， 这种情况,，无论 foo 是否做了绑定, 都要创建一个新的对象， 然后 foo 中的 this 引用这个对象。</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>js面向对象、基于对象</title>
    <url>/JS/%E7%AC%94%E8%AE%B0/js/2.JS%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E3%80%81%E5%9F%BA%E4%BA%8E%E5%AF%B9%E8%B1%A1/</url>
    <content><![CDATA[<h2 id="对象的基本特征"><a href="#对象的基本特征" class="headerlink" title="对象的基本特征"></a>对象的基本特征</h2><ol>
<li>对象具有唯一标识性：即使完全相同的两个对象，也并非同一个对象。</li>
<li>对象有状态：同一对象可能处于不同状态之下。</li>
<li>对象有行为：对象的状态可能因为它的行为产生变迁。</li>
</ol>
<h3 id="第一个特征："><a href="#第一个特征：" class="headerlink" title="第一个特征："></a>第一个特征：</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o1 = &#123;<span class="attr">a</span> : <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> o2 = &#123;<span class="attr">a</span> : <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o1 == o2); <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h3 id="第二个和第三个特征："><a href="#第二个和第三个特征：" class="headerlink" title="第二个和第三个特征："></a>第二个和第三个特征：</h3><table>
<thead>
<tr>
<th>JS</th>
<th>C++</th>
<th>JAVA</th>
</tr>
</thead>
<tbody><tr>
<td>状态</td>
<td>成员变量</td>
<td>属性</td>
</tr>
<tr>
<td>行为</td>
<td>成员函数</td>
<td>方法</td>
</tr>
</tbody></table>
<p>js中状态和行为统一抽象为“属性”</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  f: <span class="number">1</span>,</span><br><span class="line">  <span class="function"><span class="title">f</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.d);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>o是对象，d和函数f，尽管写法不太相同，但是在js中就都是普通属性。</p>
<h2 id="JS中对象独有特征"><a href="#JS中对象独有特征" class="headerlink" title="JS中对象独有特征"></a>JS中对象独有特征</h2><p>对象具有高度的动态性，因为js赋予了使用者在运行时为对象添加状态和行为的能力。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;<span class="attr">a</span> : <span class="number">1</span>&#125;;</span><br><span class="line">o.b = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">console</span>.log(o.a,o.b); <span class="comment">// 1 2</span></span><br></pre></td></tr></table></figure>
<h2 id="JS对象的两类属性"><a href="#JS对象的两类属性" class="headerlink" title="JS对象的两类属性"></a>JS对象的两类属性</h2><p>js属性并非知识简单的名称和值，js用一组特征(attribute)来描述属性(property)</p>
<h3 id="第一类属性：数据属性"><a href="#第一类属性：数据属性" class="headerlink" title="第一类属性：数据属性"></a>第一类属性：数据属性</h3><p>它具有四个<strong>特征</strong>：</p>
<ul>
<li>value: 属性的值。</li>
<li>writable: 决定属性能否被赋值。</li>
<li>enumerable: 决定for in能否枚举该属性。</li>
<li>configurable: 决定该属性能否被删除或者改变特征值。</li>
</ul>
<h3 id="第二类属性：访问器-getter-setter-属性"><a href="#第二类属性：访问器-getter-setter-属性" class="headerlink" title="第二类属性：访问器(getter/setter)属性"></a>第二类属性：访问器(getter/setter)属性</h3><p>它也具有四个<strong>特征</strong>：</p>
<ul>
<li>getter: 函数或undefined，在取属性值时被调用。</li>
<li>setter: 函数或undefined，在设置属性值时被调用。</li>
<li>enumerable: 决定for in能否枚举该属性。</li>
<li>configurable: 决定该属性能否被删除或者改变特征值。</li>
</ul>
<p>访问器属性使得属性在读和写时执行代码，它允许使用者在写和读属性时，得到完全不同的值，它可以视为一种函数的语法糖。</p>
<p>我们通常在用代码定义属性时，会产生数据属性。其中的writable、enumerable、configurable 都默认为 true。</p>
<p><strong>使用对象直接量创建的属性，writable、enumerable和configurable特性默认为true。</strong></p>
<p>我们可以使用<strong>内置函数 Object.getOwnPropertyDescripter</strong> 来<strong>查看</strong> ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;;</span><br><span class="line">o.b = <span class="number">2</span>;</span><br><span class="line"><span class="comment">//a和b皆为数据属性</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;a&quot;</span>))</span><br><span class="line"><span class="comment">// &#123;value: 1, writable: true, enumerable: true, configurable: true&#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;b&quot;</span>))</span><br><span class="line"><span class="comment">// &#123;value: 2, writable: true, enumerable: true, configurable: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果我们要想<strong>改变属性的特征</strong>，或者<strong>定义访问器属性</strong>，我们可以使用 <strong>Object.defineProperty</strong>:</p>
<p><strong>在使用Object.defineProperty、Object.defineProperties 或 Object.create 函数的情况下添加数据属性，writable、enumerable和configurable默认值为false。</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;; </span><br><span class="line"><span class="built_in">Object</span>.defineProperty(o, <span class="string">&quot;b&quot;</span>, &#123;<span class="attr">value</span>: <span class="number">2</span>, <span class="attr">writable</span>: <span class="literal">false</span>, <span class="attr">enumerable</span>: <span class="literal">false</span>,<span class="attr">configurable</span>: <span class="literal">true</span>&#125;); </span><br><span class="line"><span class="comment">//a和b都是数据属性，但特征值变化了 </span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyDescriptor(o,<span class="string">&quot;a&quot;</span>); </span><br><span class="line"><span class="comment">//&#123;value: 1, writable: true, enumerable: true, configurable: true&#125; Object.getOwnPropertyDescriptor(o,&quot;b&quot;); </span></span><br><span class="line"><span class="comment">//&#123;value: 2, writable: false, enumerable: false, configurable: true&#125; </span></span><br><span class="line">o.b = <span class="number">3</span>; <span class="comment">//这时想重新赋值</span></span><br><span class="line"><span class="built_in">console</span>.log(o.b); <span class="comment">// 2，因为writable被改为了false</span></span><br></pre></td></tr></table></figure>
<p>在创建对象时，也可以使用 get 和 set 关键字来创建访问器属性</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> o = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title">a</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//1</span></span><br></pre></td></tr></table></figure>
<p>js对象运行时是一个“属性的集合”：</p>
<table>
<thead>
<tr>
<th>key</th>
<th>value</th>
</tr>
</thead>
<tbody><tr>
<td>字符串/Symbol</td>
<td>数据属性特征值/访问器属性特征值</td>
</tr>
</tbody></table>
<p>以上面的对象 o 为例:</p>
<p>key:a</p>
<p>value:{writable:true,value:1,configurable:true,enumerable:true}</p>
]]></content>
      <categories>
        <category>JS</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>js类</title>
    <url>/JS/%E7%AC%94%E8%AE%B0/js/3.JS%E7%B1%BB/</url>
    <content><![CDATA[<p><strong>基于类的编程语言：C++、Java</strong>提倡使用一个关注分类和类之间关系开发模型。 总是先有类，再从类去实例化一个对象。类与类之间又可能会形成继承、组合等关系。</p>
<p><strong>基于原型：JS</strong>更为提倡程序员去关注一系列对象实例的行为，而后才去关心如何将这些对象，划分到最近的使用方式相似的原型对象，而不是将它们分成类。</p>
<h2 id="JS的原型模拟类"><a href="#JS的原型模拟类" class="headerlink" title="JS的原型模拟类"></a>JS的原型模拟类</h2><p>用两条概括：</p>
<ul>
<li>如果所有对象都有私有字段([prototype])，就是对象的原型；</li>
<li>读一个属性，如果对象本身没有，则会继续访问对象的原型，知道原型为空或者找到为止。</li>
</ul>
<p>ES6提供了一些列内置函数，以便更为直接地访问操纵原型。</p>
<p>三个方法分别为：</p>
<a id="more"></a>

<ul>
<li>Object.create 根据指定的原型创建新对象，原型可以是null;</li>
<li>Object.getPrototypeOf 获得一个对象的原型</li>
<li>Object.setPrototypeOf 设置一个对象的原型；</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> cat = &#123;</span><br><span class="line">  <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;meow~&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">jump</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;jump&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> tiger = <span class="built_in">Object</span>.create(cat, &#123;</span><br><span class="line">  say: &#123;</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;roar!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherCat = <span class="built_in">Object</span>.create(cat);</span><br><span class="line">anotherCat.say(); <span class="comment">// meow~</span></span><br><span class="line"><span class="keyword">var</span> anotherTiger = <span class="built_in">Object</span>.create(tiger);</span><br><span class="line">anotherTiger.say(); <span class="comment">// roar!</span></span><br></pre></td></tr></table></figure>
<h3 id="new-运算"><a href="#new-运算" class="headerlink" title="new 运算"></a>new 运算</h3><p>new 运算接受一个构造函数和一组调用参数，实际上做了几件事：</p>
<ul>
<li>以构造器的 prototype 属性为原型，创建新对象；</li>
<li>将构造函数的作用域赋给新对象(因此 this 就指向了这个新对象)；</li>
<li>执行构造函数中的代码(为这个新对象添加属性) ；</li>
<li>如果构造函数返回的是对象，则返回，否则返回第一步创建的对象。</li>
</ul>
<p>接下来我们就封装一个函数来模拟 new 操作符：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFunc</span>(<span class="params">fn, ...argv</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> o = &#123;&#125; <span class="comment">// 创建一个新对象</span></span><br><span class="line">    o.__proto__ = fn.prototype <span class="comment">// 新对象的原型指向构造函数的原型</span></span><br><span class="line">    <span class="keyword">const</span> val = fn.apply(o, argv)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> ? val : o</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = newFunc(Person, <span class="string">&#x27;wy&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name, person.age) <span class="comment">// wy 18</span></span><br><span class="line">person.say() <span class="comment">// hello!</span></span><br></pre></td></tr></table></figure>
<p>也可以运用ES6 中的一些新特性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newFunc</span>(<span class="params">fn, ...argv</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">const</span> o = <span class="built_in">Object</span>.create(fn.prototype)</span><br><span class="line">    <span class="keyword">const</span> val = fn.apply(o, argv)</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> val === <span class="string">&#x27;object&#x27;</span> ? val : o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&#x27;hello!&#x27;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">// 构造函数返回一个对象</span></span><br><span class="line">        name: name,</span><br><span class="line">        age: age,</span><br><span class="line">        <span class="function"><span class="title">say</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;Hi!&#x27;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> person = newFunc(Person, <span class="string">&#x27;wy&#x27;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.name, person.age) <span class="comment">// wy 18</span></span><br><span class="line">person.say() <span class="comment">// Hi!</span></span><br></pre></td></tr></table></figure>
<h2 id="ES6中的类"><a href="#ES6中的类" class="headerlink" title="ES6中的类"></a>ES6中的类</h2><p>ES5中没有类的概念，所以只能new function搭配，ES6 中加入了新特性 class</p>
<h3 id="类的基本写法"><a href="#类的基本写法" class="headerlink" title="类的基本写法"></a>类的基本写法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 构造器</span></span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">height, width</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.height = height;</span><br><span class="line">    <span class="built_in">this</span>.width = width;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Getter</span></span><br><span class="line">  <span class="keyword">get</span> <span class="title">area</span>() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.calcArea();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Method</span></span><br><span class="line">  <span class="function"><span class="title">calcArea</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">this</span>.height * <span class="built_in">this</span>.width;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的是，类提供了<strong>继承能力</strong>：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; makes a noise.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span> <span class="keyword">extends</span> <span class="title">Animal</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name); <span class="comment">// call the super class constructor and pass in the name parameter</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">speak</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name + <span class="string">&#x27; barks.&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> d = <span class="keyword">new</span> Dog(<span class="string">&#x27;Mitzie&#x27;</span>);</span><br><span class="line">d.speak(); <span class="comment">// Mitzie barks.</span></span><br></pre></td></tr></table></figure>
<p>使用 extends 关键字自动设置了 constructor，并且会自动调用父类的构造函数，这是一种更少坑的设计。所以当我们使用类的思想来设计代码时，应该尽量使用 class 来声明类，而不是用旧语法，拿函数来模拟对象。</p>
]]></content>
      <categories>
        <category>JS</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>js类</title>
    <url>/JS/%E7%AC%94%E8%AE%B0/js/4.apply()%E3%80%81call()%E3%80%81prototype%E7%9A%84%E7%94%A8%E6%B3%95/</url>
    <content><![CDATA[<h2 id="apply和call区别"><a href="#apply和call区别" class="headerlink" title="apply和call区别"></a>apply和call区别</h2><p>**apply:**能劫持另外一个对象的方法，继承另外一个对象的属性。</p>
<blockquote>
<p>Function.apply(obj, args)</p>
<p>obj: 这个对象将代替Function类里this对象</p>
<p>args: 这个是数组，它将作为参数传给Function(args–&gt;arguments)</p>
</blockquote>
<p>**call:**和apply的意思一样，只不过是参数列表不一样</p>
<blockquote>
<p>Function.call(obj, [param1[, param2[,…[,paramN]]]])</p>
<p>obj:这个对象将代替Function类里的this对象</p>
<p>params:这个是一个参数列表</p>
</blockquote>
<h3 id="apply"><a href="#apply" class="headerlink" title="apply"></a>apply</h3><a id="more"></a>

<p>(实现一个简单的new方法示例</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//构造函数</span></span><br><span class="line"><span class="keyword">let</span> Parent = <span class="function"><span class="keyword">function</span> (<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;;</span><br><span class="line">Parent.prototype.sayName = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newMethod = <span class="function"><span class="keyword">function</span> (<span class="params">Parent, ...rest</span>) </span>&#123; <span class="comment">//...rest为不定变量，指剩下的所有参数</span></span><br><span class="line">    <span class="comment">// 1.以构造器的prototype属性为原型，创建新对象；</span></span><br><span class="line">    <span class="keyword">let</span> child = <span class="built_in">Object</span>.create(Parent.prototype);</span><br><span class="line">    <span class="comment">// 2.将this和调用参数传给构造器执行</span></span><br><span class="line">    Parent.apply(child, rest);</span><br><span class="line">    <span class="comment">// 3.返回第一步的对象</span></span><br><span class="line">    <span class="keyword">return</span> child;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//创建一个实例，将构造函数Parent与形参作为参数传入</span></span><br><span class="line"><span class="keyword">const</span> child = newMethod(Parent, <span class="string">&#x27;echo&#x27;</span>, <span class="number">26</span>);</span><br><span class="line">child.sayName() <span class="comment">//&#x27;echo&#x27;;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//最后检验，与使用new的效果相同</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent<span class="comment">//true</span></span><br><span class="line">child.hasOwnProperty(<span class="string">&#x27;name&#x27;</span>)<span class="comment">//true</span></span><br><span class="line">child.hasOwnProperty(<span class="string">&#x27;age&#x27;</span>)<span class="comment">//true</span></span><br><span class="line">child.hasOwnProperty(<span class="string">&#x27;sayName&#x27;</span>)<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<p><strong>Parent.apply(child, rest)：</strong><br>传入的rest为[‘echo’, 26]<br>child去执行Parent类里面的内容，也就是把Parent中的属性引入新创建的child对象中。</p>
<h3 id="call"><a href="#call" class="headerlink" title="call"></a>call</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">People</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student</span>(<span class="params">name, age, grade</span>) </span>&#123;</span><br><span class="line">    People.call(<span class="built_in">this</span>, name, age);</span><br><span class="line">    <span class="built_in">this</span>.grade = grade;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> student = <span class="keyword">new</span> Student(<span class="string">&#x27;小明&#x27;</span>, <span class="number">21</span>, <span class="string">&#x27;大三&#x27;</span>);</span><br><span class="line"><span class="built_in">console</span>.log(student.name + student.age + student.grade);<span class="comment">//小明21大三</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，我们并没有给<code>Student</code>的<code>name</code>和<code>age</code>赋值，但是存在这两个属性的值，这还是要归功于<code>call()</code>方法，它可以改变<code>this</code>的指向。</p>
<p><strong>People.call(this, name, age):</strong></p>
<p><code>this</code>代表的是<code>Student</code>，这也就是之前说的，使得<code>Student</code>可以调用<code>People</code>中的方法，因为<code>People</code>中有<code>this.name = name;</code>等语句，这样就将<code>name</code>和<code>age</code>属性创建到了<code>Student</code>中。</p>
<h3 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h3><p><code>call()</code>和<code>apply()</code>的不同点就是<strong>接收参数的方式不同</strong>。</p>
<p><strong>apply()方法</strong>接收两个参数，一个是函数运行的作用域（<code>this</code>），另一个是参数数组。</p>
<p><strong>call()方法</strong>不一定接受两个参数，第一个参数也是函数运行的作用域（<code>this</code>），但是传递给函数的参数必须列举出来。</p>
<h3 id="apply妙用"><a href="#apply妙用" class="headerlink" title="apply妙用"></a>apply妙用</h3><h5 id="1）-Math-max可以实现得到数组中最大的一项"><a href="#1）-Math-max可以实现得到数组中最大的一项" class="headerlink" title="1） Math.max可以实现得到数组中最大的一项"></a>1） Math.max可以实现得到数组中最大的一项</h5><p>但是因为<code>Math.max</code>参数里面不支持<code>Math.max([param1,param2])</code>，也就是数组，但是它支持<code>Math.max(param1,param2,param3…)</code>，所以可以根据<code>apply</code>的那个特点来解决：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> max = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span>, array);</span><br><span class="line"><span class="built_in">console</span>.log(max);<span class="comment">//3</span></span><br></pre></td></tr></table></figure>
<p>这样轻易的可以得到一个数组中最大的一项，<code>apply</code>会将一个数组转换为一个参数接一个参数的传递给方法，这块在调用的时候第一个参数给了一个<code>null</code>，这个是因为没有对象去调用这个方法，我们只需要用这个方法帮我运算，得到返回的结果就行，所以直接传递了一个<code>null</code>过去，当然，第一个参数使用<code>this</code>也是可以的</p>
<p>同理 Math.min() 也是一样的</p>
<h5 id="2）Array-prototype-push可以实现两个数组合并"><a href="#2）Array-prototype-push可以实现两个数组合并" class="headerlink" title="2）Array.prototype.push可以实现两个数组合并"></a>2）Array.prototype.push可以实现两个数组合并</h5><p>同样的，<code>push</code>方法没有提供<code>push</code>一个数组，但是它提供了<code>push(param1,param,…paramN)</code>所以同样也可以通过<code>apply</code>来装换一下这个数组，即:</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line"><span class="built_in">Array</span>.prototype.push.apply(arr1, arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">//[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>
<p>或者：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">arr1.push.apply(arr1, arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">//[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>
<p>还有：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> arr1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="keyword">var</span> arr2 = [<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>];</span><br><span class="line">[].push.apply(arr1, arr2);</span><br><span class="line"><span class="built_in">console</span>.log(arr1);<span class="comment">//[ 1, 2, 3, 4, 5, 6 ]</span></span><br></pre></td></tr></table></figure>
<h5 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h5><p>当目标函数只需要n个参数列表，不接收一个数组的形式（<code>[param1[,param2[,…[,paramN]]]]</code>）时，我们就可以通过<code>apply</code>的方式来巧妙地解决。</p>
<h2 id="prototype用法"><a href="#prototype用法" class="headerlink" title="prototype用法"></a>prototype用法</h2><p>注意点：new实例创建之后，再使用<strong>对象字面量</strong>重新赋值给prototype，<strong>prototype</strong>的指向地址换成了<strong>新的</strong>object的地址。而之前那个<strong>实例</strong>指向的还是<strong>原有的</strong>默认的prototype地址，使得之前的实例指向的曾经的prototype<strong>变得不可联系</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//如果要在实例之后用prototype的话不要用对象字面量方法：</span></span><br><span class="line">Person.prototype=&#123;</span><br><span class="line">    name: <span class="string">&quot;Tom&quot;</span>,</span><br><span class="line">    age: <span class="number">20</span>,</span><br><span class="line">    saySomething: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="string">&quot;What&#x27;s up?&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//而要用对prototype的属性直接赋值的方式：</span></span><br><span class="line">Person.prototype.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">20</span>;</span><br><span class="line">Person.prototype.saySomething = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">&quot;What&#x27;s up?&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="举个栗子"><a href="#举个栗子" class="headerlink" title="举个栗子"></a>举个栗子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person();</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">&quot;Mike&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line"><span class="built_in">console</span>.log(man.name);</span><br></pre></td></tr></table></figure>
<p>结果为<strong>John</strong>,如果不直接给man添加一个自己的name属性的话，他会变成永远的John。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">Person.prototype = &#123; <span class="comment">//使用对象字面量，指向地址变化</span></span><br><span class="line">    name:<span class="string">&quot;Mike&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person(); <span class="comment">//创建的实例指向的是新的地址</span></span><br><span class="line">Person.prototype.name = <span class="string">&quot;Tom&quot;</span>; <span class="comment">//使用直接赋值的方式改变name</span></span><br><span class="line"><span class="built_in">console</span>.log(man.name);</span><br></pre></td></tr></table></figure>
<p>结果为<strong>Tom</strong>,new创建新实例在已经改变为新地址之后。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">Person.prototype.name = <span class="string">&quot;John&quot;</span>;</span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    name: <span class="string">&quot;Mike&quot;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> man = <span class="keyword">new</span> Person();</span><br><span class="line"><span class="built_in">console</span>.log(man.name);</span><br><span class="line">Person.prototype.name = <span class="string">&quot;Tom&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>结果为<strong>Mike</strong>，同样，实例创建在地址变化之后，而打印name在变为Tom之前。</p>
<p>所以对象字面量重写会使得之前创建的实例与之后创建的实例实际指向不同的prototype。慎用之。</p>
]]></content>
      <categories>
        <category>JS</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>对象分类</title>
    <url>/JS/%E7%AC%94%E8%AE%B0/js/5.%E5%AF%B9%E8%B1%A1%E5%88%86%E7%B1%BB/</url>
    <content><![CDATA[<p>对象可以分成几类：</p>
<ul>
<li>宿主对象：JS 宿主环境提供的对象，行为完全由素质环境决定。</li>
<li>内置对象：JS 提供的对象。<ul>
<li>固有对象：由标准规定，随着 JS 运行时创建而自动创建的对象实例。</li>
<li>原生对象：用户可以通过 Array、RegExp 等内置构造器或者特殊语法创建的对象。</li>
<li>普通对象：由{}语法、Object 构造器或者 class 关键字定义的对象，能被原型继承。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<h2 id="宿主对象"><a href="#宿主对象" class="headerlink" title="宿主对象"></a>宿主对象</h2><p>浏览器环境中的宿主：全局对象是 window，window 上的属性一部分来自 JS，一部分来自浏览器环境。</p>
<h2 id="内置对象·固有对象"><a href="#内置对象·固有对象" class="headerlink" title="内置对象·固有对象"></a>内置对象·固有对象</h2><p>固有对象在 js 代码执行前就已经被创建了，它们扮演着类似基础库的角色。“类”就是固有对象的一种。</p>
<h2 id="内置对象·原生对象"><a href="#内置对象·原生对象" class="headerlink" title="内置对象·原生对象"></a>内置对象·原生对象</h2><p>js 中能够通过语言本身的构造器创建的对象。</p>
<p>js 提供了 30 多个<strong>构造器</strong>（内置对象），分成以下几个种类：</p>
<img src="https://static001.geekbang.org/resource/image/6c/d0/6cb1df319bbc7c7f948acfdb9ffd99d0.png" style="width: 100%;">

<p>通过这些构造器，我们可以用 new 运算创建新的对象。这些构造器就是原生对象。</p>
<p>几乎所有这些构造器的能力都是无法用纯 JavaScript 代码实现的，它们也无法用 class/extend 语法来继承。</p>
<p>这些字段使得原型继承方法无法正常工作，所以，我们可以认为，所有这些原生对象都是为了特定能力或者性能，而设计出来的“<strong>特权对象</strong>”。</p>
<h2 id="用对象来模拟函数与构造器：函数对象与构造器对象"><a href="#用对象来模拟函数与构造器：函数对象与构造器对象" class="headerlink" title="用对象来模拟函数与构造器：函数对象与构造器对象"></a>用对象来模拟函数与构造器：函数对象与构造器对象</h2><p>函数对象的定义是：具有[[call]]私有字段的对象。</p>
<p>构造器对象的定义是：具有私有字段[[construct]]的对象。</p>
<p>任何对象只需要实现[[call]]，它就是一个函数对象，可以去作为函数被调用。而如果它能实现[[construct]]，它就是一个构造器对象，可以作为构造器被调用。</p>
<p>用户用 <strong>function</strong> 关键字创建的函数必定<strong>同时是函数和构造器</strong>。不过，它们表现出来的行为效果却并不相同。</p>
<p>对于用户使用 function 语法或者 Function 构造器创建的对象来说，[[call]]和[[construct]]行为总是相似的，它们执行同一段代码。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> v = f(); <span class="comment">//把f作为函数调用</span></span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> f(); <span class="comment">//把f作为构造器调用</span></span><br></pre></td></tr></table></figure>
<p>[[construct]]的执行过程如下：</p>
<ul>
<li>以 Object.prototype 为原型创建一个新对象；</li>
<li>以新对象为 this，执行函数的[[call]]；</li>
<li>如果[[call]]的返回值是对象，那么，返回这个对象，否则返回第一步创建的新对象。</li>
</ul>
<p>这样的规则造成了个有趣的现象，如果我们的构造器返回了一个新的对象，那么 new 创建的新对象就变成了一个构造函数之外完全无法访问的对象，这一定程度上可以实现“私有”。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cls</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">100</span>;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="comment">//返回了一个新的对象</span></span><br><span class="line">        getValue:<span class="function">() =&gt;</span> &#123; <span class="comment">// 箭头函数的this继承外部函数的this</span></span><br><span class="line">          <span class="built_in">console</span>.log(<span class="built_in">this</span>) <span class="comment">// window</span></span><br><span class="line">          <span class="keyword">return</span> <span class="built_in">this</span>.a</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> cls;</span><br><span class="line"><span class="built_in">console</span>.log(o.getValue()); <span class="comment">//100</span></span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">// undefined</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">this</span>.a); <span class="comment">// 100</span></span><br><span class="line"><span class="comment">//这相当于一个闭包</span></span><br></pre></td></tr></table></figure>
<p>构造函数一般不应该用 return 来返回值。而这个构造函数 cls 用 return 来返回值。并且<strong>返回值是一个对象</strong>（函数也是对象）则会用这个对象代替自动创建的实例对象返回给 o。也就是说你设置的是实例对象的 a，返回给 o 的却是 getValue 一个箭头函数，箭头函数没有 a 属性。</p>
<p>如果想要访问 a 可以设置 getValue 为 cls 的方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cls</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.a = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">this</span>.getValue =<span class="function">()=&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">this</span>.a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> o = <span class="keyword">new</span> cls();</span><br><span class="line"><span class="built_in">console</span>.log(o.a); <span class="comment">//100</span></span><br><span class="line"><span class="built_in">console</span>.log(o.getValue()); <span class="comment">//100</span></span><br></pre></td></tr></table></figure>
<h2 id="特殊行为的对象"><a href="#特殊行为的对象" class="headerlink" title="特殊行为的对象"></a>特殊行为的对象</h2><p>在固有对象和原生对象中，有一些对象的行为跟正常对象有很大区别。</p>
<p>它们常见的下标运算（就是使用中括号或者点来做属性访问）或者设置原型跟普通对象不同。</p>
<ul>
<li>Array：Array 的 length 属性根据最大的下标自动发生变化。</li>
<li>Object.prototype：作为所有正常对象的默认原型，不能再给它设置原型了。</li>
<li>String：为了支持下标运算，String 的正整数属性访问会去字符串里查找。</li>
<li>Arguments：arguments 的非负整数型下标属性跟对应的变量联动。</li>
<li>模块的 namespace 对象：特殊的地方非常多，跟一般对象完全不一样，尽量只用于 import 吧。</li>
<li>类型数组和数组缓冲区：跟内存块相关联，下标运算比较特殊。</li>
<li>bind 后的 function：跟原来的函数相关联。</li>
</ul>
<h2 id="创建对象的几种模式"><a href="#创建对象的几种模式" class="headerlink" title="创建对象的几种模式"></a>创建对象的几种模式</h2><h3 id="1、new-操作符-Object-创建对象"><a href="#1、new-操作符-Object-创建对象" class="headerlink" title="1、new 操作符 + Object 创建对象"></a>1、new 操作符 + Object 创建对象</h3><p>先创建空 Object 对象，再动态添加属性和方法</p>
<p><strong>适用场景：</strong>起始时不确定对象内部数据</p>
<p><strong>问题：</strong>语句太多</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">person.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">person.age = <span class="number">21</span>;</span><br><span class="line">person.family = [<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;wangwu&quot;</span>];</span><br><span class="line">person.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2、字面式创建对象"><a href="#2、字面式创建对象" class="headerlink" title="2、字面式创建对象"></a>2、字面式创建对象</h3><p>使用 {} 创建对象，同时指定属性和方法</p>
<p><strong>适用场景：</strong>起始对象内部数据是确定的</p>
<p><strong>问题：</strong>如果创建多个对象时，会产生大量重复代码，为了解决此问题，工厂模式被开发。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">&quot;lisi&quot;</span>,</span><br><span class="line">  age: <span class="number">21</span>,</span><br><span class="line">  family: [<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;wangwu&quot;</span>],</span><br><span class="line">  say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// var o = function()&#123;&#125; 也可以</span></span><br></pre></td></tr></table></figure>
<h3 id="3、工厂模式"><a href="#3、工厂模式" class="headerlink" title="3、工厂模式"></a>3、工厂模式</h3><p>通过工厂函数动态创建对象并返回</p>
<p><strong>适用场景：</strong>需要创建多个对象</p>
<p><strong>问题：</strong>对象没有一个具体的类型，都是 Object 类型</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name,age,family</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">    o.name = name;</span><br><span class="line">    o.age = age;</span><br><span class="line">    o.family = family;</span><br><span class="line">    o.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 =  createPerson(<span class="string">&quot;lisi&quot;</span>,<span class="number">21</span>,[<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;wangwu&quot;</span>]);   <span class="comment">//instanceof无法判断它是谁的实例，只能判断他是对象，构造函数都可以判断出</span></span><br><span class="line"><span class="keyword">var</span> person2 =  createPerson(<span class="string">&quot;wangwu&quot;</span>,<span class="number">18</span>,[<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;lisi&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<h3 id="4、构造函数模式"><a href="#4、构造函数模式" class="headerlink" title="4、构造函数模式"></a>4、构造函数模式</h3><p>自定义构造函数，通过 new 创建对象</p>
<p><strong>适用场景：</strong>需要创建多个类型确定的对象</p>
<p><strong>问题：</strong>每个对象都有相同的数据，浪费内存</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,family</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.family = family;</span><br><span class="line">    <span class="built_in">this</span>.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;lisi&quot;</span>,<span class="number">21</span>,[<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;wangwu&quot;</span>]);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;lisi&quot;</span>,<span class="number">21</span>,[<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;lisi&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person2 <span class="keyword">instanceof</span> Person); <span class="comment">//true</span></span><br><span class="line"><span class="built_in">console</span>.log(person1.constructor);      <span class="comment">//constructor 属性返回对创建此对象的构造函数的引用</span></span><br></pre></td></tr></table></figure>
<p>构造函数知道自己从哪里来（通过 instanceof 可以看出其既是 Object 的实例，又是 Person 的实例）</p>
<p>构造函数的缺陷是每个实例的方法是一样的但是每次 new 都会创建一个新的，浪费内存，因此产生了原型模式</p>
<h3 id="5、原型模式"><a href="#5、原型模式" class="headerlink" title="5、原型模式"></a>5、原型模式</h3><p><strong>好处</strong>：</p>
<p>方法是共享的了，所有的实例的方法都指向同一个。</p>
<p>问题：</p>
<p>1.<strong>引用类型</strong>的属性只要有一个实例对象修改了，其他也会跟着修改。因为所有实例对象的属性都是共用的。</p>
<p>2.所有都是共享的，没有办法创建实例自己的属性和方法，也没有办法像构造函数那样传递参数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">&quot;lisi&quot;</span>;</span><br><span class="line">Person.prototype.age = <span class="number">21</span>;</span><br><span class="line">Person.prototype.arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">Person.prototype.say = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="built_in">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person()</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(person.family) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.family) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">person.arr.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(person.family) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(person2.family) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<h3 id="6、混合模式（构造函数模式-原型模式）"><a href="#6、混合模式（构造函数模式-原型模式）" class="headerlink" title="6、混合模式（构造函数模式+原型模式）"></a>6、混合模式（构造函数模式+原型模式）</h3><p><strong>优点</strong>：</p>
<ol>
<li>解决了原型模式没有办法传递参数的问题</li>
<li>保证了每个实例有自己的私有属性，解决了原型模式对于引用类型的属性的问题</li>
<li>通过原型链<code>__proto__</code>共享着对相同方法的引用，解决了构造函数模式不能共享方法的问题，最大限度的节省了内存。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name,age,family</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.family = family;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype = &#123;</span><br><span class="line">    say: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">&quot;lisi&quot;</span>,<span class="number">21</span>,[<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;wangwu&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(person1); <span class="comment">// &#123;name: &quot;lisi&quot;, age: 21, family: Array(3)&#125;</span></span><br><span class="line">person1.say(); <span class="comment">// lisi</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">&quot;wangwu&quot;</span>,<span class="number">22</span>,[<span class="string">&quot;lida&quot;</span>,<span class="string">&quot;lier&quot;</span>,<span class="string">&quot;lisi&quot;</span>]);</span><br><span class="line"><span class="built_in">console</span>.log(person2); <span class="comment">// &#123;name: &quot;wangwu&quot;, age: 22, family: Array(3)&#125;</span></span><br><span class="line">person2.say(); <span class="comment">// wangwu</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意</strong>：在使用 prototype 的时候，不要用字面量的写法。否则，会重新生成一个新对象，切断与之前的联系。</p>
</blockquote>
]]></content>
      <categories>
        <category>JS</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS实现继承的几种方式</title>
    <url>/JS/%E7%AC%94%E8%AE%B0/js/6.JS%E5%AE%9E%E7%8E%B0%E7%BB%A7%E6%89%BF%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/</url>
    <content><![CDATA[<h2 id="1、借助原型链实现继承"><a href="#1、借助原型链实现继承" class="headerlink" title="1、借助原型链实现继承"></a>1、借助原型链实现继承</h2><p> <strong>步骤</strong>：</p>
<p> 1）定义父类型构造函数</p>
<p> 2）给父类型的原型添加方法</p>
<p> 3）定义子类型的构造函数</p>
<p> 4）创建父类型的实例对象赋给子类型的原型</p>
<p> 5）将子类型原型的构造属性设置为子类型（没有这一步也不影响继承，但是 constructor 的指向是错误的）</p>
<p> 6）给子类型原型添加方法</p>
<p> 7）创建子类型的实例对象：可以调用父类型的方法</p>
<a id="more"></a>

<p> <strong>关键</strong>：<strong>将父类的一个实例对象作为子类的原型</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = <span class="string">&#x27;wo&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.gender = <span class="string">&#x27;男&#x27;</span></span><br><span class="line">  <span class="built_in">this</span>.list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.eat = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;晚餐时间到&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent() <span class="comment">// 关键</span></span><br><span class="line">Child.prototype.constructor = Child <span class="comment">// 让子类型的原型的constructor指向子类型，否则它指向的是Parent</span></span><br><span class="line">Child.prototype.sleep = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;睡觉时间到&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = <span class="keyword">new</span> Child(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="keyword">new</span> Child(<span class="number">30</span>)</span><br><span class="line">child.eat() <span class="comment">// 晚餐时间到，eat 继承自父类型的原型，在 child.__proto__.__proto__ 上</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child.list) <span class="comment">// [1, 2, 3]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.list) <span class="comment">// [1, 2, 3]</span></span><br><span class="line">child.list.push(<span class="number">4</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child.list) <span class="comment">// [1, 2, 3, 4]</span></span><br><span class="line"><span class="built_in">console</span>.log(child2.list) <span class="comment">// [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p> <strong>缺点</strong>：</p>
<p> 因为 Child 的原型对象都是 New Parent，所以实例化出来的对象的属性都是一样的。Parent 上面的<strong>引用类型</strong>的属性只要有一个实例对象修改了，其他也会跟着修改。因为他们原型对象都是共用的。并且创建子类实例时，无法向父类构造函数传参。</p>
<h2 id="2、借助构造函数实现继承（call）"><a href="#2、借助构造函数实现继承（call）" class="headerlink" title="2、借助构造函数实现继承（call）"></a>2、借助构造函数实现继承（call）</h2><p> <strong>步骤</strong>：</p>
<p> 1）定义父类型构造函数</p>
<p> 2）定义子类型构造函数</p>
<p> 3）在子类型构造函数中调用 call 或 apply 把 Parent 的 this 指向改变为是 Child 的 this 指向。这样就可以实现复制父类的实例属性给子类。</p>
<p> <strong>关键</strong>：<strong>在子类型构造函数中通过 call 调用父类型构造函数</strong></p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.sayHi = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;hello&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age, gender</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name, age) <span class="comment">// 相当于将 this.name = name; this.age = age; 这两行代码放在这里执行</span></span><br><span class="line">  <span class="built_in">this</span>.gender = gender</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> child = <span class="keyword">new</span> Child(<span class="string">&#x27;王&#x27;</span>, <span class="number">20</span>, <span class="string">&#x27;男&#x27;</span>)</span><br><span class="line"><span class="built_in">console</span>.log(child.name, child.age) <span class="comment">// 王, 20</span></span><br><span class="line">child.sayHi() <span class="comment">// Uncaught TypeError:child.sayHi is not a function</span></span><br></pre></td></tr></table></figure>
<p> <strong>优点</strong>：可以向父类传递参数，而且解决了原型链继承中父类属性使用 this 声明的引用类型属性会在所有实例共享的问题。</p>
<p> <strong>缺点</strong>：只能解决父类型上的属性和方法的继承，但是父类型原型上的不能继承</p>
<h2 id="3、组合式继承（原型链-构造函数）"><a href="#3、组合式继承（原型链-构造函数）" class="headerlink" title="3、组合式继承（原型链 + 构造函数）"></a>3、组合式继承（原型链 + 构造函数）</h2><p> 组合上述两种方法，用<strong>原型链</strong>实现对原型属性和方法的继承，用<strong>构造函数</strong>技术来实现实例属性的继承。（常用）</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name) <span class="comment">// 实现Parent属性&quot;name&quot;的继承</span></span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="keyword">new</span> Parent() <span class="comment">// 实现子继承父的所有属性和方法包括原型上的</span></span><br><span class="line">Child.prototype.constructor = Child <span class="comment">// prototype构造器指回自己，否则构造函数指向的是Parent</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Child(<span class="string">&#x27;wy&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">c.say() <span class="comment">// say</span></span><br></pre></td></tr></table></figure>
<p> <strong>优点</strong>：</p>
<p> 1)可以继承父类原型上的属性，可以传参，可复用。</p>
<p> 2)每个新子类对象实例引入的构造函数属性是私有的。</p>
<p> <strong>缺点</strong>：</p>
<p> 1)两次调用父类函数（new Parent() 和 Parent.call(this)），造成一定的性能损耗。</p>
<p> 2)在使用子类创建实例对象时，其原型中会存在两份相同属性/方法的问题。</p>
<h2 id="4、原型式继承（Object-create-）"><a href="#4、原型式继承（Object-create-）" class="headerlink" title="4、原型式继承（Object.create()）"></a>4、原型式继承（Object.create()）</h2><p> 是组合式的优化</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> Parent = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jacky&#x27;</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  courses: [<span class="string">&#x27;前端&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> child = <span class="built_in">Object</span>.create(Parent)</span><br><span class="line"><span class="keyword">var</span> child2 = <span class="built_in">Object</span>.create(Parent)</span><br><span class="line">child.courses.push(<span class="string">&#x27;后端&#x27;</span>)</span><br><span class="line">child2.courses.push(<span class="string">&#x27;全栈&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.courses) <span class="comment">//  [&quot;前端&quot;, &quot;后端&quot;, &quot;全栈&quot;]</span></span><br></pre></td></tr></table></figure>
<p> <strong>优点</strong>：解决了组合式继承中，父类的构造函数被调用了两次，会产生两组相同属性，一组在实例上 一组在原型上的问题。</p>
<p> <strong>缺点</strong>：与原型链继承一样。多个实例共享被继承对象的属性，存在篡改的可能。</p>
<h3 id="Object-create-也可以替换为-ES5-的写法"><a href="#Object-create-也可以替换为-ES5-的写法" class="headerlink" title="Object.create() 也可以替换为 ES5 的写法"></a>Object.create() 也可以替换为 ES5 的写法</h3> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">create</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125; <span class="comment">// 创建一个空的构造函数</span></span><br><span class="line">    F.prototype = o <span class="comment">// 原型指向o</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> F() <span class="comment">// 返回的是new构造函数的实例对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="加上构造函数的另一种写法"><a href="#加上构造函数的另一种写法" class="headerlink" title="加上构造函数的另一种写法"></a>加上构造函数的另一种写法</h3><p> 仅仅就是把组合式中的 new Parent() 替换为了原型式 Object.create()，这样就解决了引用类型值的属性会共享的问题</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name, courses</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.name = name</span><br><span class="line">  <span class="built_in">this</span>.courses = courses</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age, courses</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, name, courses)</span><br><span class="line">  <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype) <span class="comment">// 用Object.create复制了Parent的原型到Child的原型上</span></span><br><span class="line">Child.prototype.constructor = Child</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> c = <span class="keyword">new</span> Child(<span class="string">&#x27;wy&#x27;</span>, <span class="number">18</span>, [<span class="number">1</span>])</span><br><span class="line"><span class="keyword">const</span> c2 = <span class="keyword">new</span> Child(<span class="string">&#x27;woo&#x27;</span>, <span class="number">18</span>, [<span class="number">1</span>])</span><br><span class="line"><span class="built_in">console</span>.log(c.courses) <span class="comment">// [1]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.courses) <span class="comment">// [1]</span></span><br><span class="line">c.courses.push(<span class="number">2</span>)</span><br><span class="line"><span class="built_in">console</span>.log(c.courses) <span class="comment">// [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(c2.courses) <span class="comment">// [1]</span></span><br></pre></td></tr></table></figure>
<h2 id="5、寄生式继承"><a href="#5、寄生式继承" class="headerlink" title="5、寄生式继承"></a>5、寄生式继承</h2><p> 仅仅在原型式继承的基础上，创建一个封装继承过程的函数（创建、增强、返回）</p>
<p> 使用场景：专门为对象来做某种固定方式的增强。</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createAnother</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(o)</span><br><span class="line">  clone.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 增加的新的方法和属性</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> clone</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> Parent = &#123;</span><br><span class="line">  name: <span class="string">&#x27;jacky&#x27;</span>,</span><br><span class="line">  age: <span class="number">22</span>,</span><br><span class="line">  courses: [<span class="string">&#x27;前端&#x27;</span>],</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> child = createAnother(Parent)</span><br><span class="line"><span class="keyword">var</span> child2 = createAnother(Parent)</span><br><span class="line">child.courses.push(<span class="string">&#x27;后端&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(child2.courses) <span class="comment">//  [&quot;前端&quot;, &quot;后端&quot;]</span></span><br><span class="line">child2.say() <span class="comment">// say</span></span><br></pre></td></tr></table></figure>
<p> <strong>优点</strong>：没有创建自定义构造函数类型，因为只是套了个壳子增加特定属性/方法返回对象，以达到增强对象的目的</p>
<p> <strong>缺点</strong>：同原型链继承相同，多个实例的引用类型属性指向相同，存在篡改的可能，也无法传递参数</p>
<h2 id="6、寄生-组合式继承"><a href="#6、寄生-组合式继承" class="headerlink" title="6、寄生-组合式继承"></a>6、寄生-组合式继承</h2><p> 借用<strong>寄生式</strong>实现封装，<strong>组合式</strong>实现继承。（<strong>构造函数</strong>（call）传递参数并实现继承父类自身属性/方法+ <strong>原型式</strong>（Object.create()）实现继承父类原型的属性/方法）</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.say = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;say&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">name, age</span>) </span>&#123;</span><br><span class="line">    Parent.call(<span class="built_in">this</span>, name) <span class="comment">// 借用构造函数继承：继承父类通过this声明的属性和方法至子类实例的属性上</span></span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寄生式继承：封装了child.prototype对象原型式继承parent.prototype的过程，并且增强了传入的对象。</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">child, parent</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> clone = <span class="built_in">Object</span>.create(parent.prototype) <span class="comment">// 原型式继承：浅拷贝parent原型对象到clone的隐式原型上</span></span><br><span class="line">    clone.constructor = child <span class="comment">// 增强对象，弥补child因重写原型而失去的默认的constructor属性</span></span><br><span class="line">    child.prototype = clone <span class="comment">// 将新创建的拷贝的对象赋值给子类的原型</span></span><br><span class="line">&#125;</span><br><span class="line">inheritPrototype(Child, Parent); <span class="comment">// 子类原型继承父类原型</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 新增子类原型属性，必须在执行过继承函数inheritPrototype之后</span></span><br><span class="line">Child.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;eat&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> Child(<span class="string">&#x27;wy&#x27;</span>, <span class="number">18</span>)</span><br><span class="line">c.say() <span class="comment">// say</span></span><br><span class="line">c.eat() <span class="comment">// eat</span></span><br><span class="line"><span class="comment">// c.__proto__ = clone</span></span><br><span class="line"><span class="comment">// clone.__proto__ = Parent.prototype</span></span><br></pre></td></tr></table></figure>
<p> <strong>优点</strong>：</p>
<p> 1）只调用一次父类 Parent 构造函数。不必为了指定子类的原型而调用构造函数，而是间接的使用原型式继承 Object.create 让 Parent.prototype 赋给 Child.prototype。保持了原型链上下文不变， instanceof 和 isPrototypeOf() 也能正常使用。</p>
<p> 2）避免在子类 prototype 上创建多余的属性（父类自身属性 name）。</p>
<p> 3）寄生组合式继承是最成熟的继承方法，也是现在最常用的继承方法，众多 JS 库采用的继承方案也是它。</p>
<p> 还可以这样写：</p>
 <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Parent</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">this</span>.val = value</span><br><span class="line">&#125;</span><br><span class="line">Parent.prototype.getValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="built_in">this</span>.val)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Child</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  Parent.call(<span class="built_in">this</span>, value)</span><br><span class="line">&#125;</span><br><span class="line">Child.prototype = <span class="built_in">Object</span>.create(Parent.prototype, &#123;</span><br><span class="line">  <span class="title">constructor</span>: &#123;</span><br><span class="line">    value: Child, <span class="comment">// constructor指回Child</span></span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    writable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> child = <span class="keyword">new</span> Child(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">child.getValue() <span class="comment">// 1</span></span><br><span class="line">child <span class="keyword">instanceof</span> Parent <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h2 id="7、ES6-extends-继承（最优方式）"><a href="#7、ES6-extends-继承（最优方式）" class="headerlink" title="7、ES6 extends 继承（最优方式）"></a>7、ES6 extends 继承（最优方式）</h2> <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name</span><br><span class="line">    <span class="built_in">this</span>.age = age</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="title">skill</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;父类的技能&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Son</span> <span class="keyword">extends</span> <span class="title">Father</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="title">constructor</span>(<span class="params">name, age, job</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">super</span>(name, age) <span class="comment">// 调用父类的constructor，只有调用super之后，才可以使用this关键字</span></span><br><span class="line">    <span class="built_in">this</span>.job = job</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="title">getInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">this</span>.name, <span class="built_in">this</span>.age, <span class="built_in">this</span>.job)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> son = <span class="keyword">new</span> Son(<span class="string">&#x27;jacky&#x27;</span>, <span class="number">22</span>, <span class="string">&#x27;前端开发&#x27;</span>)</span><br><span class="line">son.skill() <span class="comment">// 父类的技能</span></span><br><span class="line">son.getInfo() <span class="comment">// jacky 22 前端开发</span></span><br></pre></td></tr></table></figure>
<p> 子类必须在 constructor 方法中调用 super 方法，否则新建实例时会报错。因为子类没有自己的 this 对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后再对其进行加工，加上子类自己的实例属性和方法。如果不调用 super 方法，子类就得不到 this 对象。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="ES5-继承"><a href="#ES5-继承" class="headerlink" title="ES5 继承"></a>ES5 继承</h3><ol>
<li><p>借助原型链实现继承：<code>Child.prototype = new Parent()</code></p>
</li>
<li><p>借助构造函数实现继承：<code>Parent.call(this)</code></p>
</li>
<li><p>组合式继承：综合上面两种方式，既有 <code>Child.prototype = new Parent()</code> 又有 <code>Parent.call(this)</code></p>
</li>
<li><p>原型式继承：优化版组合式，将 <code>new Parent()</code> 改为 <code>Object.create(Parent.prototype)</code></p>
</li>
<li><p>寄生式继承：在原型式外面套了个函数壳子（创建、增强、返回）</p>
</li>
<li><p>寄生-组合式：寄生式 + 构造函数的 call + 原型式的 Object.create()</p>
<h3 id="ES5-继承与-ES6-继承的区别"><a href="#ES5-继承与-ES6-继承的区别" class="headerlink" title="ES5 继承与 ES6 继承的区别"></a>ES5 继承与 ES6 继承的区别</h3></li>
<li><p>ES5 的继承实质上是先创建子类的实例对象，再将父类的方法添加到 this 上( Father.call(this) )。</p>
</li>
<li><p>ES6 的继承是先创建父类的实例对象 this，再用子类的构造函数修改 this。</p>
</li>
<li><p>因为子类没有自己的 this 对象，所以必须先调用父类的 super() 方法。</p>
</li>
</ol>
]]></content>
      <categories>
        <category>JS</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>执行异步</title>
    <url>/JS/%E7%AC%94%E8%AE%B0/js/7.%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5/</url>
    <content><![CDATA[<p>一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。</p>
<p>采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p>
<p>宏观任务的队列就相当于事件循环。</p>
<p>在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列。</p>
<p>Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。</p>
<a id="more"></a>

<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise是JS的一种标准化异步管理方式。总体思想是：</p>
<p>需要进行io、等待或其它异步操作的函数，不返回真实结果，而返回一个”承诺“。函数的调用方可以在合适的时机选择等待这个承诺兑现（通过Promise的then方法的回调）。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resole, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;finished&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>Promise 的 then 回调是一个异步的执行过程，下面我们就来研究一下 Promise 函数中的执行顺序。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>); </span><br><span class="line"> resolve() </span><br><span class="line">&#125;); </span><br><span class="line">r.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>); <span class="comment">//输出a,b,c</span></span><br></pre></td></tr></table></figure>
<p>在 console.log(“b”) 之前， r 已经得到了 resolve，但是 Promise 的 resolve 是异步操作，所以 c 无法出现在 b 之前。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&quot;d&quot;</span>), <span class="number">0</span>)</span><br><span class="line">r.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>) <span class="comment">//输出a，b，c，d</span></span><br></pre></td></tr></table></figure>
<p>不论代码顺序如何，d 必定发生在 c 之后，因为 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。微任务始终先于宏任务。</p>
<p>总结一下如何分析异步执行的顺序：</p>
<ul>
<li>首先我们分析有多少个宏任务；</li>
<li>在每个宏任务中，分析有多少个微任务；</li>
<li>根据调用次序，确定宏任务中的微任务执行次序；</li>
<li>根据宏任务的触发规则和调用次序，确定宏任务的执行次序；</li>
<li>确定整个顺序。</li>
</ul>
<h2 id="新特性：async-await"><a href="#新特性：async-await" class="headerlink" title="新特性：async/await"></a>新特性：async/await</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve,duration);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//输出a,c,2s后输出b</span></span><br></pre></td></tr></table></figure>
<p>async 函数强大之处在于，它是可以嵌套的<br>一个 JavaScript 引擎会常驻于内存中，它等待着我们（宿主）把 JavaScript 代码或者函数传递给它执行。</p>
<p>采纳 JSC 引擎的术语，我们把宿主发起的任务称为宏观任务，把 JavaScript 引擎发起的任务称为微观任务。</p>
<p>宏观任务的队列就相当于事件循环。</p>
<p>在宏观任务中，JavaScript 的 Promise 还会产生异步代码，JavaScript 必须保证这些异步代码在一个宏观任务中完成，因此，每个宏观任务中又包含了一个微观任务队列。</p>
<p>Promise 永远在队列尾部添加微观任务。setTimeout 等宿主 API，则会添加宏观任务。</p>
<h2 id="Promise-1"><a href="#Promise-1" class="headerlink" title="Promise"></a>Promise</h2><p>Promise是JS的一种标准化异步管理方式。总体思想是：</p>
<p>需要进行io、等待或其它异步操作的函数，不返回真实结果，而返回一个”承诺“。函数的调用方可以在合适的时机选择等待这个承诺兑现（通过Promise的then方法的回调）。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resole, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve, duration);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">sleep(<span class="number">1000</span>).then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;finished&quot;</span>));</span><br></pre></td></tr></table></figure>
<p>Promise 的 then 回调是一个异步的执行过程，下面我们就来研究一下 Promise 函数中的执行顺序。</p>
<p>示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>); </span><br><span class="line"> resolve() </span><br><span class="line">&#125;); </span><br><span class="line">r.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>); <span class="comment">//输出a,b,c</span></span><br></pre></td></tr></table></figure>
<p>在 console.log(“b”) 之前， r 已经得到了 resolve，但是 Promise 的 resolve 是异步操作，所以 c 无法出现在 b 之前。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  resolve()</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span><span class="built_in">console</span>.log(<span class="string">&quot;d&quot;</span>), <span class="number">0</span>)</span><br><span class="line">r.then(<span class="function">() =&gt;</span> <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>));</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>) <span class="comment">//输出a，b，c，d</span></span><br></pre></td></tr></table></figure>
<p>不论代码顺序如何，d 必定发生在 c 之后，因为 Promise 产生的是 JavaScript 引擎内部的微任务，而 setTimeout 是浏览器 API，它产生宏任务。微任务始终先于宏任务。</p>
<p>总结一下如何分析异步执行的顺序：</p>
<ul>
<li>首先我们分析有多少个宏任务；</li>
<li>在每个宏任务中，分析有多少个微任务；</li>
<li>根据调用次序，确定宏任务中的微任务执行次序；</li>
<li>根据宏任务的触发规则和调用次序，确定宏任务的执行次序；</li>
<li>确定整个顺序。</li>
</ul>
<h2 id="新特性：async-await-1"><a href="#新特性：async-await-1" class="headerlink" title="新特性：async/await"></a>新特性：async/await</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sleep</span>(<span class="params">duration</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;c&quot;</span>);</span><br><span class="line">    <span class="built_in">setTimeout</span>(resolve,duration);</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;a&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> sleep(<span class="number">2000</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&quot;b&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo(); <span class="comment">//输出a,c,2s后输出b</span></span><br></pre></td></tr></table></figure>
<p>async 函数强大之处在于，它是可以嵌套的</p>
]]></content>
      <categories>
        <category>JS</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>JS的异步操作</title>
    <url>/JS/%E7%AC%94%E8%AE%B0/js/8.JS%E7%9A%84%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h2 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h2><p>先执行func1()，执行成功后callback()告知，再执行func2()。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> func1 = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">    (callback &amp;&amp; <span class="keyword">typeof</span>(callback)===<span class="string">&#x27;function&#x27;</span>) &amp;&amp; callback();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> func2 = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line">func1(func2);</span><br><span class="line"><span class="comment">//1 2</span></span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>异步回调中最常见的形式是Ajax。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">    url:<span class="string">&quot;/getmsg&quot;</span>,</span><br><span class="line">    type: <span class="string">&#x27;GET&#x27;</span>,</span><br><span class="line">    dataType: <span class="string">&#x27;json&#x27;</span>,</span><br><span class="line">    success: <span class="function"><span class="keyword">function</span>(<span class="params">ret</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ret &amp;&amp; ret.status) &#123;</span><br><span class="line">            <span class="comment">//...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    error: <span class="function"><span class="keyword">function</span>(<span class="params">xhr</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2 id="事件监听"><a href="#事件监听" class="headerlink" title="事件监听"></a>事件监听</h2><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#div&#x27;</span>);</span><br><span class="line"><span class="keyword">var</span> event = <span class="built_in">document</span>.createEvent(<span class="string">&#x27;Event&#x27;</span>);</span><br><span class="line">event.initEvent(<span class="string">&#x27;myEvent&#x27;</span>, <span class="literal">true</span>, <span class="literal">true</span>); <span class="comment">// 定义事件名称myEvent</span></span><br><span class="line">elem.addEventListener(<span class="string">&#x27;myEvent&#x27;</span>, <span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123; <span class="comment">// 监听myEvent</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">&#x27;触发事件&#x27;</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(e);</span><br><span class="line">&#125;, <span class="literal">false</span>);</span><br><span class="line">elem.dispatchEvent(event);  <span class="comment">// 使用目标对象去派发事件，可以是元素节点/事件对象</span></span><br><span class="line"><span class="comment">//触发事件</span></span><br><span class="line"><span class="comment">//[object Event]</span></span><br></pre></td></tr></table></figure>
<h2 id="发布订阅"><a href="#发布订阅" class="headerlink" title="发布订阅"></a>发布订阅</h2><p>它定义对象间的一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都将得到通知</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//发布-订阅</span></span><br><span class="line"><span class="comment">//有个消息池，存放所有消息</span></span><br><span class="line"><span class="keyword">let</span> pubsub = &#123;&#125;;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">myObj</span>) </span>&#123;</span><br><span class="line">    topics = &#123;&#125;</span><br><span class="line">    subId = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">//发布者接受参数(消息名称，参数)</span></span><br><span class="line">    myObj.publish = <span class="function"><span class="keyword">function</span>(<span class="params">topic, msg</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//如果发布的该消息没有订阅者，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (!topics[topic]) &#123;</span><br><span class="line">                <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对该消息的所有订阅者，遍历去执行各自的回调函数</span></span><br><span class="line">            <span class="keyword">let</span> subs = topics[topic]</span><br><span class="line">            subs.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub</span>) </span>&#123;</span><br><span class="line">                sub.func(topic, msg)</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//订阅者接受参数：（消息名称，回调函数）</span></span><br><span class="line">    myObj.subscribe = <span class="function"><span class="keyword">function</span>(<span class="params">topic, func</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//如果订阅的该事件还未定义，初始化</span></span><br><span class="line">        <span class="keyword">if</span> (!topics[topic]) &#123;</span><br><span class="line">            topics[topic] = []</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//使用不同的token来作为订阅者的索引</span></span><br><span class="line">        <span class="keyword">let</span> token = (++subId).toString()</span><br><span class="line">        topics[topic].push(&#123;</span><br><span class="line">                token: token,</span><br><span class="line">                func: func</span><br><span class="line">            &#125;)</span><br><span class="line">        <span class="keyword">return</span> token</span><br><span class="line">    &#125;</span><br><span class="line">    myObj.unsubscribe = <span class="function"><span class="keyword">function</span>(<span class="params">token</span>) </span>&#123;</span><br><span class="line">        <span class="comment">//对消息列表遍历查找该token是哪个消息中的哪个订阅者</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> t <span class="keyword">in</span> topics) &#123;</span><br><span class="line">            <span class="comment">//如果某个消息没有订阅者，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (!topics[t]) &#123;</span><br><span class="line">                <span class="keyword">return</span> &#125;</span><br><span class="line">            topics[t].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">sub,index</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (sub.token === token) &#123;</span><br><span class="line">                    <span class="comment">//找到了，从订阅者的数组中去掉该订阅者</span></span><br><span class="line">                    topics[t].splice(index, <span class="number">1</span>)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)(pubsub)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> sub1 = pubsub.subscribe(<span class="string">&#x27;Msg::Name&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">topic, msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;event is :&quot;</span> + topic + <span class="string">&quot;; data is :&quot;</span> + msg)</span><br><span class="line">&#125;);</span><br><span class="line"><span class="keyword">let</span> sub2 = pubsub.subscribe(<span class="string">&#x27;Msg::Name&#x27;</span>, <span class="function"><span class="keyword">function</span>(<span class="params">topic, msg</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;this is another subscriber, data is :&quot;</span> + msg)</span><br><span class="line">&#125;);</span><br><span class="line">pubsub.publish(<span class="string">&#x27;Msg::Name&#x27;</span>, <span class="string">&#x27;123&#x27;</span>)</span><br><span class="line"></span><br><span class="line">pubsub.unsubscribe(sub2)</span><br><span class="line">pubsub.publish(<span class="string">&#x27;Msg::Name&#x27;</span>, <span class="string">&#x27;456&#x27;</span>)</span><br><span class="line"><span class="comment">//&gt; event is :Msg::Name; data is :123</span></span><br><span class="line"><span class="comment">//&gt; this is another subscriber, data is :123</span></span><br><span class="line"><span class="comment">//&gt; event is :Msg::Name; data is :456</span></span><br></pre></td></tr></table></figure>
<p>其中存储消息的结构用json可以表示为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">topics = &#123;</span><br><span class="line">  Msg::Name: [&#123;</span><br><span class="line">    token: <span class="number">0</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params">topic, msg</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;event is :&quot;</span> + topic + <span class="string">&quot;; data is :&quot;</span> + msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;, &#123;</span><br><span class="line">    token: <span class="number">1</span>,</span><br><span class="line">    func: <span class="function"><span class="keyword">function</span>(<span class="params">topic, msg</span>) </span>&#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">&quot;this is another subscriber, data is :&quot;</span> + msg)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;],</span><br><span class="line">  topic2: [&#123; <span class="attr">token</span>: <span class="number">2</span>, <span class="attr">func</span>: callback3 &#125;, &#123; <span class="attr">token</span>: <span class="number">3</span>, <span class="attr">func</span>: callback4 &#125;],</span><br><span class="line">  topic3: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>消息池的结构是发布订阅模式与事件监听模式的最大区别。每个消息也可以看做是一个个的事件，topics对象就相当于一个事件处理中心，每个事件都有各自的订阅者。<em>事件监听其实就是发布订阅模式的一个简化版本。</em></p>
<p>而发布订阅模式的优点就是我们可以查看消息中心的信息，了解有多少信号，每个信号有多少订阅者。</p>
<h2 id="观察者"><a href="#观察者" class="headerlink" title="观察者"></a>观察者</h2><p>很多情况下，我们都将观察者模式和发布-订阅模式混为一谈，因为都可用来进行异步通信，实现代码的解耦，而不再细究其不同，但是内部实现还是有很多不同的。</p>
<ol>
<li><strong>整体模型</strong>的不同：发布订阅模式是靠信息池作为发布者和订阅者的中转站的，订阅者订阅的是信息池中的某个信息；而观察者模式是直接将订阅者订阅到发布者内部的，目标对象需要负责维护观察者，也就是观察者模式中订阅者是依赖发布者的。</li>
<li><strong>触发回调的方式</strong>不同：发布-订阅模式中，订阅者通过监听特定消息来触发回调；而观察者模式是发布者暴露一个接口(方法)，当目标对象发生变化时调用此接口，以保持自身状态的及时改变。</li>
</ol>
<p>观察者模式很好的应用是MVC架构，当数据模型更新时，视图也发生变化。从数据模型中将视图解耦出来，从而减少了依赖。但是当观察者数量上升时，性能会有显著下降。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//观察者模式</span></span><br><span class="line"><span class="keyword">var</span> Subject=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">this</span>.observers=[];</span><br><span class="line">&#125;</span><br><span class="line">Subject.prototype=&#123;</span><br><span class="line">    subscribe:<span class="function"><span class="keyword">function</span>(<span class="params">observer</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">this</span>.observers.push(observer);</span><br><span class="line">    &#125;,</span><br><span class="line">    unsubscribe:<span class="function"><span class="keyword">function</span>(<span class="params">observer</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> index=<span class="built_in">this</span>.observers.indexOf(observer);</span><br><span class="line">        <span class="keyword">if</span> (index&gt;-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.observers.splice(index,<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    notify:<span class="function"><span class="keyword">function</span>(<span class="params">observer,msg</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> index=<span class="built_in">this</span>.observers.indexOf(observer);</span><br><span class="line">        <span class="keyword">if</span> (index&gt;-<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="built_in">this</span>.observers[index].notify(msg)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    notifyAll:<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(msg) <span class="comment">//all notified</span></span><br><span class="line">        <span class="built_in">this</span>.observers.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">observe,msg</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(msg) <span class="comment">//0 1 2 3,这里的msg相当于forEach的index</span></span><br><span class="line">            observe.notify(msg) </span><br><span class="line">        &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> Observer=<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        notify:<span class="function"><span class="keyword">function</span>(<span class="params">msg</span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&quot;received: &quot;</span>+msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> subject=<span class="keyword">new</span> Subject();</span><br><span class="line"><span class="keyword">var</span> observer0=<span class="keyword">new</span> Observer();</span><br><span class="line"><span class="keyword">var</span> observer1=<span class="keyword">new</span> Observer();</span><br><span class="line"><span class="keyword">var</span> observer2=<span class="keyword">new</span> Observer();</span><br><span class="line"><span class="keyword">var</span> observer3=<span class="keyword">new</span> Observer();</span><br><span class="line">subject.subscribe(observer0);</span><br><span class="line">subject.subscribe(observer1);</span><br><span class="line">subject.subscribe(observer2);</span><br><span class="line">subject.subscribe(observer3);</span><br><span class="line">subject.notifyAll(<span class="string">&#x27;all notified&#x27;</span>); <span class="comment">//received: 0, received: 1, received: 2, received: 3</span></span><br><span class="line">subject.notify(observer2,<span class="string">&#x27;asda&#x27;</span>); <span class="comment">//received: asda</span></span><br></pre></td></tr></table></figure>
<h2 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h2><p>Promise，就是一个<strong>对象</strong>，用来传递异步操作的消息。</p>
<p>Promise 对象代表一个异步操作，有<strong>三种状态</strong>：<code>Pending</code>（进行中）、<code>Resolved</code>（已完成，又称 Fulfilled）和 <code>Rejected</code>（已失败）。</p>
<p>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是 Promise 这个名字的由来，它的英语意思就是「承诺」，表示其他手段<strong>无法改变</strong>。</p>
<p><strong>resolve</strong>函数的作用是，将 Promise 对象的状态从 <code>未处理</code> 变成 <code>处理成功</code> (unresolved =&gt; resolved)， 在异步操作成功时调用，并将异步操作的<strong>结果</strong>作为参数<strong>传递出去</strong>。</p>
<p><strong>reject</strong>函数的作用是，将 Promise 对象的状态从 <code>未处理</code> 变成 <code>处理失败</code>(unresolved =&gt; rejected), 在异步操作失败时调用，并将异步操作报出的<strong>错误</strong>作为参数<strong>传递出去</strong>。</p>
<p>Promise 实例生成以后，可以用 <strong>then</strong> 方法和 <strong>catch</strong> 方法分别指定 resolved 状态和 rejected 状态的<strong>回调函数</strong>。</p>
<h3 id="做饭、吃饭、洗碗（cook、eat、wash）示例"><a href="#做饭、吃饭、洗碗（cook、eat、wash）示例" class="headerlink" title="做饭、吃饭、洗碗（cook、eat、wash）示例"></a>做饭、吃饭、洗碗（cook、eat、wash）示例</h3><p>定义这三个方法，它们是层层依赖的关系，下一步的的操作需要使用上一部操作的结果。（这里使用 setTimeout 模拟异步操作）</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//做饭</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cook</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始做饭&#x27;</span>);</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;        <span class="comment">//做一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;做饭完毕&#x27;</span>);</span><br><span class="line">            resolve(<span class="string">&#x27;鸡蛋炒饭&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//吃饭</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">eat</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始吃饭：&#x27;</span> + data);</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;        <span class="comment">//做一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;吃饭完毕&#x27;</span>);</span><br><span class="line">            resolve(<span class="string">&#x27;一块碗一双筷子&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wash</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;开始洗碗：&#x27;</span> + data);</span><br><span class="line">    <span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;        <span class="comment">//做一些异步操作</span></span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">&#x27;洗碗完毕&#x27;</span>);</span><br><span class="line">            resolve(<span class="string">&#x27;干净的碗筷&#x27;</span>);</span><br><span class="line">        &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用 then 链式调用这三个方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">cook()</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> eat(data);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> wash(data);</span><br><span class="line">&#125;)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//上面代码还可以简化成如下：</span></span><br><span class="line">cook()</span><br><span class="line">.then(eat)</span><br><span class="line">.then(wash)</span><br><span class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(data);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">//运行结果:</span></span><br><span class="line">开始做饭</span><br><span class="line">做饭完毕</span><br><span class="line">开始吃饭：鸡蛋炒饭</span><br><span class="line">吃饭完毕</span><br><span class="line">开始洗碗：一块碗一双筷子</span><br><span class="line">洗碗完毕</span><br><span class="line">干净的碗筷</span><br></pre></td></tr></table></figure>
<h3 id="再举一个需要多层回调的例子"><a href="#再举一个需要多层回调的例子" class="headerlink" title="再举一个需要多层回调的例子"></a>再举一个需要多层回调的例子</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">takeLongTime</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>resolve(n+<span class="number">200</span>),n)</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step1</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step1 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step2</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step2 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">step3</span>(<span class="params">n</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`step3 with <span class="subst">$&#123;n&#125;</span>`</span>);</span><br><span class="line">    <span class="keyword">return</span> takeLongTime(n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Promise的方式将其3个步骤处理为链式操作，每一步都返回一个promise对象，将输出的结果作为下一步新的输入：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dolt</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;dolt&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1=<span class="number">300</span>;</span><br><span class="line">    step1(time1)</span><br><span class="line">    .then(<span class="function"><span class="params">time2</span>=&gt;</span>step2(time2))</span><br><span class="line">    .then(<span class="function"><span class="params">time3</span>=&gt;</span>step3(time3))</span><br><span class="line">    .then(<span class="function"><span class="params">result</span>=&gt;</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">        <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;dolt&#x27;</span>)</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">dolt();</span><br><span class="line"><span class="comment">//输出结果为:</span></span><br><span class="line">step1 <span class="keyword">with</span> <span class="number">300</span></span><br><span class="line">step2 <span class="keyword">with</span> <span class="number">500</span></span><br><span class="line">step3 <span class="keyword">with</span> <span class="number">700</span></span><br><span class="line">result is <span class="number">900</span></span><br><span class="line">dolt: <span class="number">1506.</span>291ms</span><br></pre></td></tr></table></figure>
<p>缺点：对于长的链式操作来说，看起来是一堆then方法的堆砌，代码冗余，语义也不清楚，靠着箭头函数才使得代码略微简短一些。还有一个痛点，就是传递参数太麻烦，尤其是需要传递多参数的情况下。</p>
<h2 id="Generator函数"><a href="#Generator函数" class="headerlink" title="Generator函数"></a>Generator函数</h2><p>generator是一个封装的异步任务，在需要暂停的地方，使用yield语句注明。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">gen</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> y=<span class="keyword">yield</span> x+<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> g=gen(<span class="number">1</span>);</span><br><span class="line">g.next(); <span class="comment">//&#123;value: 3, done: false&#125;</span></span><br><span class="line">g.next(); <span class="comment">//&#123;value: undefined, done: true&#125;</span></span><br></pre></td></tr></table></figure>
<p>调用generator函数返回的是内部的指针对象，调用next方法就会移动内部指针。Generator函数之所以能被用来处理异步操作，因为它可以暂停执行和恢复执行、函数体内外的数据交换和错误处理机制。</p>
<h3 id="前面多任务的例子，使用generator实现"><a href="#前面多任务的例子，使用generator实现" class="headerlink" title="前面多任务的例子，使用generator实现"></a>前面多任务的例子，使用generator实现</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">dolt</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;dolt&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1 = <span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2 = <span class="keyword">yield</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3 = <span class="keyword">yield</span> step2(time2);</span><br><span class="line">    <span class="keyword">const</span> result = <span class="keyword">yield</span> step3(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;dolt&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Generator 函数的执行必须靠执行器</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">spawn</span>(<span class="params">genF</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> gen = genF();</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">step</span>(<span class="params">nextF</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> next = nextF();</span><br><span class="line">      &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">        <span class="keyword">return</span> reject(e); </span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(next.done) &#123;</span><br><span class="line">        <span class="keyword">return</span> resolve(next.value);</span><br><span class="line">      &#125; </span><br><span class="line">      <span class="built_in">Promise</span>.resolve(next.value).then(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(v); &#125;);      </span><br><span class="line">      &#125;, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.throw(e); &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    step(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="keyword">return</span> gen.next(<span class="literal">undefined</span>); &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line">spawn(dolt); <span class="comment">//输出相同</span></span><br></pre></td></tr></table></figure>
<h2 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h2><p>async函数基于Generator又做了几点改进：</p>
<ul>
<li>内置执行器，将Generator函数和自动执行器进一步包装。</li>
<li>语义更清楚，async表示函数中有异步操作，await表示等待着紧跟在后边的表达式的结果。</li>
<li>适用性更广泛，await后面可以跟promise对象和原始类型的值(Generator中不支持)</li>
</ul>
<p>它基于Promise使用async/await来优化then链的调用,其实也是Generator函数的语法糖。 async 将其后的函数（函数表达式或 Lambda）的返回值封装成一个 Promise 对象， await 会等待这个 Promise 完成，并将其 resolve 的结果返回出来。</p>
<h3 id="用async-await重写前面的回调任务"><a href="#用async-await重写前面的回调任务" class="headerlink" title="用async/await重写前面的回调任务"></a>用async/await重写前面的回调任务</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">function</span> <span class="title">dolt</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.time(<span class="string">&#x27;dolt&#x27;</span>);</span><br><span class="line">    <span class="keyword">const</span> time1=<span class="number">300</span>;</span><br><span class="line">    <span class="keyword">const</span> time2=<span class="keyword">await</span> step1(time1);</span><br><span class="line">    <span class="keyword">const</span> time3=<span class="keyword">await</span> step2(time2);</span><br><span class="line">    <span class="keyword">const</span> result=<span class="keyword">await</span> step3(time3);</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">`result is <span class="subst">$&#123;result&#125;</span>`</span>);</span><br><span class="line">    <span class="built_in">console</span>.timeEnd(<span class="string">&#x27;dolt&#x27;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">dolt(); <span class="comment">//输出相同</span></span><br></pre></td></tr></table></figure>
<p>await只能用在async函数中，否则会报错。</p>
]]></content>
      <categories>
        <category>JS</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>闭包和执行上下文</title>
    <url>/JS/%E7%AC%94%E8%AE%B0/js/9.%E9%97%AD%E5%8C%85%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/</url>
    <content><![CDATA[<h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>闭包其实只是一个绑定了执行环境的函数。<br>闭包包含两个部分：</p>
<ul>
<li>环境部分<ul>
<li>环境：函数的词法环境（执行上下文的一部分）</li>
<li>标识符列表：函数中用到的未声明的变量</li>
</ul>
</li>
<li>表达式部分：函数体</li>
</ul>
<a id="more"></a>

<h2 id="执行上下文：执行的基础设施"><a href="#执行上下文：执行的基础设施" class="headerlink" title="执行上下文：执行的基础设施"></a>执行上下文：执行的基础设施</h2><p>一段代码（包括函数），执行所需的所有信息定义为：“执行上下文”。<br>在 ES2018 中，执行上下文是这样的：</p>
<ul>
<li>lexical environment：词法环境，当获取变量或者 this 值时使用。</li>
<li>variable environment：变量环境，当声明变量时使用。</li>
<li>code evaluation state：用于恢复代码执行位置。</li>
<li>Function：执行的任务是函数时使用，表示正在被执行的函数。</li>
<li>ScriptOrModule：执行的任务是脚本或者模块时使用，表示正在被执行的代码。</li>
<li>Realm：使用的基础库和内置对象实例。</li>
<li>Generator：仅生成器上下文有这个属性，表示当前生成器。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">1</span></span><br><span class="line"><span class="built_in">this</span>.a = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>要想正确执行它，我们需要知道以下信息：</p>
<ol>
<li>var 把 b 声明到哪里；</li>
<li>b 表示哪个变量；</li>
<li>b 的原型是哪个对象；</li>
<li>let 把 c 声明到哪里；</li>
<li>this 指向哪个对象。</li>
</ol>
<h3 id="var-声明与赋值"><a href="#var-声明与赋值" class="headerlink" title="var 声明与赋值"></a>var 声明与赋值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b = <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>var 会穿透 for 、if 等语句。</p>
<p>在只有 var，没有 let 的旧 JavaScript 时代，诞生了一个技巧，叫做：立即执行的函数表达式（IIFE），通过创建一个函数，并且立即执行，来构造一个新的域，从而控制 var 的范围。</p>
<p>比较推荐的写法是使用 void 关键字：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  <span class="comment">//code</span></span><br><span class="line">&#125;();</span><br></pre></td></tr></table></figure>
<p>这有效避免了语法问题，同时，语义上 void 运算表示忽略后面表达式的值，变成 undefined，我们确实不关心 IIFE 的返回值，所以语义也更为合理。</p>
<p>使用 with 的时候，var 的特性会导致声明的变量和被赋值的变量是两个 b：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> b;</span><br><span class="line"><span class="keyword">void</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> env = &#123;<span class="attr">b</span>:<span class="number">1</span>&#125;;</span><br><span class="line">    b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&quot;In function b:&quot;</span>, b); <span class="comment">//2</span></span><br><span class="line">    <span class="function"><span class="title">with</span>(<span class="params">env</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">var</span> b = <span class="number">3</span>;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">&quot;In with b:&quot;</span>, b); <span class="comment">//3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;();</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">&quot;Global b:&quot;</span>, b); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，利用立即执行的函数表达式（IIFE）构造了一个函数的执行环境。</p>
<p>在 Global function with 三个环境中，b 的值都不一样，而在 function 环境中，并没有出现 var b，这说明 with 内的 var b 作用到了 function 这个环境当中。</p>
<p>var b = {} 这样一句对两个域产生了作用，从语言的角度是个非常糟糕的设计，这也是一些人坚定地反对在任何场景下使用 with 的原因之一。</p>
<h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>et 是 ES6 开始引入的新的变量声明模式。为了实现 let，JS在运行时引入了块级作用域。在 let 出现之前，JS 的 if for 等语句皆不产生作用域。</p>
<p>以下语句会产生 let 使用的作用域：</p>
<ul>
<li>for；</li>
<li>if；</li>
<li>switch；</li>
<li>try/catch/finally。</li>
</ul>
<h3 id="Realm"><a href="#Realm" class="headerlink" title="Realm"></a>Realm</h3><p>在最新的标准（9.0）中，JavaScript 引入了一个新概念 Realm，它的中文意思是“国度”“领域”“范围”，但是都不太适合JS的语境。</p>
<p>Realm 中包含一组完整的内置对象，而且是复制关系。对不同 Realm 中的对象操作，会有一些需要格外注意的问题，比如 instanceOf 几乎是失效的。</p>
<p>如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">&#x27;iframe&#x27;</span>)</span><br><span class="line"><span class="built_in">document</span>.documentElement.appendChild(iframe)</span><br><span class="line">iframe.src=<span class="string">&quot;javascript:var b = &#123;&#125;;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> b1 = iframe.contentWindow.b;</span><br><span class="line"><span class="keyword">var</span> b2 = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> b1, <span class="keyword">typeof</span> b2); <span class="comment">//object object</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(b1 <span class="keyword">instanceof</span> <span class="built_in">Object</span>, b2 <span class="keyword">instanceof</span> <span class="built_in">Object</span>); <span class="comment">//false true</span></span><br></pre></td></tr></table></figure>
<p>由于 b1、 b2 由同样的代码“ {} ”在不同的 Realm 中执行，所以表现出了不同的行为。</p>
]]></content>
      <categories>
        <category>JS</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>JS</tag>
      </tags>
  </entry>
  <entry>
    <title>01_初识Vue</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/01-%E5%88%9D%E8%AF%86Vue/</url>
    <content><![CDATA[<h2 id="Vue渐进式的框架-声明式编程"><a href="#Vue渐进式的框架-声明式编程" class="headerlink" title="Vue渐进式的框架(声明式编程)"></a>Vue渐进式的框架(声明式编程)</h2><h3 id="什么是渐进式"><a href="#什么是渐进式" class="headerlink" title="什么是渐进式"></a>什么是渐进式</h3><p>​        渐进式意味着你可以将Vue作为你应用的一部分嵌入其中，带来更丰富的交互体验。</p>
<p>​        或者如果你希望将更多的业务逻辑使用Vue实现，那么Vue的核心库以及其生态系统。</p>
<p>​        比如Core+Vue-router+Vuex，也可以满足你各种各样的需求。</p>
<a id="more"></a>



<p><strong>JavaScript是命令式编程，Vue是声明式编程</strong></p>
<h3 id="Vue有很多特点和Web开发中常见的高级功能"><a href="#Vue有很多特点和Web开发中常见的高级功能" class="headerlink" title="Vue有很多特点和Web开发中常见的高级功能"></a>Vue有很多特点和Web开发中常见的高级功能</h3><p>解耦视图和数据</p>
<p>可复用的组件</p>
<p>前端路由技术</p>
<p>状态管理</p>
<p>虚拟DOM</p>
<h3 id="安装Vue"><a href="#安装Vue" class="headerlink" title="安装Vue"></a>安装Vue</h3><ul>
<li>CDN引入</li>
<li>下载引入</li>
<li>npm安装</li>
</ul>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
<p>16</p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>02_Vue的使用</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/02-Vue%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="Vue的使用"><a href="#Vue的使用" class="headerlink" title="Vue的使用"></a>Vue的使用</h2><p>在js代码中使用Vue时，先构造一个vue对象的实例。</p>
<p>Vue是个构造函数，该构造函数在创建实例时可向内部传入一个对象作为参数，对象内部可存放的属性有：</p>
<p>el：其值为css选择器，表示该vue实例管理的DOM区域</p>
<a id="more"></a>

<p>data：其值为一个对象或一个函数，内部存储的是该管理DOM区域的数据</p>
<p>methods：其值为一个对象，内部存储函数(事件监听的回调)<br><font color="red"><strong>注意：</strong></font>这些函数中如果使用了this则不能使用箭头函数。</p>
<h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p><a href="https://www.cnblogs.com/caoyi/p/11356500.html">Vue生命周期详解</a></p>
<p>创建前后 挂载前后 更新前后 销毁前后 一共八个生命周期</p>
<p>记住dom渲染完毕，是在mounted</p>
<p><strong>activated和deactivated</strong>这两个回调是<strong>只有在当组件在keep-alive中时（保持了状态）</strong>（否则执行的就是销毁回调了），当组件处于活跃中时调用前者，不活跃时调用后者。</p>
<p><a href="https://imgchr.com/i/s9SqhV"><img src="https://s3.ax1x.com/2021/01/03/s9SqhV.png" alt="s9SqhV.png"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>04_有关webpack</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/04-%E6%9C%89%E5%85%B3webpack/</url>
    <content><![CDATA[<h4 id="1-什么是webpack"><a href="#1-什么是webpack" class="headerlink" title="1. 什么是webpack"></a>1. 什么是webpack</h4><ul>
<li>webpack和gulp对比</li>
<li>webpack依赖环境</li>
<li>安装webpack</li>
</ul>
<a id="more"></a>

<h4 id="2-webpack的起步"><a href="#2-webpack的起步" class="headerlink" title="2. webpack的起步"></a>2. webpack的起步</h4><ul>
<li>webpack命令</li>
<li>webpack配置: webpack.config.js/package.json(scripts)</li>
</ul>
<p>文件目录解析：</p>
<p><a href="https://imgchr.com/i/s9pSB9"><img src="https://s3.ax1x.com/2021/01/03/s9pSB9.png" alt="s9pSB9.png"></a></p>
<h4 id="3-webpack的loader"><a href="#3-webpack的loader" class="headerlink" title="3. webpack的loader"></a>3. webpack的loader</h4><ul>
<li>css-loader/style-loader</li>
<li>less-loader/less</li>
<li>url-loader/file-loader</li>
<li>babel-loader</li>
</ul>
<h4 id="4-webpack中配置Vue"><a href="#4-webpack中配置Vue" class="headerlink" title="4. webpack中配置Vue"></a>4. webpack中配置Vue</h4><ul>
<li>vue-loader</li>
</ul>
<p>模板快捷键：default</p>
<p><strong>安装vue-loader和vue-template-compiler</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install vue-loader vue-template-compiler --save-dev</span><br></pre></td></tr></table></figure>
<h4 id="5-webpack的plugin"><a href="#5-webpack的plugin" class="headerlink" title="5. webpack的plugin"></a>5. webpack的plugin</h4><h4 id="6-搭建本地服务器"><a href="#6-搭建本地服务器" class="headerlink" title="6. 搭建本地服务器"></a>6. 搭建本地服务器</h4><ul>
<li>webpack-dev-server</li>
</ul>
<h4 id="7-配置文件的分离"><a href="#7-配置文件的分离" class="headerlink" title="7. 配置文件的分离"></a>7. 配置文件的分离</h4><h4 id="执行npm-run-build的过程"><a href="#执行npm-run-build的过程" class="headerlink" title="执行npm run build的过程"></a><font color="red">执行npm run build的过程</font></h4><p><a href="https://imgchr.com/i/s9pCA1"><img src="https://s3.ax1x.com/2021/01/03/s9pCA1.png" alt="s9pCA1.png"></a></p>
<h4 id="执行npm-run-dev的过程"><a href="#执行npm-run-dev的过程" class="headerlink" title="执行npm run dev的过程"></a><font color="red">执行npm run dev的过程</font></h4><p><a href="https://imgchr.com/i/s9pih6"><img src="https://s3.ax1x.com/2021/01/03/s9pih6.png" alt="s9pih6.png"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>05_Vue Cli</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/05-Vue-Cli/</url>
    <content><![CDATA[<h2 id="一-初见Vue-Cli"><a href="#一-初见Vue-Cli" class="headerlink" title="一.初见Vue Cli"></a>一.初见Vue Cli</h2><h3 id="1-1-什么是CLI"><a href="#1-1-什么是CLI" class="headerlink" title="1.1. 什么是CLI"></a>1.1. 什么是CLI</h3><ul>
<li>脚手架是什么东西.</li>
<li>CLI依赖webpack,node,npm</li>
<li>安装CLI3 -&gt; 拉去CLI2模块</li>
</ul>
<a id="more"></a>

<p>Cli是Command-Line Interface，翻译为命令行界面，但是俗称<font color="red">脚手架</font></p>
<p>Vue Cli是一个官方发布的vue.js项目脚手架</p>
<p>使用vue-cli可以快速的搭建Vue开发环境以及对应的webpack配置。</p>
<h3 id="1-2-安装Vue-Cli"><a href="#1-2-安装Vue-Cli" class="headerlink" title="1.2 安装Vue Cli"></a>1.2 安装Vue Cli</h3><p>安装Vue Cli</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli</span><br></pre></td></tr></table></figure>
<p>拉取2.x模板</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install -g @vue/cli-init</span><br></pre></td></tr></table></figure>
<p>初始化cli2项目</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue init webpack 项目名称</span><br></pre></td></tr></table></figure>
<p><a href="https://imgchr.com/i/s9pVje"><img src="https://s3.ax1x.com/2021/01/03/s9pVje.png" alt="s9pVje.png"></a></p>
<h3 id="1-3-cli2目录分析"><a href="#1-3-cli2目录分析" class="headerlink" title="1.3 cli2目录分析"></a>1.3 cli2目录分析</h3><p><a href="https://imgchr.com/i/s9pmBd"><img src="https://s3.ax1x.com/2021/01/03/s9pmBd.png" alt="s9pmBd.png"></a></p>
<h3 id="1-4-runtim-compiler于runtim-only的区别"><a href="#1-4-runtim-compiler于runtim-only的区别" class="headerlink" title="1.4 runtim-compiler于runtim-only的区别"></a>1.4 runtim-compiler于runtim-only的区别</h3><p>两者只在main.js文件中存在差异</p>
<p><a href="https://imgchr.com/i/s9pMNt"><img src="https://s3.ax1x.com/2021/01/03/s9pMNt.png" alt="s9pMNt.png"></a></p>
<p>首先来了解一下Vue程序的运行过程</p>
<p><a href="https://imgchr.com/i/s9p19f"><img src="https://s3.ax1x.com/2021/01/03/s9p19f.png" alt="s9p19f.png"></a></p>
<p>runtim-compiler<br>template –&gt; ast –&gt;render –&gt; vdom –&gt; UI</p>
<p>runtim-only    （性能更高，代码更少）<br>render –&gt; vdom –&gt; UI</p>
<ul>
<li><p>如果在之后的开发中，你依然使用template，就需要选择Runtime-Compiler</p>
</li>
<li><p>如果你之后的开发中，使用的是.vue文件夹开发，那么可以选择Runtime-only</p>
</li>
</ul>
<h3 id="1-5-render函数"><a href="#1-5-render函数" class="headerlink" title="1.5 render函数"></a><font color="red">1.5 render函数</font></h3><ul>
<li>不使用render函数:</li>
</ul>
<p><a href="https://imgchr.com/i/s9pYuQ"><img src="https://s3.ax1x.com/2021/01/03/s9pYuQ.png" alt="s9pYuQ.png"></a></p>
<ul>
<li>使用方式1：</li>
</ul>
<p><a href="https://imgchr.com/i/s9paEn"><img src="https://s3.ax1x.com/2021/01/03/s9paEn.png" alt="s9paEn.png"></a></p>
<ul>
<li>使用方式2：</li>
</ul>
<p><a href="https://imgchr.com/i/s9PBCt"><img src="https://s3.ax1x.com/2021/01/03/s9PBCt.png" alt="s9PBCt.png"></a></p>
<p>在.vue文件中的template模板，不需要进行template –&gt; ast –&gt;render –&gt; vdom –&gt; UI 中的前两步。</p>
<p><strong><font color="red">那么.vue文件中的template是由谁处理了呢？</font></strong><br>因为在解析.vue文件时，会经过<font color="red">vue-template-compiler</font>（安装vue时安装过的）来将.vue文件进行解析成一个对象。该对象中的template会被解析为render函数。</p>
<h2 id="二-Vue-Cli3"><a href="#二-Vue-Cli3" class="headerlink" title="二. Vue Cli3"></a>二. Vue Cli3</h2><p>在vue cli2中使用了flow-type(Facebook)<br>vue cli3中使用的是TypeScript(微软)</p>
<h3 id="2-1-创建cli3项目"><a href="#2-1-创建cli3项目" class="headerlink" title="2.1 创建cli3项目"></a>2.1 创建cli3项目</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vue create 项目名称</span><br></pre></td></tr></table></figure>
<p>选择配置</p>
<p><a href="https://imgchr.com/i/s9Prgf"><img src="https://s3.ax1x.com/2021/01/03/s9Prgf.png" alt="s9Prgf.png"></a></p>
<p>目录结构分析</p>
<p><a href="https://imgchr.com/i/s9PD8P"><img src="https://s3.ax1x.com/2021/01/03/s9PD8P.png" alt="s9PD8P.png"></a></p>
<p>在cli3中的.vue文件的vue的el属性写成了vue.$mount<br>原因:vue中el属性(vue管理的区域)在源码中是：vue.el等价于vue.$mount</p>
<h3 id="2-2-配置去哪儿了"><a href="#2-2-配置去哪儿了" class="headerlink" title="2.2 配置去哪儿了"></a>2.2 配置去哪儿了</h3><h4 id="2-2-1-第一种方式-使用vue-ui"><a href="#2-2-1-第一种方式-使用vue-ui" class="headerlink" title="2.2.1 第一种方式:使用vue ui"></a>2.2.1 第一种方式:使用vue ui</h4><p>在本地安装vue/cli时会同时安装了vue，在vue中包含了vue ui。在哪个目录下都可以使用，他管理的是本地服务器。然后导入项目中，即可查看该项目的配置。</p>
<h4 id="2-2-2-第二种方式-在文件目录中查找"><a href="#2-2-2-第二种方式-在文件目录中查找" class="headerlink" title="2.2.2 第二种方式:在文件目录中查找"></a>2.2.2 第二种方式:在文件目录中查找</h4><p>在node_modules@vue\cli-service\webpack.config.js中</p>
<h4 id="2-2-3-当需要修改默认配置"><a href="#2-2-3-当需要修改默认配置" class="headerlink" title="2.2.3 当需要修改默认配置"></a><font color="red">2.2.3 当需要修改默认配置</font></h4><p>在项目文件夹根目录下创建一个vue.config.js配置文件（文件名不能修改）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>08_axios框架</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/08-axios%E6%A1%86%E6%9E%B6/</url>
    <content><![CDATA[<p>有关JSONP去看BV1jt411j72F</p>
<h3 id="axios框架之认识axios"><a href="#axios框架之认识axios" class="headerlink" title="axios框架之认识axios"></a>axios框架之认识axios</h3><h4 id="1-选择什么网络模块"><a href="#1-选择什么网络模块" class="headerlink" title="1 选择什么网络模块"></a>1 选择什么网络模块</h4><ul>
<li>传统的Ajax是基于XMLHttpRequest(XHR)<br>不选择该方式：原因是配置和调用方式等非常混乱</li>
</ul>
<a id="more"></a>

<ul>
<li>jQuery-Ajax<br>不选择该方式：原因是没有必要为了用网络请求就引用这个重量级的框架</li>
<li>Vue-resource<br>不选择该方式：原因是作者不再维护，并且推荐使用axios</li>
<li>axios<br>axios有非常多的优点, 并且用起来也非常方便</li>
</ul>
<h4 id="2-axios的特点"><a href="#2-axios的特点" class="headerlink" title="2. axios的特点"></a>2. axios的特点</h4><ul>
<li><p>在浏览器中发送 XMLHttpRequests 请求</p>
</li>
<li><p>在 node.js 中发送 http请求</p>
</li>
<li><p>支持 Promise API</p>
</li>
<li><p>拦截请求和响应</p>
</li>
<li><p>转换请求和响应数据</p>
</li>
</ul>
<h4 id="3-使用axios"><a href="#3-使用axios" class="headerlink" title="3. 使用axios"></a>3. 使用axios</h4><p>首先安装axios框架：npm install axios –save</p>
<p>使用axios，首先他是框架与之前的vue-router、vuex插件把不同。插件在使用前必须用Vue.use安装插件。但是框架不用，使用npm安装完框架就可直接使用。</p>
<p>支持多种请求方式:</p>
<ul>
<li>axios(config)</li>
<li>axios.request(config)</li>
<li>axios.get(url[, config])</li>
<li>axios.delete(url[, config])</li>
<li>axios.head(url[, config])</li>
<li>axios.post(url[, data[, config]])</li>
<li>axios.put(url[, data[, config]])</li>
<li>axios.patch(url[, data[, config]])</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 1.基本使用</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://152.136.185.210:7878/api/m5/home/multidata&#x27;</span>,</span><br><span class="line">  method: <span class="string">&#x27;get&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2. 配置参数信息</span></span><br><span class="line">axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://152.136.185.210:7878/api/m5/home/data&#x27;</span>,</span><br><span class="line">  method: <span class="string">&#x27;get&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;) </span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.发送并发请求</span></span><br><span class="line">axios.all([axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://152.136.185.210:7878/api/m5/home/multidata&#x27;</span>,</span><br><span class="line">&#125;),axios(&#123;</span><br><span class="line">  url: <span class="string">&#x27;http://152.136.185.210:7878/api/m5/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;sell&#x27;</span>,</span><br><span class="line">    page: <span class="number">5</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)]).then(axios.spread(<span class="function">(<span class="params">res1,res2</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(res1)</span><br><span class="line">    <span class="built_in">console</span>.log(res2)</span><br><span class="line">&#125;))</span><br><span class="line"></span><br><span class="line"><span class="comment">// 全局配置</span></span><br><span class="line"><span class="comment">// 原因:在开发中很多参数都是固定的,此时就需要抽取这些参数.此时就用到了axios的全局配置</span></span><br><span class="line">axios.defaults.baseURL = <span class="string">&#x27;http://152.136.185.210:7878/api/m5&#x27;</span></span><br><span class="line">axios.defaults.timeout = <span class="number">5000</span></span><br></pre></td></tr></table></figure>
<p>常见的配置选项：</p>
<p><a href="https://imgchr.com/i/s9MJJO"><img src="https://s3.ax1x.com/2021/01/03/s9MJJO.png" alt="s9MJJO.png"></a></p>
<h4 id="4-axios实例"><a href="#4-axios实例" class="headerlink" title="4. axios实例"></a>4. axios实例</h4><p>​        前面的代码都是在使用全局的axios和对应的配置在进行网络请求，在现实中是不会这样做的。因为有可能每个功能需要访问的服务端地址不一样，这样就需要创建出不同的axios实例来处理不同的需求等等。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.创建axios实例</span></span><br><span class="line"><span class="keyword">const</span> instance1 = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;http://152.136.185.210:7878/api/m5&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">5000</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">instance1(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/data&#x27;</span>,</span><br><span class="line">  params: &#123;</span><br><span class="line">    type: <span class="string">&#x27;pop&#x27;</span>,</span><br><span class="line">    page: <span class="number">1</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当出现需要访问的服务端地址不同时,此时就在创建一个新的实例即可</span></span><br><span class="line"><span class="keyword">const</span> instance1 = axios.create(&#123;</span><br><span class="line">  baseURL: <span class="string">&#x27;http://222.111.33.33:8000&#x27;</span>,</span><br><span class="line">  timeout: <span class="number">3000</span></span><br><span class="line">&#125;)js</span><br></pre></td></tr></table></figure>


<h4 id="5-网络模块封装的重要性"><a href="#5-网络模块封装的重要性" class="headerlink" title="5. 网络模块封装的重要性"></a><font color="red">5. 网络模块封装的重要性</font></h4><p><strong><font color="deeppink">具体怎么一步步实现去看BV15741177Eh?p=146</font></strong></p>
<p>​        在选择使用网络模块时,一定要对其封装后再使用。原因是第三方的网络模块是有可能出现一些bug或者突然间不再维护。此时就得更换所选用的第三方模块。此时模块的封装就显得尤为重要。封装或进行模块的切换就变得容易许多。</p>
<p>​        封装方法：<br>​        首先在src文件夹下创建一个network文件用于存放网络层的封装。然后在内部创建对应模块的封装js文件。</p>
<p>​        然后在内部想方法让其return出去一个promise对象即可。在使用时直接调用then和catch方法去做回调。当第三方库出现问题后直接修改该文件,将改用的另一种第三方库也返回一个promise对象即可。</p>
<p>src/network/request.js</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> axios <span class="keyword">from</span> <span class="string">&#x27;axios&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">request</span>(<span class="params">config</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 1.创建axios实例</span></span><br><span class="line">  <span class="keyword">const</span> instance = axios.create(&#123;</span><br><span class="line">    baseURL: <span class="string">&#x27;http://152.136.185.210:7878/api/m5&#x27;</span>,</span><br><span class="line">    timeout: <span class="number">5000</span></span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 2.axios拦截器interceptors</span></span><br><span class="line">  <span class="comment">// 2.1.请求拦截的作用</span></span><br><span class="line">  <span class="comment">// 如果是axios调用interceptors则表示全局拦截即谁调用interceptors就会在那个作用域拦截</span></span><br><span class="line">  <span class="comment">// 这里是instance调用的interceptors则表示这个模块内的拦截</span></span><br><span class="line">  <span class="comment">// request表示请求的拦截   response表示响应的拦截 </span></span><br><span class="line">  instance.interceptors.request.use(<span class="function"><span class="params">config</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// 在请求成功的拦截中经常进行以下操作</span></span><br><span class="line">    <span class="comment">// 1.比如config中的一些信息不符合服务器的要求</span></span><br><span class="line">    <span class="comment">// 2.比如每次发送网络请求时, 都希望在界面中显示一个请求的图标</span></span><br><span class="line">    <span class="comment">// 3.某些网络请求(比如登录(token)), 必须携带一些特殊的信息</span></span><br><span class="line">    <span class="built_in">console</span>.log(config)  <span class="comment">// 这个config对象内存储的就是发送请求的配置信息</span></span><br><span class="line">    <span class="comment">// 记住拦截后要使用return config放行,不然后续就被禁止了</span></span><br><span class="line">    <span class="keyword">return</span> config</span><br><span class="line">  &#125;,<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2.2.响应拦截</span></span><br><span class="line">  instance.interceptors.response.use(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(res);  // 这个res就是服务器返回的具体数据信息</span></span><br><span class="line">    <span class="comment">// 记住拦截后要使用return放行,不然后续就被禁止了</span></span><br><span class="line">    <span class="keyword">return</span> res.data</span><br><span class="line">  &#125;, <span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(err);</span><br><span class="line">  &#125;)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 3.发送真正请求</span></span><br><span class="line">  <span class="keyword">return</span> instance(config) <span class="comment">// 这里instance调用后可以使用then和catch方法,证明在源码中他返回的是一个promise对象,直接把他return出去,使用后就可以直接调用then和catch方法去做回调.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当第三方库出现问题后直接修改该文件,将改用的另一种第三方库也返回一个promise对象即可.</span></span><br></pre></td></tr></table></figure>
<p>此时在使用时就这样使用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;request&#125; <span class="keyword">from</span> <span class="string">&#x27;./network/request.js&#x27;</span></span><br><span class="line"></span><br><span class="line">request(&#123;</span><br><span class="line">  url: <span class="string">&#x27;/home/multidata&#x27;</span></span><br><span class="line">&#125;).then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(res)</span><br><span class="line">&#125;).catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(err)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>


<h4 id="6-axios拦截器的使用"><a href="#6-axios拦截器的使用" class="headerlink" title="6. axios拦截器的使用"></a>6. axios拦截器的使用</h4><p> axios拦截器包括四种拦截器：</p>
<ul>
<li>请求成功与失败的拦截<br>需要拦截的axios实例.interceptors.request.use()<br>内部参数为两个函数第一个为成功的函数第二个为失败的函数</li>
<li>响应成功与失败的拦截<br>需要拦截的axios实例.interceptors.response.use()</li>
</ul>
<p>具体代码请看上一步的网络模块封装中。</p>
<h5 id="请求成功与失败的拦截"><a href="#请求成功与失败的拦截" class="headerlink" title="请求成功与失败的拦截"></a>请求成功与失败的拦截</h5><p>如果是axios调用interceptors则表示全局拦截即谁调用interceptors就会在那个作用域拦截<br>这里是instance调用的interceptors则表示这个模块内的拦截<br>request表示请求的拦截   response表示响应的拦截 </p>
<p>在请求成功的拦截中经常进行以下操作<br> 1.比如config中的一些信息不符合服务器的要求<br> 2.比如每次发送网络请求时, 都希望在界面中显示一个请求的图标<br> 3.某些网络请求(比如登录(token)), 必须携带一些特殊的信息</p>
<p>记住拦截后要使用return config放行,不然后续就被禁止了</p>
<p>这个config对象内存储的就是发送请求的配置信息</p>
<p>请求拦截中的config对象</p>
<p><a href="https://imgchr.com/i/s9MGFK"><img src="https://s3.ax1x.com/2021/01/03/s9MGFK.png" alt="s9MGFK.png"></a></p>
<h5 id="响应成功与失败的拦截"><a href="#响应成功与失败的拦截" class="headerlink" title="响应成功与失败的拦截"></a>响应成功与失败的拦截</h5><p>这个res就是服务器返回的具体数据信息</p>
<p>记住拦截后要使用return放行,不然后续就被禁止了（比如后续的then操作）</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>04_Git常用操作</title>
    <url>/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<h1 id="常用命令："><a href="#常用命令：" class="headerlink" title="常用命令："></a><font color="deeppink">常用命令：</font></h1><h3 id="git高层命令-curd"><a href="#git高层命令-curd" class="headerlink" title="git高层命令(curd)"></a>git高层命令(curd)</h3><ol>
<li><font color="cornflowerblue">git init</font><font color="orange">(初始化仓库)</font></li>
<li><font color="cornflowerblue">git add ./(这是你修改内容的路径./表示当前工作空间根目录，也可写具体文件目录)</font><font color="orange">(将修改添加到暂存区)</font></li>
<li><font color="cornflowerblue">git commit </font><font color="orange">(此时会进入编辑器，用于插入大量的注释)</font></li>
<li><font color="cornflowerblue">git commit -a</font><font color="orange">(跳过使用暂存区)</font><a id="more"></a></li>
<li><font color="cornflowerblue">git commit -m “注释内容”</font><font color="orange">(将暂存区提交到版本库)</font></li>
<li><font color="blue"><strong>git status</strong></font><font color="orange">(查看确定文件当前处于什么状态)</font></li>
<li><font color="blue">git diff</font><font color="orange">(查看当前有哪些更新还没有暂存？)</font></li>
<li><font color="blue">git diff –staged/git diff -–cached</font><font color="orange">(查看有哪些更新已经暂存还没提交)</font></li>
<li><font color="blue"><strong>git ls-files -s</strong></font><font color="orange">(查看暂存区)</font></li>
<li><font color="blue">mv  “原文件名”  “新文件名” </font><font color="orange">(更改文件名，接下来直接提交即可)</font></li>
<li><font color="blue">git rm 文件名 </font><font color="orange">(删除工作目录中的文件，并将该存入缓存区，接下来直接提交即可)</font></li>
<li><font color="blue"><strong>git log(参数：–pretty=oneline 出现在一行/–oneline出现在一行，并简写)</strong></font><font color="orange">(查看当前分支的状态)</font></li>
<li><font color="blue"><strong>git reflog</strong></font><font color="orange">(查看完整的历史记录)</font></li>
<li><font color="cornflowerblue">git log -g</font><font color="orange">(以标准日志的格式输出引用日志)</font></li>
<li><font color="blue"><strong>git config –global alias.加别名 原本命令(不要加git并要加双引号)</strong></font><font color="orange">(git配别名)</font></li>
</ol>
<h3 id="git高层命令-分支"><a href="#git高层命令-分支" class="headerlink" title="git高层命令(分支)"></a>git高层命令(分支)</h3><ol>
<li><p><font color="blue"><strong>git branch</strong></font><font color="orange">(显示分支列表)</font></p>
</li>
<li><p><font color="blue">git branch 分支名</font><font color="orange">(创建分支)</font></p>
</li>
<li><p><font color="blue"><strong>git branch -D 分支名</strong></font><font color="orange">(强行删除分支，但是不能自己删除自己，得切换到其他分支)</font></p>
</li>
<li><p>git branch -v(查看每个分支的最后一次提交)</p>
</li>
<li><p><font color="blue"><strong>git branch 自定义指针名 对应要跳转的分支hash缩写</strong></font><font color="orange">(该操作会在指定的hash对象出新建一个指针)</font></p>
</li>
<li><p><font color="blue"><strong>git switch 分支名</strong>(git checkout 分支名)</font><font color="orange">(切换分支)</font></p>
</li>
<li><p><font color="blue"><strong>git switch -c 分支名(git checkout -b 分支名)</strong></font><font color="orange">(相当于创建分支并切换到该分支)</font></p>
</li>
<li><p><font color="blue"><strong>git merge 分支名</strong></font><font color="orange">(分支合并)</font></p>
</li>
<li><p><font color="blue"><strong>git branch –merged</strong></font><font color="orange">(查看合并到当前分支的分支)一旦出现在该列表中，这些分支就要删除</font></p>
</li>
<li><p><font color="blue"><strong>git branch –no-merged</strong></font><font color="orange"><strong>一旦出现在该列表中，就应该观察一下是否需要合并</strong></font></p>
</li>
<li><p><font color="cornflowerblue">git log –oneline –decorate –graph –all</font><font color="orange">(查看完整分支图，<strong>我已经将该命令配置为了git lol</strong>)</font></p>
</li>
</ol>
<h3 id="git存储命令"><a href="#git存储命令" class="headerlink" title="git存储命令"></a><strong>git存储命令</strong></h3><ol>
<li><font color="blue"><strong>git stash</strong></font><font color="orange">(将未完成的修改保存到一个栈上)</font></li>
<li><font color="blue"><strong>git stash list</strong></font><font color="orange">(查看存储)</font></li>
<li><font color="cornflowerblue">git stash apply stash@{2}</font><font color="orange">(在栈中取出对应的内容但不会从栈中删除)</font></li>
<li><font color="cornflowerblue">git stash drop stash@{2}</font><font color="orange">(将栈中对应的元素删除）</font></li>
<li><font color="blue"><strong>git stash pop stash@{0}</strong></font><font color="orange">(应用栈中对应的元素，并将其从栈中移除）</font></li>
</ol>
<h3 id="restore-恢复-后悔药"><a href="#restore-恢复-后悔药" class="headerlink" title="restore(恢复)后悔药"></a><strong>restore(恢复)后悔药</strong></h3><ol>
<li><font color="blue"><strong>git restore filename</strong>(git checkout –filename)</font><font color="orange">撤回自己在工作目录中的修改</font></li>
<li><font color="blue"><strong>git restore –staged  filename</strong>(git reset HEAD filename)</font><font color="orange">撤回自己的暂存</font></li>
<li><font color="blue"><strong>git restore -s HEAD~1 filename</strong></font><font color="orange">撤回自己的提交</font></li>
<li><font color="blue"><strong>git commit –amend</strong></font><font color="orange">修改上次提交的注释</font></li>
</ol>
<h3 id="reset-重置-三部曲"><a href="#reset-重置-三部曲" class="headerlink" title="reset(重置)三部曲"></a><strong>reset(重置)三部曲</strong></h3><ol>
<li><font color="cornflowerblue">git reset –soft HEAD~</font><font color="orange">(移动HEAD)</font></li>
<li><font color="cornflowerblue">git reset [–mixed] HEAD~</font><font color="orange">(更新暂存区）</font></li>
<li><font color="cornflowerblue">git reset –hard HEAD~</font><font color="orange">(更新工作目录）</font></li>
<li><strong>路径reset</strong></li>
<li><strong><font color="red">checkout与git reset –hard HEAD~的区别</font></strong></li>
</ol>
<h3 id="数据恢复"><a href="#数据恢复" class="headerlink" title="数据恢复"></a>数据恢复</h3><ol>
<li>硬重置（不推荐）</li>
<li><strong>使用分支（推荐）</strong></li>
</ol>
<h3 id="打tag"><a href="#打tag" class="headerlink" title="打tag"></a>打tag</h3><ol>
<li><font color="blue">git tag v1.4 commitHash</font><font color="orange">创建标签</font></li>
<li><font color="blue">git tag -d tagname</font><font color="orange">删除标签</font></li>
<li><font color="blue">git show tagname</font><font color="orange">查看特定标签</font></li>
<li><font color="blue">git checkout tagname</font><font color="orange">检出标签**(注意使用检出标签后会出现头部分离现象)**</font></li>
</ol>
<h1 id="使用Git步骤："><a href="#使用Git步骤：" class="headerlink" title="使用Git步骤："></a><font color="deeppink">使用Git步骤：</font></h1><p>第一步：创建工作目录  </p>


<p>第二步：开始工作，对工作目录进行修改</p>
<p><font color="cornflowerblue">git add ./（这是你修改内容的路径./表示当前工作空间根目录，也可写具体文件目录）</font><font color="orange">（将修改添加到暂存区）</font></p>
<p>​        <font color="deeppink">这一步是将提交的修改的文件一个一个的存入暂存区（存入暂存区的会将之前的同名文件覆盖）如果该文件未曾被跟踪过则还会将其一个一个存入版本库（存成一个一个的git对象不是覆盖原本的而是创建一个新的）</font></p>
<p>​        <strong>暂存区存的是git对象的描述信息，也即在工作区执行（git add ./）命令时文件的描述信息，例如时间戳、内容的长度等，代表了此时文件的状态</strong></p>
<p>第三步：</p>
<p><font color="cornflowerblue">git commit -m “注释内容”</font><font color="orange">（将暂存区提交到版本库）</font></p>
<p>​        <font color="deeppink">这一步是表示暂存区的内容已经可以达到一个新的版本，需要提交，执行后现将暂存区进行一次快照，然后存入版本库（存入的是一个树对象），然后取出添加注释作者信息等，再将其封装为提交对象存入版本库</font></p>
<h3 id="工作目录下的文件分为两种"><a href="#工作目录下的文件分为两种" class="headerlink" title="工作目录下的文件分为两种"></a><font color="deeppink">工作目录下的文件分为两种</font></h3><ul>
<li><p><font color="red">未跟踪</font>（在显示时为红色）</p>
<p>跟踪文件既没有上次更新时的快照，也不在当前的暂存区域。</p>
</li>
<li><p><font color="red">已跟踪</font></p>
<p>​        已跟踪的文件是指本来就被纳入版本控制管理的文件，在上次快照中有它们的记录，工作一段时间后，它们的状态可能是<font color="cornflowerblue">已提交（不显示），已修改（在显示时为红色）或者已暂存（在显示时为绿色）</font></p>
</li>
</ul>
<p>使用 Git 时的文件状态变化周期如下图所示</p>
<p><a href="https://imgchr.com/i/s9SBOH"><img src="https://s3.ax1x.com/2021/01/03/s9SBOH.png" alt="s9SBOH.png"></a></p>
<p>​        当一个文件已暂存时，然后对文件进行修改，此时再对文件进行查看状态时，<font color="deeppink">该文件就会出现两个状态：已暂存和已修改（此时当次修改的git对象还未暂存）</font></p>
<p>​        实际上 Git 只不过暂存了你运行git add 命令时的版本，如果现在提交，那么提交的是修改前的版本，而非当前工作目录中的版本。所以，运行了git add 之后又作了修订的文件，需要重新运行git add 把最新版本重新暂存起来。</p>
<p>​        实际上 git status 的显示比较简单，仅仅是列出了修改过的文件，如果要查看具体修改了什么地方，可以用 git diff 命令.这个命令它已经能解决我们</p>
<p><strong>两个问题了：当前做的哪些更新还没有暂存？有哪些更新已经暂存起来准备好了下次提交？</strong></p>
<ul>
<li>当前做的哪些更新还没有暂存？，</li>
</ul>
<p>命令：git diff（不加参数直接输入 git diff）</p>
<ul>
<li>有哪些更新已经暂存起来准备好了下次提交？</li>
</ul>
<p>命令： git diff -–cached   或者 git diff –staged(1.6.1 以上)</p>
<p><strong>git commit进入编辑模式如何退出：</strong></p>
<p>1.Ubuntu下git commit后进入的是nano界面</p>
<p>2.输入需要内容后按下ctrl+x会提示是否保存</p>
<p>3.输入Y保存后按下回车即可退出</p>
<p><strong>跳过使用暂存区</strong></p>
<p><font color="blue">git commit -a</font></p>
<p>​        尽管使用暂存区域的方式可以精心准备要提交的细节，但有时候这么做略显繁琐。Git 提供了一个跳过使用暂存区域的方式， 只要在提交的时候， 给 git commit 加上-a 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过git add 步骤</p>
<p><strong>移除文件</strong></p>
<p><font color="blue">git rm 文件名 </font></p>
<p>​        相当于他先把该文件先从工作目录中删除，然后将其提交至缓存区，此时再使用git commit -m ‘注释’将修改后的缓存区快照存入版本库</p>
<p>并没有真正的删除文件，对之前的版本可内的记录没有任何影响</p>
<p><strong>文件改名</strong></p>
<p><font color="blue">mv  “原文件名”  “新文件名” </font></p>
<p>其实低层做的是先删除原文件再添加源文件</p>
<p>​        做完该操作依旧需要将文件加入缓存区，缓存区快照加入版本库</p>
<p><strong>查看暂存区</strong></p>
<p><font color="blue"><strong>git ls-files -s</strong></font></p>
<p><strong>查看历史记录</strong></p>
<p><font color="blue">git log（按q退出）</font></p>
<p><font color="blue">git log –pretty=oneline （出现在一行）</font></p>
<p><font color="blue">git log –oneline（出现在一行，并简写）</font></p>
<p><font color="blue"><strong>git reflog</strong></font></p>
<p><strong>只要head有变化,那么git reflog就会记录下来而git log当前分支的状态(不包括撤回和删除的内容)</strong></p>
<p><font color="deeppink"><strong>配置别名</strong></font></p>
<p><font color="cornflowerblue"><strong>git config –global alias.加别名 原本命令</strong></font></p>
<p><font color="red"><strong>注意:后边的原命令不能加git,如果原命令不止一个单词还要加双引号</strong></font></p>
<p>例如:</p>
<p>将查看完整分支图git log –oneline –decorate –graph –all这个命令配置为git lol则输入以下命令:</p>
<p><font color="blue">git config –global alias.lol “log –oneline –decorate –graph –all”</font></p>
<h2 id="分支操作-时光机-杀手功能"><a href="#分支操作-时光机-杀手功能" class="headerlink" title="分支操作(时光机)杀手功能"></a><font color="deeppink">分支操作(时光机)杀手功能</font></h2><p>​        使用分支意味着你可以把你的工作从开发主线上分离开来，以免影响开发主线。 </p>
<p><font color="red"><strong>分支就是指向最新提交对象的指针</strong></font></p>
<p>​        我们知道HEAD本质指向一个分支，分支的本质是一个提交对象<br>​        提交对象指向一个树对象，树对象又很有可能指向多个git对象，一个git对象代表一个文件!!!<br>​        HEAD可以代表一系列文件的状态!!!!</p>
<h4 id="查看分支列表"><a href="#查看分支列表" class="headerlink" title="查看分支列表"></a><strong>查看分支列表</strong></h4><p><font color="blue">git branch</font></p>
<h4 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支:"></a><strong>创建分支:</strong></h4><p><font color="cornflowerblue">git branch 分支名</font></p>
<p>​        为你创建了一个可以移动的新的指针。 比如，创建一个 testing 分支：git branch testing。这会在当前所在的提交对象上创建一个指针。<font color="red"><strong>注意！创建 一个新分支，并不会自动切换到新分支中去</strong></font></p>
<h4 id="显示分支列表"><a href="#显示分支列表" class="headerlink" title="显示分支列表"></a><strong>显示分支列表</strong></h4><p><font color="blue">git branch</font></p>
<h4 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a><strong>删除分支</strong></h4><p><font color="blue">git branch -D/-d 分支名</font>(小写是删除已经合并过的分支，大写是强制删除没有合并过的分支)</p>
<p><font color="deeppink"><strong>注意：假如当前处在a分支上就不能删除a分支(不能自己删除自己)需要先转到其他分支才能删除a分支</strong></font></p>
<p><strong>当文件处于未跟踪状态时使用强制删除命令会<font color="red">引发数据丢失的风险</font>，它也是 Git 会<font color="red">真正地销毁数据</font>的仅有的几个操作之一</strong></p>
<h4 id="查看每个分支最后一次提交"><a href="#查看每个分支最后一次提交" class="headerlink" title="查看每个分支最后一次提交"></a><strong>查看每个分支最后一次提交</strong></h4><p><font color="blue">git branch -v</font></p>
<p><strong><font color="red">分支的本质其实就是一个提交对象!!!</font></strong></p>
<p><strong><font color="red">HEAD: 是一个指针 它默认指向master分支 切换分支时其实就是让HEAD指向不同的分支 每次有新的提交时 HEAD都会带着当前指向的分支 一起往前移动</font></strong></p>
<p><font color="blue">git branch 自定义指针名 对应要跳转的分支hash缩写</font>(该操作会在指定的hash对象出新建一个指针,但现在指针指向并没有切过去,要手动切过去)</p>
<h4 id="切换分支"><a href="#切换分支" class="headerlink" title="切换分支"></a><strong>切换分支</strong></h4><p><font color="cornflowerblue">git switch 分支名(git checkout 分支名)</font></p>
<p><font color="blue">git switch -c 分支名(git checkout -b 分支名)</font><font color="orange">(相当于创建分支并切换到该分支)</font></p>
<p><strong><font color="red">新建一个分支并且使指针指向对应的分支对象</font></strong></p>
<p><font color="red"><strong>切换分支会更改三个地方:</strong></font></p>
<p>​        <strong>HEAD</strong>(对应的指针指向改变)</p>
<p>​        <strong>暂存区</strong>(暂存区内容跟随改变)</p>
<p>​        <strong>工作目录</strong>(工作目录内容跟随改变)</p>
<p>​        <strong>暂存区不会动(他只会一直增多)</strong></p>
<p><font color="deeppink"><strong>最佳实践：每次切换分支前,当前分支一定得是已经提交的状态(干净的)！！！</strong></font></p>
<h4 id="切换分支的坑！！！"><a href="#切换分支的坑！！！" class="headerlink" title="切换分支的坑！！！"></a><font color="red"><strong>切换分支的坑！！！</strong></font></h4><p>​        <strong>在切换分支时，如果当前分支上有未暂存的修改(第一次) 或者 有未提交的暂存(第一次)，分支可以切换成功，但是这种操作可能会污染其他分支</strong></p>
<p>​        如果不是第一次（该文件已经在此分支上提交过一次），如果在不是已经提交的状态下切换文件，此时就会提醒，不允许切换分支。</p>
<h4 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a><font color="red"><strong>注意点</strong></font></h4><p><font color="deeppink"><strong>在切换的时候 一定要保证当前分支是干净的!!!</strong></font></p>
<p><font color="Cyan"><strong>允许切换分支:</strong></font><br>   分支上所有的内容处于 已提交状态<br>    <strong>(避免)**分支上的内容是初始化创建 处于未跟踪状态<br>    **(避免)**分支上的内容是初始化创建 第一次处于已暂存状态<br><font color="Cyan">**不允许切分支:</font></strong><br>     分支上所有的内容处于 已修改状态  或 第二次以后的已暂存状态  </p>
<p><font color="Cyan"><strong>在分支上的工作做到一半时 如果有切换分支的需求, 我们应该将现有的工作存储起来</strong></font><br>    git stash : 会将当前分支上的工作推到一个栈中<br>    分支切换  进行其他工作 完成其他工作后 切回原分支<br>    git stash apply : 将栈顶的工作内容还原 但不让任何内容出栈<br>    git stash drop  : 取出栈顶的工作内容后 就应该将其删除(出栈)<br>    git stash pop   :      git stash apply +  git stash drop<br>    git stash list : 查看存储</p>
<h4 id="合并分支"><a href="#合并分支" class="headerlink" title="合并分支"></a><strong>合并分支</strong></h4><p><font color="blue">git merge 分支名</font></p>
<p>得先回到主分支，再将该分支合并到主分支（快进合并）快进合并不会产生冲突，但是对后续的合并有可能产生冲突</p>
<p>例子：</p>
<p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201208195953748.png" alt="image-20201208195953748"></p>
<p>此时将hotbug合并到主分支</p>
<p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201208200009367.png" alt="image-20201208200009367"></p>
<p>此时iss53就变成了过期的分支，在iss53分支中看不到c4中更改的内容，在这种情况下，iss53继续工作</p>
<p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201208200131377.png" alt="image-20201208200131377"></p>
<p>如果在iss53工作中野更改了c4中更改的内容，iss53工作完成了需要合并到主分支</p>
<p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201208202429549.png" alt="image-20201208202429549"></p>
<p>你在此时合并到主分支时就会存在冲突：你在该分支也更改了c4分支更改的文件，使用git merge iss53后会<strong>产生冲突</strong>，此时就需要打开冲突的文件进行<strong>解决冲突</strong>(修改业务逻辑)，然后使用git add ./ 然后提交到版本库再将分支删除就会<strong>完成冲突的解决(这种叫做典型合并即自己与自己的冲突)</strong><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201208202411314.png" alt="image-20201208202411314"></p>
<h4 id="查看合并到当前分支的分支"><a href="#查看合并到当前分支的分支" class="headerlink" title="查看合并到当前分支的分支"></a>查看合并到当前分支的分支</h4><p><font color="blue"><strong>git branch –merged</strong></font></p>
<p><font color="orange"><strong>一旦出现在该列表中，这些分支就要删除</strong></font></p>
<h4 id="查看没有合并到当前分支的分支"><a href="#查看没有合并到当前分支的分支" class="headerlink" title="查看没有合并到当前分支的分支"></a>查看没有合并到当前分支的分支</h4><p><font color="blue"><strong>git branch –no-merged</strong></font></p>
<p><font color="orange"><strong>一旦出现在该列表中，就应该观察一下是否需要合并</strong></font></p>
<h4 id="分支模式"><a href="#分支模式" class="headerlink" title="分支模式"></a><strong>分支模式</strong></h4><p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/01.png" alt="01"></p>
<p>在master下创建一个新的分支（取名为develop自己花名）<font color="orange"><strong>develop和master分支被叫做长期分支</strong></font></p>
<p>然后在自己的分支上创建各种功能分支（在完成功能后合并到自己的分支上）</p>
<h4 id="分支的本质"><a href="#分支的本质" class="headerlink" title="分支的本质"></a><strong>分支的本质</strong></h4><p><font color="red"><strong>Git 的分支，其实本质上仅仅是指向提交对象的可变指针</strong></font></p>
<p>​        分支就是一个没有后缀名的文件(提交对象)内部存储的是一个hsah值（存储在.git\refs\heads中）</p>
<p>​        那个可变指针是head（存储在根目录的HEAD文件中），每次移动的都是head，这个可变指针head带着提交对象移动。</p>
<h4 id="查看完整分支图"><a href="#查看完整分支图" class="headerlink" title="查看完整分支图"></a><strong>查看完整分支图</strong></h4><p><font color="blue">git log –oneline –decorate –graph –all</font></p>
<p>注意工作时整个分支图有可能很大（我已经将该命令配置为了git lol）</p>
<h2 id="Git存储"><a href="#Git存储" class="headerlink" title="Git存储"></a><font color="deeppink">Git存储</font></h2><p>当你在一个分支上的任务还未完成时，你需要切换分支，此时由于任务未完成，又不想提交，就可以使用git存储功能。</p>
<p>其实他帮你做了一次提交但是此次提交不会在git log –oneline中显示（但是通过查看完整分支图的命令会看到）</p>
<p>**<font color="blue">git stash</font>**将未完成的修改保存到一个栈上，而你可以在任何时候重新应用这些改动</p>
<p><strong><font color="blue">git stash list</font>查看存储</strong></p>
<p><font color="cornflowerblue">git stash apply stash@{2}</font>在栈中取出对应的内容但不会从栈中删除，如果不指定一个储藏，Git 认为指定的是最近的储藏</p>
<p><font color="cornflowerblue">git stash drop stash@{2} </font>将栈中对应元素删除</p>
<p><strong><font color="blue">git stash pop  stash@{2} </font>应用栈中对应元素并将其从栈中移除</strong></p>
<h2 id="撤回操作-后悔药"><a href="#撤回操作-后悔药" class="headerlink" title="撤回操作(后悔药)"></a><font color="deeppink"><strong>撤回操作(后悔药)</strong></font></h2><h4 id="工作区"><a href="#工作区" class="headerlink" title="工作区"></a><strong>工作区</strong></h4><p>​        如何撤回自己在工作目录中的修改</p>
<p>​        <font color="cornflowerblue">git restore filename(git checkout –filename)</font></p>
<p>​        <font color="red"><strong>注意：</strong></font>这是一个危险的命令，这很重要。 你对那个文件做的任何修改都会消失 - 你只是拷贝了另一个文件来覆盖它。除非你确实清楚不想要那个文件了， 否则不要使用这个命令</p>
<p><font color="orange"><strong>git restore是默认带着–worktree参数的</strong></font></p>
<p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201209092213576.png" alt="image-20201209092213576"></p>
<p><img src="/%E7%89%88%E6%9C%AC%E6%8E%A7%E5%88%B6/Git/git/04-Git%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/Users\dell\AppData\Roaming\Typora\typora-user-images\image-20201209092106548.png" alt="image-20201209092106548"></p>
<h4 id="暂存区"><a href="#暂存区" class="headerlink" title="暂存区"></a><strong>暂存区</strong></h4><p>​        如何撤回自己的暂存</p>
<p>​        <font color="cornflowerblue">git restore –staged  filename(git reset [HEAD] filename)</font></p>
<h4 id="版本库"><a href="#版本库" class="headerlink" title="版本库"></a><strong>版本库</strong></h4><p>​        如何撤回自己的提交（实际上没有撤销只是重新存入一份之前的一份在git log中看不到，在git reflog中能看到）</p>
<p>​        <font color="cornflowerblue">git restore -s HEAD~1 filename </font></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">$ git restore -s HEAD~<span class="number">1</span> READEME.md  <span class="comment">// 该命名表示将版本回退到当前快照的前一个版本</span></span><br><span class="line">$ git restore -s <span class="number">91410</span>eb9  READEME.md  <span class="comment">// 改命令指定明确的 commit id ，回退到指定的快照中</span></span><br><span class="line">$ git reset --soft HEAD^  <span class="comment">// 该命令表示撤销 commit 至上一次 commit 的版本</span></span><br></pre></td></tr></table></figure>
<p><strong>如果文件仅仅是注释写错了可以使用<font color="cornflowerblue">git commit –amend</font></strong></p>
<h2 id="reset三部曲"><a href="#reset三部曲" class="headerlink" title="reset三部曲"></a><font color="deeppink"><strong>reset三部曲</strong></font></h2><h3 id="移动HEAD"><a href="#移动HEAD" class="headerlink" title="移动HEAD"></a><strong>移动HEAD</strong></h3><p>​        <font color="cornflowerblue">git reset –soft HEAD~</font>(回到上一次提交对象)</p>
<p><font color="deeppink">(后边的HEAD~是个参数可写想要去的对象的hash)</font></p>
<p><font color="red"><strong>等价于后悔药版本库中的git commit –amend</strong></font></p>
<p>​        动HEAD(带着分支一起走)</p>
<p>​        而不动暂存区和工作目录</p>
<h3 id="更新暂存区-索引"><a href="#更新暂存区-索引" class="headerlink" title="更新暂存区(索引)"></a><strong>更新暂存区(索引)</strong></h3><p>​        <font color="cornflowerblue">git reset [–mixed] HEAD~</font>(回到上一次提交对象)</p>
<p><font color="deeppink">(后边的HEAD~是个参数可写想要去的对象的hash)</font></p>
<p><font color="red"><strong>等价于后悔药暂存库中的git reset HEAD filename</strong></font></p>
<p>​        动HEAD(带着分支一起走)</p>
<p>​        动暂存区</p>
<p>​        而不动工作目录</p>
<h3 id="更新工作目录"><a href="#更新工作目录" class="headerlink" title="更新工作目录"></a><strong>更新工作目录</strong></h3><p><font color="cornflowerblue">git reset –hard HEAD~</font>(回到上一次提交对象)</p>
<p>​    <font color="deeppink">(后边的HEAD~是个参数可写想要去的对象的hash)</font></p>
<p>​    <font color="red"><strong>类似于后悔药工作区中的git checkout –filename</strong></font></p>
<p>​        动HEAD(带着分支一起走)</p>
<p>​        动暂存区</p>
<p>​        动工作目录</p>
<p><font color="deeppink"><strong>该操作有危险不要用</strong></font></p>
<h4 id="注意点-1"><a href="#注意点-1" class="headerlink" title="注意点"></a><font color="red"><strong>注意点</strong></font></h4><p>​        必须注意，**–hard<strong>标记是</strong>reset<strong>命令<font color="red">**唯一的危险用法</font></strong>，它也是 Git 会<font color="red"><strong>真正地销毁数据</strong></font>的仅有的几个操作之一。 其他任何形式的<strong>reset</strong>调用都可以轻松撤消，但是**–hard**选项不能，因为它强制覆盖了工作目录中的文件。</p>
<p>​        在这种特殊情况下，我们的 Git 数据库中的一个提交内还留有该文件的 <strong>v3</strong> 版本， 我们可以通过reflog来找回它。但是若该文件还未提交，Git    仍会覆盖它从而导致无法恢复。 </p>
<h3 id="路径reset-只有–mixed才能跟路径"><a href="#路径reset-只有–mixed才能跟路径" class="headerlink" title="路径reset(只有–mixed才能跟路径)"></a>路径reset(只有–mixed才能跟路径)</h3><p><strong>所有的路径reset都要省略第一步！！！</strong></p>
<p>​        第一步是重置HEAD内容，我们知道HEAD本质指向一个分支 分支的本质是一个提交对象<br>​        提交对象指向一个树对象，树对象又很有可能指向多个git对象，一个git对象代表一个文件!!!<br>​        HEAD可以代表一系列文件的状态!!!!</p>
<p><font color="cornflowerblue">git reset [–mixed] HEAD filename     </font></p>
<p>​        原本是git reset [–mixed] HEADhsah。他的作用是更新暂存区，更改了HEAD和暂存区。但现在在后面加了一个文件名(因为第一步是更改head指向他不能指向一个文件,他只会指向一个树对象)所以这个HEADhsah就可不要(此时第一步也不会执行)最终变成<strong>git reset  filename</strong></p>
<p>​    reset 将会跳过第 1 步(即不更改HEAD)</p>
<p>​    只动了暂存区</p>
<p>​    不改工作目录</p>
<h3 id="checkout与git-reset-–hard-HEAD-的区别"><a href="#checkout与git-reset-–hard-HEAD-的区别" class="headerlink" title="checkout与git reset –hard HEAD~的区别"></a><font color="red"><strong>checkout与git reset –hard HEAD~的区别</strong></font></h3><p><font color="deeppink"><strong>git checkout 跟hash(分支名)</strong></font></p>
<p><font color="cornflowerblue">git  checkout 分支名(commithash)</font>与<font color="cornflowerblue">git reset –hard 提交对象(commithash)</font> 很相似     </p>
<p>​    两者都重置了HEAD，暂存区和工作目录</p>
<p>区别是：</p>
<ol>
<li><p>checkout只动HEAD(将head换到另一个分支)    </p>
<p>–hard动HEAD并带着分支一起走</p>
</li>
<li><p>checkout对工作目录是安全的(去看切换分支的坑)   </p>
<p>–hard是强制覆盖工作目录(该操作有危险不要用)</p>
</li>
</ol>
<p><font color="deeppink"><strong>git checkout 跟路径(文件名)</strong></font></p>
<p>git checkout –filename 相比于 git reset –hard  commitHash(只有–mixed才能跟路径)<br>      第一  第二步都没做(HEAD和暂存区都不动)<br>      只会动了工作目录</p>
<p><font color="deeppink">git checkout 跟hash和路径</font>(该命令基本不用)</p>
<p>git checkout  commithash filename</p>
<p>​      将会跳过第 1 步 (更改HEAD)<br>​      更新暂存区<br>​      更新工作目录   </p>
<h2 id="数据恢复-1"><a href="#数据恢复-1" class="headerlink" title="数据恢复"></a>数据恢复</h2><ol>
<li><h3 id="硬重置-不建议使用"><a href="#硬重置-不建议使用" class="headerlink" title="硬重置(不建议使用)"></a>硬重置(不建议使用)</h3><p>假设你提交了5次，我们将master分支硬重置到第三次提交</p>
<p><font color="cornflowerblue">git reset –hard 第三次hash</font></p>
<p>现在后两个的提交已经丢失，我们可以通过git reflog查看丢失的提交记录(存放在.git/logs/HEAD文件中)。</p>
<p>此时恢复回第五次提交就再次使用硬重置</p>
<p><font color="cornflowerblue">git rest –hard 第五次hash</font></p>
</li>
</ol>
<ol start="2">
<li><h3 id="使用分支-推荐使用"><a href="#使用分支-推荐使用" class="headerlink" title="使用分支(推荐使用)"></a>使用分支(推荐使用)</h3><p>看起来下面的那个就是你丢失的提交，你可以通过创建一个新的分支，指向这个提交来恢复它 。 例如，你可以创建一个 名为recover-branch 的分支指向这个提交（ab1afef）</p>
<p><font color="blue"><strong>git branch recover-branch ab1afef</strong></font></p>
<p>现在有一个名为 recover-branch 的分支是你的 master 分支曾经指向的地方，再一次使得前两次提交可到达了。</p>
</li>
</ol>
<h2 id="打tag-1"><a href="#打tag-1" class="headerlink" title="打tag"></a>打tag</h2><p>​        <font color="orange"><strong>标签就像一个不会动的分支</strong></font></p>
<p>​        Git 可以给历史中的某一个提交打上标签，以示重要。 比较有代表性的是人们会使用这个功能来标记发布结点（v1.0 等等）。</p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><ol>
<li><p><strong>轻量标签</strong>很像一个不会改变的分支 - 它只是一个特定提交的引用</p>
<p><strong><font color="blue">git tag v1.4</font></strong></p>
<p><strong><font color="blue">git tag v1.4 commitHash</font></strong></p>
</li>
<li><p><strong>附注标签</strong>是存储在 Git 数据库中的一个完整对象。它们是可以被校验的；其中包含打标签者的名字、电子 邮件地址、日期时间；还有一个标签信息；通常建议 创建附注标签，这样你可以拥有以上所有信息；但是如果你只是想用一个临时的标签，或者因为某些原因不想要保存那些信息，轻量标签也是可用的。</p>
<p><strong><font color="blue">git tag -a v1.4</font></strong></p>
<p><strong><font color="blue">git tag -a v1.4 commitHash</font></strong></p>
<p><strong><font color="blue">git tag -a v1.4 commitHash -m ‘my version 1.4’</font></strong></p>
</li>
</ol>
<h3 id="列出标签"><a href="#列出标签" class="headerlink" title="列出标签"></a>列出标签</h3><p><font color="blue">git tag</font></p>
<p><font color="cornflowerblue">git tag -l ‘v1.8.5*’</font>（显示出v1.8.5系列）</p>
<h3 id="查看特定标签"><a href="#查看特定标签" class="headerlink" title="查看特定标签"></a>查看特定标签</h3><p>​        git show 可以显示任意类型的对象（git 对象 树对象 提交对象 tag 对象）</p>
<p>​        <font color="cornflowerblue">git show tagname</font></p>
<h3 id="远程标签"><a href="#远程标签" class="headerlink" title="远程标签"></a>远程标签</h3><h3 id="删除标签"><a href="#删除标签" class="headerlink" title="删除标签"></a>删除标签</h3><p><strong><font color="blue">git tag -d tagname</font></strong></p>
<h3 id="检出标签-头部分离"><a href="#检出标签-头部分离" class="headerlink" title="检出标签(头部分离)"></a>检出标签(<font color="deeppink">头部分离</font>)</h3><p><strong><font color="blue">git checkout tagname</font></strong></p>
<p><strong>使用检出标签后会出现<font color="deeppink">头部分离</font>状态（HEAD指针到了标签的位置但是该指针没有指向一个分支）</strong>如果你做了某些更改然后提交它们，标签不会发生变化，但你的新提交将不属于任何分支，并且将无法访问，除非访问确切的提交哈希。<strong>因此当使用检出标签后<font color="deeppink">需要创建一个新分支</font></strong></p>
<p><strong><font color="blue">git checkout -b 分支名</font></strong></p>
<h1 id="Git特点"><a href="#Git特点" class="headerlink" title="Git特点"></a>Git特点</h1><ol>
<li><h3 id="直接记录快照，而非差异比较"><a href="#直接记录快照，而非差异比较" class="headerlink" title="直接记录快照，而非差异比较"></a>直接记录快照，而非差异比较</h3></li>
<li><h3 id="近乎所有操作都是本地执行"><a href="#近乎所有操作都是本地执行" class="headerlink" title="近乎所有操作都是本地执行"></a>近乎所有操作都是本地执行</h3></li>
<li><h3 id="时刻保持数据完整性"><a href="#时刻保持数据完整性" class="headerlink" title="时刻保持数据完整性"></a>时刻保持数据完整性</h3></li>
<li><h3 id="多数操作仅添加数据"><a href="#多数操作仅添加数据" class="headerlink" title="多数操作仅添加数据"></a>多数操作仅添加数据</h3></li>
<li><h3 id="文件的三种状态"><a href="#文件的三种状态" class="headerlink" title="文件的三种状态"></a>文件的三种状态</h3></li>
</ol>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15J411973T">尚硅谷Git教程全套完整版（12h深入掌握git）</a></p>
]]></content>
      <categories>
        <category>版本控制</category>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>06_Vue-router路由插件</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/06-Vue-router%E8%B7%AF%E7%94%B1%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1. 什么是路由?"></a>1. 什么是路由?</h2><h3 id="1-1-认识路由"><a href="#1-1-认识路由" class="headerlink" title="1.1 认识路由"></a>1.1 认识路由</h3><p>路由(routing)就是通过互联的网络把信息从源地址传输到目的地址的活动</p>
<ul>
<li>路由器提供了两种机制: 路由和转送.<ul>
<li>路由是决定数据包从<strong>来源</strong>到<strong>目的地</strong>的路径.</li>
<li>转送将<strong>输入端</strong>的数据转移到合适的<strong>输出端</strong>.</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li>路由中有一个非常重要的概念叫路由表.<ul>
<li>路由表本质上就是一个映射表, 决定了数据包的指向</li>
</ul>
</li>
</ul>
<p><a href="https://imgchr.com/i/s9ikad"><img src="https://s3.ax1x.com/2021/01/03/s9ikad.png" alt="s9ikad.png"></a></p>
<h3 id="1-2-前端路由的发展"><a href="#1-2-前端路由的发展" class="headerlink" title="1.2 前端路由的发展"></a>1.2 前端路由的发展</h3><h4 id="1-2-1-后端路由-后端渲染"><a href="#1-2-1-后端路由-后端渲染" class="headerlink" title="1.2.1 后端路由(后端渲染)"></a><font color="red">1.2.1 后端路由(后端渲染)</font></h4><h5 id="后端路由简介"><a href="#后端路由简介" class="headerlink" title="后端路由简介"></a>后端路由简介</h5><p>​        早期在开发网页时是通过jsp(Java Server Pages)/php开发的。（没有AJAX）<br>​        通常是浏览器将url发送到服务器，浏览器拿到以后进行解析，然后将其解析出对应的页面，在后端就用jsp将页面写好(html+css+java(java用来获取数据并将其动态渲染在页面))。然后将该页面发送到浏览器（仅发送html+css）。<font color="blue">这种方式就是后端渲染（服务端渲染）。</font>当用户点击跳转页面时，又会重复上述操作，再次将后端写好的页面发送到浏览器端。<font color="deeppink"><strong>总结：服务器直接生产渲染好对应的HTML页面, 返回给客户端进行展示。</strong></font></p>
<ul>
<li><p>一个页面有自己对应的网址, 也就是URL.</p>
</li>
<li><p>URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理.</p>
</li>
<li><p>Controller进行各种处理, 最终生成HTML或者数据, 返回给前端.</p>
</li>
<li><p>这就完成了一个IO操作.</p>
<p>​    此时，在后端总就存在一个类似于映射表。该映射表存储的就是每个url所对应的页面，<font color="red">这种映射关系就叫做后端路由</font>。</p>
</li>
</ul>
<h5 id="后端路由的优点"><a href="#后端路由的优点" class="headerlink" title="后端路由的优点:"></a><strong><font color="red">后端路由的优点:</font></strong></h5><p>​        这种情况下渲染好的页面, 不需要单独加载任何的js和css, 可以直接交给浏览器展示, 这样也有利于SEO的优化.</p>
<h5 id="后端路由的缺点"><a href="#后端路由的缺点" class="headerlink" title="后端路由的缺点:"></a><strong><font color="red">后端路由的缺点:</font></strong></h5><ul>
<li><p>一种情况是整个页面的模块由后端人员来编写和维护的.</p>
</li>
<li><p>另一种情况是前端开发人员如果要开发页面, 需要通过PHP和Java等语言来编写页面代码.</p>
</li>
<li><p>而且通常情况下HTML代码和数据以及对应的逻辑会混在一起, 编写和维护都是非常糟糕的事情.（耦合性太高）</p>
</li>
</ul>
<p><a href="https://imgchr.com/i/s9iPqe"><img src="https://s3.ax1x.com/2021/01/03/s9iPqe.png" alt="s9iPqe.png"></a></p>
<h4 id="1-2-2-前后端分离（前端渲染）"><a href="#1-2-2-前后端分离（前端渲染）" class="headerlink" title="1.2.2 前后端分离（前端渲染）"></a><font color="red">1.2.2 前后端分离（前端渲染）</font></h4><h5 id="前后端分离简介"><a href="#前后端分离简介" class="headerlink" title="前后端分离简介"></a>前后端分离简介</h5><p>​        由于AJAX的出现，后端只负责提供数据，不负责任何阶段的内容。</p>
<p>​        通常是浏览器将url发送到静态资源服务器（内部存储各个不同页面对应的一套html+css+js），浏览器从静态服务器拿到html+css+js，浏览器直接渲染html和css，并且js代码在浏览器中执行。在js中的<font color="blue">AJAX请求即API接口</font>，然后从提供接口的服务器中获得数据，然后按照其他的js代码将其插入到DOM树中。</p>
<p><font color="red">前端渲染</font>：浏览器中显示网页中大部分内容，都是由前端写的js代码在浏览器中执行，最终渲染出来的网页。</p>
<p><a href="https://imgchr.com/i/s9iFVH"><img src="https://s3.ax1x.com/2021/01/03/s9iFVH.png" alt="s9iFVH.png"></a></p>
<h5 id="前后端分离优点"><a href="#前后端分离优点" class="headerlink" title="前后端分离优点"></a><font color="red">前后端分离优点</font></h5><ul>
<li><p>前后端责任的清晰, 后端专注于数据上, 前端专注于交互和可视化上.</p>
</li>
<li><p><font color="cornflowerblue">并且当移动端(iOS/Android)出现后, 后端不需要进行任何处理, 依然使用之前的一套API即可.</font></p>
</li>
</ul>
<h4 id="1-2-3-SPA-单页面富应用-阶段-（前端路由）"><a href="#1-2-3-SPA-单页面富应用-阶段-（前端路由）" class="headerlink" title="1.2.3 SPA(单页面富应用)阶段  （前端路由）"></a><font color="red">1.2.3 SPA(单页面富应用)阶段  （前端路由）</font></h4><h5 id="SPA简介"><a href="#SPA简介" class="headerlink" title="SPA简介"></a>SPA简介</h5><p>其实SPA最主要的特点就是在前后端分离的基础上加了一层前端路由<br>也就是前端来维护一套路由规则</p>
<p><font color="blue"><strong>整个网站只有一个html页面</strong></font></p>
<p>​        浏览器将url发送到静态资源服务器（之前内部存储的是不同页面有对应的一套html+css+js<strong>现在只有一个html一个css和一个js</strong>），浏览器从静态服务器拿到<strong>全部的html+css+js资源</strong>，当用户点击时，url发生改变，但是页面不会跳转而是会向<strong>前端路由</strong>中查找url对应的组件将页面进行更改渲染。</p>
<p>此时前端路由就是该功能的支撑：<font color="red">前端路由会映射url与其对应组件的关系。</font></p>
<p><a href="https://imgchr.com/i/s9iVPI"><img src="https://s3.ax1x.com/2021/01/03/s9iVPI.png" alt="s9iVPI.png"></a></p>
<p><font color="deeppink"><strong>改变url不会刷新页面向服务器发送请求的几种方式：</strong></font></p>
<ul>
<li>改变location.hash</li>
<li>h5中提出的history.pushState({},’’,’url’)    将这些url压入到栈中(浏览器历史记录)    使用history.back()会回退一次历史记录    使用history.forward()会前进一次历史记录</li>
<li>history.replaceState({},’’,’url’)   这种方式是直接替换url不会保存浏览历史记录</li>
<li>history.go(num)配合history.pushState使用，传入的数字为负数是回退的记录个数，正数是前进几个记录</li>
</ul>
<h2 id="2-vue-router"><a href="#2-vue-router" class="headerlink" title="2. vue-router"></a>2. vue-router</h2><h3 id="2-1-基本使用"><a href="#2-1-基本使用" class="headerlink" title="2.1 基本使用"></a>2.1 基本使用</h3><p>第一步：安装</p>
<p>npm install vue-router –save（在使用脚手架创建项目时选用过，就不用再安装了）</p>
<p>第二步：在模块化工程中使用它（）</p>
<ol>
<li>通过Vue.use(插件)，安装插件</li>
<li>创建VueRouter对象，在该对象中使用其routes属性设置路由的映射关系（他是一个数组，内部存入一个一个对象）使用path属性设置对应的组件路径，使用component属性设置对应的组件名称</li>
<li>将router对象挂载在Vue实例中</li>
<li>使用路由: 通过&lt;router-link&gt;（显示标签，to属性表示要显示的组件）和&lt;router-view&gt;（占位符）</li>
<li>修改路由的默认值（使用redirect重定向）和history模式（默认是改变hash）（在路由的配置中设置mode: “history”）</li>
<li><ol>
<li> router-link的tag属性改变该标签的渲染模式（默认是a标签）</li>
<li> replace属性,将其设置为replace(即没有历史记录)</li>
<li> 当router-link处于活跃的状态(被点击后)则该标签会被加上两个class属性即router-link-exact-active和router-link-active。改变router-link-active的写法就使用active-class属性改为自己想要的值。或者在路由的配置文件中设置linkActiveClass: ‘active’统一设置所有的router-link-active的写法</li>
</ol>
</li>
<li>不使用router-link使用html标签来实现对应的功能：使用this.$router.push或this.$router.replace实现点击后的页面变化功能。<br>注意此时会出现连续点击报错问题，此时就添加一层判断即可。</li>
</ol>
<ul>
<li>在index.js文件中注册并配置路由：</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../components/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../components/About.vue&#x27;</span></span><br><span class="line"><span class="comment">// 1.通过Vue.use(插件),安装插件</span></span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="comment">// 2.创建VueRouter对象，并配置路由</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    <span class="comment">// redirect重定向</span></span><br><span class="line">    redirect: <span class="string">&#x27;/home&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About</span><br><span class="line">  &#125;</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 配置路由和组件之间的应用关系</span></span><br><span class="line">  routes,</span><br><span class="line">  <span class="comment">// 使用history模式</span></span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  <span class="comment">// 使用linkActiveClas统一设置所有的router-link-active的写法</span></span><br><span class="line">  linkActiveClass: <span class="string">&#x27;active&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3.将router对象传入Vue实例中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<ul>
<li>在App.vue文件中使用：</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用tag将渲染模式变为button --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用active-class修改router-link-active的写法 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">active-class</span>=<span class="string">&quot;active&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 使用html标签代替router-link写法 --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;homeClick&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;aboutClick&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 使用this.$router.push或this.$router.replace实现</span></span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">homeClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(&#x27;111&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&#x27;/home&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.replace(&#x27;/home&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// 处理连续点击报错问题</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(<span class="built_in">this</span>.$route.path !== <span class="string">&#x27;/home/news&#x27;</span>)&#123;   </span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/home/news&#x27;</span>)  </span></span><br><span class="line">      &#125; </span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">aboutClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(&#x27;222&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.push(&#x27;/about&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$router.replace(&#x27;/about&#x27;)</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">if</span>(<span class="built_in">this</span>.$route.path !== <span class="string">&#x27;/about&#x27;</span>)&#123;   </span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/about&#x27;</span>)  </span></span><br><span class="line">      &#125; </span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="2-2-动态路由"><a href="#2-2-动态路由" class="headerlink" title="2.2 动态路由"></a>2.2 动态路由</h3><p>案例进入到用户界面后再url后加上用户对应的信息。</p>
<p>实现：首先在user组件中设置对应界面，然后在路由配置中添加该页面的配置，其中path属性值设置为“/user/:abc”其中:abc表示要动态显示的路径。然后在App.vue中设置router-link，将to属性动态绑定为：”‘/user/‘+userId”（<strong>此时就把userId这个数据携带着传递到了user组件中</strong>（$route.params.abc））。当要在user组件显示App.vue中的数据时使用$route.params.abc这里的abc与配置路由时的abc是对应的。</p>
<p>$route.params是一个 key/value 对象，包含了动态片段和全匹配片段，如果没有路由参数，就是一个空对象。<br>在这里打印$route.params的结果是{abc: “zhangsan”}。</p>
<p>注意：$router与$route</p>
<ul>
<li><p><strong>this.$router</strong></p>
<p>表示router 实例。</p>
</li>
<li><p><strong>this.$route</strong></p>
<p>当前激活的路由信息对象。这个属性是只读的，里面的属性是 immutable (不可变) 的，不过你可以 watch (监测变化) 它。</p>
</li>
</ul>
<p>路由配置：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> VueRouter <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Router <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Home <span class="keyword">from</span> <span class="string">&#x27;../components/Home.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> About <span class="keyword">from</span> <span class="string">&#x27;../components/About.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> User <span class="keyword">from</span> <span class="string">&#x27;../components/User.vue&#x27;</span></span><br><span class="line"><span class="comment">// 1.通过Vue.use(插件),安装插件，此时原码会指向Router.install去安装该插件</span></span><br><span class="line">Vue.use(Router)</span><br><span class="line"><span class="comment">// 2.创建VueRouter对象</span></span><br><span class="line"><span class="keyword">const</span> routes = [</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;&#x27;</span>,</span><br><span class="line">    redirect: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    mode: <span class="string">&#x27;history&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/home&#x27;</span>,</span><br><span class="line">    component: Home</span><br><span class="line">  &#125;,</span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/about&#x27;</span>,</span><br><span class="line">    component: About</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 配置动态路由,此时就相当于在$route.params中添加了一个属性名为abc</span></span><br><span class="line">  &#123;</span><br><span class="line">    path: <span class="string">&#x27;/user/:abc&#x27;</span>,</span><br><span class="line">    component: User</span><br><span class="line">  &#125;,</span><br><span class="line">]</span><br><span class="line"><span class="keyword">const</span> router = <span class="keyword">new</span> VueRouter(&#123;</span><br><span class="line">  <span class="comment">// 配置路由和组件之间的应用关系</span></span><br><span class="line">  routes,</span><br><span class="line">  mode: <span class="string">&#x27;history&#x27;</span>,</span><br><span class="line">  linkActiveClass: <span class="string">&#x27;active&#x27;</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 3.将router对象传入Vue实例中</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> router</span><br></pre></td></tr></table></figure>
<p>App.vue：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/about&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span>&gt;</span>关于<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 此时就携带着userId这个数据传递给了$route.params.abc --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">:to</span>=<span class="string">&quot;&#x27;/user/&#x27;+userId&quot;</span> <span class="attr">tag</span>=<span class="string">&quot;button&quot;</span> &gt;</span>用户<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">      userId: <span class="string">&#x27;zhangsan&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;lisi&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">  <span class="selector-class">.active</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">color</span>: <span class="selector-id">#bfa</span>;</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>User.vue:</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h3</span>&gt;</span>我是用户界面<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是&#123;&#123;userName&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是&#123;&#123;$route.params.abc&#125;&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;test&quot;</span>&gt;</span>test<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&quot;User&quot;</span>,</span></span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">userName</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.$route.params.abc</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">test</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.params)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>  <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h3 id="2-3-路由懒加载"><a href="#2-3-路由懒加载" class="headerlink" title="2.3 路由懒加载"></a>2.3 路由懒加载</h3><h4 id="2-3-1-使用懒加载的原因"><a href="#2-3-1-使用懒加载的原因" class="headerlink" title="2.3.1 使用懒加载的原因"></a>2.3.1 使用懒加载的原因</h4><ul>
<li><p>当打包构建应用时，Javascript 包会变得非常大，影响页面加载。</p>
</li>
<li><p>如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应组件，这样就更加高效了</p>
</li>
</ul>
<h4 id="2-3-2-路由懒加载都做了什么"><a href="#2-3-2-路由懒加载都做了什么" class="headerlink" title="2.3.2 路由懒加载都做了什么"></a>2.3.2 路由懒加载都做了什么</h4><ul>
<li><p>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块.</p>
</li>
<li><p>只有在这个路由被访问到的时候, 才加载对应的组件</p>
</li>
</ul>
<p>​        之前不进行路由懒加载时：在将项目进行打包后，js文件会有三个。其中包括<strong>appxxx.js</strong>（项目逻辑代码）、<strong>mainfestxxx.js（</strong>底层支撑，例如es6转es5，模块化转换等）和<strong>venderxxx.js</strong>（第三方相关，例如vue，vue-router）。<br>​        当项目开发时，<strong>appxxx.js</strong>（项目逻辑代码）这个文件中的代码会越来越大，当用户第一次访问时会一次性的将上述的三个文件请求到本地。此时会出现界面空白的现象，使得用户体验差。<br>此时就需要用到路由懒加载就会将每个路由都分别打包到不同的js文件中，当用户访问时，仅会将需要的对应文件请求到本地。</p>
<h4 id="2-3-3-路由懒加载使用"><a href="#2-3-3-路由懒加载使用" class="headerlink" title="2.3.3 路由懒加载使用"></a>2.3.3 路由懒加载使用</h4><ul>
<li><p>方式一: 结合Vue的异步组件和Webpack的代码分析<br>nconst Home = resolve =&gt; { require.ensure([‘../components/Home.vue’], () =&gt; { resolve(require(‘../components/Home.vue’)) })};</p>
</li>
<li><p>方式二: AMD写法<br>const About = resolve =&gt; require([‘../components/About.vue’], resolve);</p>
</li>
<li><p><font color="red"><strong>方式三</strong></font>: 在ES6中, 我们可以有更加简单的写法来组织Vue异步组件和Webpack的代码分割</p>
<p>const Home = () =&gt; import(‘../components/Home.vue’)</p>
</li>
</ul>
<h3 id="2-4-vue-router嵌套路由"><a href="#2-4-vue-router嵌套路由" class="headerlink" title="2.4. vue-router嵌套路由"></a>2.4. vue-router嵌套路由</h3><p>第一步：创建子组件，子组件正常编写。</p>
<p><a href="https://imgchr.com/i/s9iAIA"><img src="https://s3.ax1x.com/2021/01/03/s9iAIA.png" alt="s9iAIA.png"></a></p>
<p>第二步：在父组件中使用router-link标签将子组件挂载，并使用router-view标签处理显示位置。</p>
<p><a href="https://imgchr.com/i/s9VHr6"><img src="https://s3.ax1x.com/2021/01/03/s9VHr6.png" alt="s9VHr6.png"></a></p>
<p>第三步：在路由配置文件中使用children属性配置子路由。<br>        <font color="red">在这里注意写路径时前面不要加斜杠。</font></p>
<p><a href="https://imgchr.com/i/s9VbqK"><img src="https://s3.ax1x.com/2021/01/03/s9VbqK.png" alt="s9VbqK.png"></a></p>
<p>第四步：设置嵌套路由的默认选项。</p>
<p><a href="https://imgchr.com/i/s9VLVO"><img src="https://s3.ax1x.com/2021/01/03/s9VLVO.png" alt="s9VLVO.png"></a></p>
<h3 id="2-5-vue-router参数传递"><a href="#2-5-vue-router参数传递" class="headerlink" title="2.5. vue-router参数传递"></a>2.5. vue-router参数传递</h3><h4 id="2-5-1-传递参数主要有两种方式"><a href="#2-5-1-传递参数主要有两种方式" class="headerlink" title="2.5.1 传递参数主要有两种方式"></a>2.5.1 传递参数主要有两种方式</h4><p>params(parameter参数)和query</p>
<ul>
<li>**params的类型:**（适用于数据少的时候）<br>配置路由格式: /router/:id<br>传递的方式: 在path后面跟上对应的值<br>传递后形成的路径: /router/123, /router/abc</li>
</ul>
<p><a href="https://imgchr.com/i/s9V7Kx"><img src="https://s3.ax1x.com/2021/01/03/s9V7Kx.png" alt="s9V7Kx.png"></a></p>
<ul>
<li>**query的类型:**（适用于数据多的时候）<br>配置路由格式: /router, 也就是普通配置<br>传递的方式: 对象中使用query的key作为传递方式<br>传递后形成的路径: /router?id=123, /router?id=abc</li>
</ul>
<p><a href="https://imgchr.com/i/s9Vox1"><img src="https://s3.ax1x.com/2021/01/03/s9Vox1.png" alt="s9Vox1.png"></a></p>
<p><font color="red">params与query的区别:</font><br>query要使用path来引入，params要使用name来引入，接受参数类似，分别是this.$route.query.name和this.$route.params.name</p>
<p><font color="red"><strong>URL的组成：协议(scheme)+服务器地址(host)+端口(默认是80不写)+路径(path)+?查询(query)+#片段hash值(fragment)</strong></font></p>
<p><a href="https://imgchr.com/i/s9ZBdO"><img src="https://s3.ax1x.com/2021/01/03/s9ZBdO.png" alt="s9ZBdO.png"></a></p>
<h5 id="传递参数的两种方式"><a href="#传递参数的两种方式" class="headerlink" title="传递参数的两种方式"></a><font color="cornflowerblue">传递参数的两种方式</font></h5><ul>
<li>方式一:  使用&lt;router-link&gt;</li>
</ul>
<p><a href="https://imgchr.com/i/s9Z6Wd"><img src="https://s3.ax1x.com/2021/01/03/s9Z6Wd.png" alt="s9Z6Wd.png"></a></p>
<ul>
<li>方式二:  <strong>使用JavaScript代码</strong>(不使用router-link使用button并监听点击)<br>注意这里也会出现连续点击报错问题，添加一层判断即可</li>
</ul>
<p><a href="https://imgchr.com/i/s9ZsFe"><img src="https://s3.ax1x.com/2021/01/03/s9ZsFe.png" alt="s9ZsFe.png"></a></p>
<h5 id="获取参数方式"><a href="#获取参数方式" class="headerlink" title="获取参数方式:"></a><font color="cornflowerblue">获取参数方式:</font></h5><ul>
<li>获取参数通过$route对象获取的.<ul>
<li>在使用了 vue-router 的应用中，路由对象会被注入每个组件中，赋值为 this.$route ，并且当路由切换时，路由对象会被更新</li>
</ul>
</li>
<li>通过$route获取传递的信息如下:</li>
</ul>
<p><a href="https://imgchr.com/i/s9ZDoD"><img src="https://s3.ax1x.com/2021/01/03/s9ZDoD.png" alt="s9ZDoD.png"></a></p>
<h4 id="2-5-2-route和-router的区别"><a href="#2-5-2-route和-router的区别" class="headerlink" title="2.5.2 $route和$router的区别"></a>2.5.2 $route和$router的区别</h4><ul>
<li><p>$router就是VueRouter实例。想要导航到不同URL，则使用$router.push方法</p>
</li>
<li><p>$route为配置的路由中，当前处于活跃的路由（router跳转的路由对象）。里面可以获取name、path、query、params等 </p>
</li>
</ul>
<p><a href="https://imgchr.com/i/s9ZyJH"><img src="https://s3.ax1x.com/2021/01/03/s9ZyJH.png" alt="s9ZyJH.png"></a></p>
<p><font color="red">$route和$router都是通过添加到vue的原型中的，所以所有vue的实例都可以访问到$route和$router。</font></p>
<h3 id="2-6-vue-router导航守卫"><a href="#2-6-vue-router导航守卫" class="headerlink" title="2.6. vue-router导航守卫"></a>2.6. vue-router导航守卫</h3><p><font color="deeppink"><strong>导航守卫用于在路由中来回跳转时调用的回调函数。</strong></font></p>
<h4 id="2-6-1-首先了解几个生命周期函数"><a href="#2-6-1-首先了解几个生命周期函数" class="headerlink" title="2.6.1 首先了解几个生命周期函数"></a><font color="red"><strong>2.6.1 首先了解几个生命周期函数</strong></font></h4><p>created回调函数：在组件被创建后会被调用<br>mounted回调函数：当组件中的模板被挂载到DOM中时被调用<br>updated回调函数：当界面发生更新时被调用<br>destroyed回调函数：当组件被销毁时被调用</p>
<h4 id="2-6-2-案例需求：当点击跳转到不同的界面时，页面的title会随之改变。"><a href="#2-6-2-案例需求：当点击跳转到不同的界面时，页面的title会随之改变。" class="headerlink" title="2.6.2 案例需求：当点击跳转到不同的界面时，页面的title会随之改变。"></a><strong>2.6.2 案例需求：当点击跳转到不同的界面时，页面的title会随之改变。</strong></h4><p>实现方案一：</p>
<p>利用生命周期的created回调函数实现。（document.title = ‘关于’）</p>
<p>问题：实现时要更改多个页面中的代码</p>
<p>实现方案二：</p>
<p>使用vue-router全局导航守卫<br>        router.beforeEach方法（被称为前置守卫即钩子<font color="red">在跳转前回调</font>），参数为一个函数，该函数中有三个参数，分别是to(route类型)、from(route类型)和next(函数类型)。使用该方法时内部必须调用next函数。不调用会导致点击后再也无法跳转。可以在路由中添加一个meta属性**<font color="cornflowerblue">meta表示元数据（描述数据的数据）</font>**，将数据保存在该对象中。</p>
<p><a href="https://imgchr.com/i/s9nPqx"><img src="https://s3.ax1x.com/2021/01/03/s9nPqx.png" alt="s9nPqx.png"></a></p>
<p><a href="https://imgchr.com/i/s9nCs1"><img src="https://s3.ax1x.com/2021/01/03/s9nCs1.png" alt="s9nCs1.png"></a></p>
<p><strong><font color="red">注意：to是一个对象，其中有一个matched数组，包含当前路由的所有嵌套路径片段的路由记录</font></strong></p>
<p><a href="https://imgchr.com/i/s9n0e0"><img src="https://s3.ax1x.com/2021/01/03/s9n0e0.png" alt="s9n0e0.png"></a></p>
<h4 id="2-6-3-导航守卫的补充"><a href="#2-6-3-导航守卫的补充" class="headerlink" title="2.6.3 导航守卫的补充"></a>2.6.3 导航守卫的补充</h4><ul>
<li>router.afterFach    <font color="red">在跳转后回调</font><br>需要传入一个函数，该函数有两个参数：to和from。因为他是在跳转后回调所以就没有next参数。</li>
</ul>
<p>router.beforeEach和router.afterFach被称为<font color="blue">全局守卫</font>，</p>
<ul>
<li><font color="deeppink"><strong>全局守卫</strong></font></li>
</ul>
<p><a href="https://imgchr.com/i/s9n9MR"><img src="https://s3.ax1x.com/2021/01/03/s9n9MR.png" alt="s9n9MR.png"></a></p>
<p><a href="https://imgchr.com/i/s9nSz9"><img src="https://s3.ax1x.com/2021/01/03/s9nSz9.png" alt="s9nSz9.png"></a></p>
<ul>
<li><font color="deeppink"><strong>组件内守卫</strong></font></li>
</ul>
<p><a href="https://imgchr.com/i/s9nyYF"><img src="https://s3.ax1x.com/2021/01/03/s9nyYF.png" alt="s9nyYF.png"></a></p>
<p><a href="https://imgchr.com/i/s9n6W4"><img src="https://s3.ax1x.com/2021/01/03/s9n6W4.png" alt="s9n6W4.png"></a></p>
<ul>
<li><font color="deeppink"><strong>路由独享守卫</strong></font></li>
</ul>
<p><a href="https://imgchr.com/i/s9ngSJ"><img src="https://s3.ax1x.com/2021/01/03/s9ngSJ.png" alt="s9ngSJ.png"></a></p>
<p><a href="https://router.vuejs.org/zh/guide/advanced/navigation-guards.html">路由守卫官方文档</a></p>
<p><a href="https://www.cnblogs.com/johnjackson/p/11044658.html">钩子与回调的区别</a></p>
<p>钩子函数在捕获消息的第一时间就执行，而回调函数是捕获结束时，最后一个被执行的。</p>
<h3 id="2-7-keep-alive"><a href="#2-7-keep-alive" class="headerlink" title="2.7. keep-alive"></a>2.7. keep-alive</h3><h4 id="2-7-1-首先理解Vue生命周期"><a href="#2-7-1-首先理解Vue生命周期" class="headerlink" title="2.7.1 首先理解Vue生命周期"></a><font color="red">2.7.1 首先理解Vue生命周期</font></h4><p><a href="https://www.cnblogs.com/caoyi/p/11356500.html">Vue生命周期详解</a></p>
<p><a href="https://imgchr.com/i/s9n2l9"><img src="https://s3.ax1x.com/2021/01/03/s9n2l9.png" alt="s9n2l9.png"></a></p>
<h4 id="2-7-2-案例需求："><a href="#2-7-2-案例需求：" class="headerlink" title="2.7.2 案例需求："></a>2.7.2 案例需求：</h4><p>当在主页中点击消息列表，当切换到其他路由后，再回到主页路由后将其保留之前显示的消息列表。</p>
<ul>
<li>原因：当切换路由会之前的组件会被销毁，所以在回到之前的路由时会重新创建一个新的组件。</li>
</ul>
<ul>
<li><font color="red">解决方案：使用keep-alive配合守卫</font><br>直接使用keep-alive无法完成是因为存在重定向。<pre><code>    首先在App.vue中使用keep-alive将router-view包裹，然后把路由配置中的默认路由删除，再配置Home.vue文件。其中在data中放入一个变量用来存储每次切换时首页的路径，然后使用beforeRouteLeave守卫回调更改切换前首页路径状态并更改data的值。当切换回首页时，由于首页依旧存活，可以使用activated（组件活跃回调）将路径改为data的值。</code></pre>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是首页,哈哈哈<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home/news&quot;</span>&gt;</span>新闻<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-link</span> <span class="attr">to</span>=<span class="string">&quot;/home/message&quot;</span>&gt;</span>消息<span class="tag">&lt;/<span class="name">router-link</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">router-view</span>&gt;</span><span class="tag">&lt;/<span class="name">router-view</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">    name: <span class="string">&quot;Vue&quot;</span>,</span></span><br><span class="line">    data ()&#123;</span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">        path: <span class="string">&#x27;/home/news&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="comment">// 使用created生命周期回调函数解决问题</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// created() &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   document.title = &#x27;首页&#x27;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;</span></span></span><br><span class="line">    /* created() &#123;</span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;home created&quot;</span>),</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.push(<span class="string">&#x27;/home/news&#x27;</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">destroyed</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">&quot;home destroyed&quot;</span>)</span></span><br><span class="line">    &#125; */</span><br><span class="line"><span class="javascript">    <span class="comment">// 当切换回首页时，由于首页依旧存活，可以使用activated（组件活跃回调）将路径改为data的值。</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">activated</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$router.push(<span class="built_in">this</span>.path)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    /* deactivated() &#123;</span><br><span class="line"><span class="javascript">      <span class="comment">// deactivated记录的是活跃的路由</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.path)</span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.path = this.$route.path</span></span></span><br><span class="line">    &#125;, */</span><br><span class="line"><span class="javascript">    <span class="comment">// 使用beforeRouteLeave守卫回调更改切换前首页路径状态并更改data的值</span></span></span><br><span class="line"><span class="javascript">    beforeRouteLeave (to, <span class="keyword">from</span>, next) &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$route.path)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.path = <span class="built_in">this</span>.$route.path</span></span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>  <span class="attr">scoped</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="2-7-3-keep-alive总结"><a href="#2-7-3-keep-alive总结" class="headerlink" title="2.7.3 keep-alive总结"></a>2.7.3 keep-alive总结</h4><p>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存：</p>
<p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。keep-alive会缓存，生命周期不会重新执行</p>
<p>它们有两个非常重要的属性:</p>
<ul>
<li><p>pinclude - 字符串或正则表达，只有匹配的组件会被缓存</p>
</li>
<li><p>pexclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</p>
</li>
</ul>
<p><strong>activated和deactivated</strong>这两个回调是<strong>只有在当组件在keep-alive中时（保持了状态）</strong>（否则执行的就是销毁回调了），当组件处于活跃中时调用前者，不活跃时调用后者。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>07_Vuex状态管理插件</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/07-Vuex%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%8F%92%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="一-认识Vuex"><a href="#一-认识Vuex" class="headerlink" title="一 认识Vuex"></a>一 认识Vuex</h3><h4 id="1-1-vuex是做什么的"><a href="#1-1-vuex是做什么的" class="headerlink" title="1.1 vuex是做什么的"></a>1.1 vuex是做什么的</h4><ul>
<li>官方解释：Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。<ul>
<li>它采用 集中式存储管理 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</li>
<li>Vuex 也集成到 Vue 的官方调试工具 <a href="https://github.com/vuejs/vue-devtools">devtools</a><a href="https://github.com/vuejs/vue-devtools"> extension</a>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</li>
</ul>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p><strong>状态管理</strong>到底是什么？</p>
<ul>
<li><strong>状态管理模式、集中式存储管理</strong>这些名词听起来就非常高大上，让人捉摸不透。</li>
<li>其实，你可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。</li>
<li>然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。</li>
<li>那么，多个组件是不是就可以共享这个对象中的所有变量属性了呢？</li>
</ul>
</li>
<li><p>等等，如果是这样的话，为什么官方还要专门出一个插件Vuex呢？难道我们不能自己封装一个对象来管理吗？</p>
<ul>
<li>当然可以，只是我们要先想想VueJS带给我们最大的便利是什么呢？没错，就是<font color="red"><strong>响应式</strong></font>。</li>
<li>如果你自己封装实现一个对象能不能保证它里面所有的属性做到响应式呢？当然也可以，只是自己封装可能稍微麻烦一些。</li>
<li>不用怀疑，Vuex就是为了提供这样一个在多个组件间共享状态的插件，用它就可以了。</li>
</ul>
</li>
</ul>
<h4 id="1-2-vuex管理什么状态呢"><a href="#1-2-vuex管理什么状态呢" class="headerlink" title="1.2 vuex管理什么状态呢"></a>1.2 vuex管理什么状态呢</h4><ul>
<li>但是，有什么状态时需要我们在多个组件间共享的呢？<ul>
<li>如果你做过大型开放，你一定遇到过多个状态，在多个界面间的共享问题。</li>
<li>比如用户的登录状态、用户名称、头像、地理位置信息等等。</li>
<li>比如商品的收藏、购物车中的物品等等。</li>
<li>这些状态信息，我们都可以放在统一的地方，对它进行保存和管理，而且它们还是响应式的（待会儿我们就可以看到代码了，莫着急）。</li>
</ul>
</li>
</ul>
<h4 id="1-3-单页面的状态管理"><a href="#1-3-单页面的状态管理" class="headerlink" title="1.3 单页面的状态管理"></a>1.3 单页面的状态管理</h4><ul>
<li>我们知道，要在单个组件中进行状态管理是一件非常简单的事情<ul>
<li>State：不用多说，就是我们的状态。（你姑且可以当做就是data中的属性）</li>
<li>View：视图层，可以针对State的变化，显示不同的信息。（这个好理解吧？）</li>
<li>Actions：这里的Actions主要是用户的各种操作：点击、输入等等，会导致状态的改变。</li>
</ul>
</li>
</ul>
<p><a href="https://imgchr.com/i/s9MAoV"><img src="https://s3.ax1x.com/2021/01/03/s9MAoV.png" alt="s9MAoV.png"></a></p>
<h4 id="1-4-全局单例模式（大管家）"><a href="#1-4-全局单例模式（大管家）" class="headerlink" title="1.4 全局单例模式（大管家）"></a>1.4 全局<font color="red">单例模式</font>（大管家）</h4><ul>
<li><p>我们现在要做的就是将共享的状态抽取出来，交给我们的大管家，统一进行管理。</p>
</li>
<li><p>之后，你们每个试图，按照我<font color="blue"><strong>规定好的</strong></font>规定，进行访问和修改等操作。</p>
</li>
<li><p>这就是Vuex背后的基本思想。</p>
</li>
</ul>
<h3 id="二-vuex的使用"><a href="#二-vuex的使用" class="headerlink" title="二 vuex的使用:"></a>二 vuex的使用:</h3><h4 id="2-1-配置vuex"><a href="#2-1-配置vuex" class="headerlink" title="2.1 配置vuex"></a>2.1 配置vuex</h4><ul>
<li><p><strong>首先安装vuex    npm install vuex –save</strong></p>
</li>
<li><p><strong>然后在src文件夹下创建一个store文件夹，在该文件夹下创建index.js配置vuex。</strong></p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> Vuex <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.安装插件</span></span><br><span class="line">Vue.use(Vuex)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 2.创建对象</span></span><br><span class="line"><span class="keyword">const</span> store = <span class="keyword">new</span> Vuex.Store(&#123;</span><br><span class="line">  state: &#123;		<span class="comment">// Vuex.Store内存储的状态(数据内容)</span></span><br><span class="line">    counter: <span class="number">100</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;		<span class="comment">// 定义操作state的方法,这些方法中都有默认的形参,传入的就是store对象的state对象</span></span><br><span class="line">    <span class="function"><span class="title">increment</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.counter++</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      state.counter--</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;		<span class="comment">//进行异步操作</span></span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;		<span class="comment">// 类似于计算属性</span></span><br><span class="line">    <span class="function"><span class="title">squareofCounter</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.counter * state.counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  modules: &#123;		<span class="comment">//划分模块</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.导出store对象</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> store</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>最后在main.js中导入并挂载在Vue实例中</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">    // 使用$store.state.属性名来访问state</span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.state.counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;add&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;sub&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    // getters的使用</span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.squareofCounter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hello-vuex</span>&gt;</span><span class="tag">&lt;/<span class="name">hello-vuex</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">import</span> HelloVuex <span class="keyword">from</span> <span class="string">&#x27;./components/HelloVuex&#x27;</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="javascript">  name: <span class="string">&#x27;App&#x27;</span>,</span></span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 使用$store.commit(&#x27;方法名&#x27;)来修改state</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;increment&#x27;</span>)</span></span><br><span class="line">    &#125;,</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">sub</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;decrement&#x27;</span>)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    HelloVuex</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="2-2-使用vuex"><a href="#2-2-使用vuex" class="headerlink" title="2.2 使用vuex"></a>2.2 使用vuex</h4><p>通过<font color="deeppink">$store.state.状态名</font>来使用store.state内部存储的数据。</p>
<p>但是注意需要更改store.state内部的状态时：不要直接通过<font color="deeppink">$store.state.状态名</font>这种方式更改。</p>
<p>原因：</p>
<p>​        流程步骤：首先State提供状态给组件，当需要修改State时，组件先发布一个Action，然后提交到Mutations。最后再将State进行修改。<br>​        由于只有通过Mutations修改的State，此时Devtools才会记录到修改State的信息，比如谁进行了修改、修改内容是什么。此时才会让后续出错时容易查找问题出在哪儿。因此不提倡绕过Mutations直接修改<font color="deeppink">$store.state.状态名</font>的方法进行修改状态。（此外绕过Actions直接进入Mutations修改也是可以的。但是Actions可以处理异步操作。）</p>
<p>​    使用$store.commit(‘方法名’)来修改state</p>
<p><a href="https://imgchr.com/i/s9KXIf"><img src="https://s3.ax1x.com/2021/01/03/s9KXIf.png" alt="s9KXIf.png"></a></p>
<h4 id="2-3-Vuex的核心概念"><a href="#2-3-Vuex的核心概念" class="headerlink" title="2.3 Vuex的核心概念"></a>2.3 Vuex的核心概念</h4><p>vuex的核心概念包括：</p>
<ul>
<li><p>State单一状态树(用于存储状态)</p>
<p>​        单一状态树（Single Source of Truth）也可翻译为单一数据源。这个意思就是在一个项目中，只需要创建一个store对象，所以需要管理的状态都放在该对象中，不要创建多余的store对象。这样在管理时只需要去找这一个store对象就能找到你需要的状态。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">state: &#123;</span><br><span class="line">  counter: <span class="number">100</span>,</span><br><span class="line">  students: [</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">110</span>, <span class="attr">name</span>: <span class="string">&#x27;why&#x27;</span>, <span class="attr">age</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">111</span>, <span class="attr">name</span>: <span class="string">&#x27;kobe&#x27;</span>, <span class="attr">age</span>: <span class="number">24</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">112</span>, <span class="attr">name</span>: <span class="string">&#x27;james&#x27;</span>, <span class="attr">age</span>: <span class="number">30</span>&#125;,</span><br><span class="line">    &#123;<span class="attr">id</span>: <span class="number">113</span>, <span class="attr">name</span>: <span class="string">&#x27;curry&#x27;</span>, <span class="attr">age</span>: <span class="number">10</span>&#125;</span><br><span class="line">  ],</span><br><span class="line">  info: &#123;</span><br><span class="line">  name: <span class="string">&#x27;kobe&#x27;</span>,</span><br><span class="line">    age: <span class="number">40</span>,</span><br><span class="line">  height: <span class="number">1.98</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


</li>
</ul>
<ul>
<li>Getters(类似于计算属性)</li>
</ul>
<p>getters作为参数和传递参数</p>
  <figure class="highlight js"><table><tr><td class="code"><pre><span class="line">getters: &#123;</span><br><span class="line">  <span class="comment">// 1. getters基本使用,默认会将state作为参数传递进去</span></span><br><span class="line">  <span class="function"><span class="title">squareofCounter</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.counter * state.counter</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">more20stu</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age &gt; <span class="number">20</span>)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 2. getters作为参数</span></span><br><span class="line">  <span class="function"><span class="title">more20stuLength</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> getters.more20stu.length</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 3.getters默认是不能传递参数的, 如果希望传递参数, 那么只能让getters本身返回另一个函数.</span></span><br><span class="line">  <span class="function"><span class="title">moreAgeStu</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// return function (age) &#123;</span></span><br><span class="line">    <span class="comment">//   return state.students.filter(s =&gt; s.age &gt; age)</span></span><br><span class="line">    <span class="comment">// &#125;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">age</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.students.filter(<span class="function"><span class="params">s</span> =&gt;</span> s.age &gt; age)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  使用时 :</p>
  <figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.squareofCounter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.more20stu&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.more20stuLength&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;$store.getters.moreAgeStu(12)&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br></pre></td></tr></table></figure>


<ul>
<li>Mutations</li>
</ul>
<ol>
<li>Vuex的store状态的<strong>更新唯一方式</strong>：<strong>提交Mutations</strong></li>
<li>Mutations主要包括两部分：</li>
</ol>
<p>字符串的<strong>事件类型（type）</strong>和一个<strong>回调函数（handler）</strong>,该回调函数的第一个参数就是state。</p>
<ol start="3">
<li>Mutations的参数<br>他传入参数与getters传参不同,他<strong>只能接收两个参数</strong>。他可以直接在第一个参数state后添加一个要传入的参数,第二个参数被称为payload(负载)。这个payload分两种情况（具体看第四点）</li>
<li>Mutations的提交风格</li>
</ol>
<ul>
<li><p>普通提交风格</p>
<p>例如：this.$store.commit(‘incrementCount’, count)</p>
<pre><code>    此时传入的只能有两个值,第一个是要提交给的Mutations的函数名,第二个是传入的参数,可以是基本数据类型或对象。此时Mutations接收的参数中的payload就代表第二个传入的数据。</code></pre>
</li>
<li><p>特殊的提交风格在</p>
<p>例如：</p>
<p>this.$store.commit({</p>
<pre><code>  type: &#39;incrementCount&#39;,
  a:a,
  b:b</code></pre>
<p>})        </p>
<p>​        使用$store.commit提交时传入一个对象,这个对象的第一个属性是type其属性值为要提交给的Mutations的函数名。后边的属性是接着要传入的参数。此时Mutations接收的参数中的payload就是一个对象,该对象中存储了commit后的这个对象的所有内容。</p>
</li>
</ul>
<ol start="5">
<li>Mutations响应规则</li>
</ol>
<p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新。这就要求我们必须遵守一些Vuex对应的规则:</p>
<p><strong><font color="deeppink">提前在store中初始化好所需的属性.</font></strong></p>
<p>当给state中的对象添加新属性时, 使用下面的方式:<br>方式一: 使用Vue.set(obj, ‘newProp’, 123)<br>方式二: 用新对象给旧对象重新赋值</p>
<p>当给state中的对象删除属性时, 使用下面的方式:<br>Vue.delete(state.info, ‘age’)</p>
<p><font color="red"><strong>总结</strong></font>：Vuex的store中的state中的数据在原本就有的时候，这些数据是响应式的（因为在初始化时vue就将这些原本就有的属性加入响应式系统,响应式系统会进行监听变化,当变化时会通知界面中有用到该属性的地方进行刷新,而后添加的属性却没有加入响应式系统），自己后来添加上去的属性要使用一些方式才能是响应式的。</p>
<ol start="6">
<li>Mutations的类型常量</li>
</ol>
<p>首先在src/store文件夹下创建mutations-types.js文件。在该文件中配置Mutations的类型常量。<br>例如：export const INCREMENT = ‘increment’</p>
<p>然后在src/store的index.js中使用increment函数是写成[INCREMENT ]的形式具体看代码。并在APP.vue中向该方法传递时使用this.$store.commit(INCREMENT)</p>
<p>为什么要这么使用?<br>因为如果在配置Mutations的类型常量时出错也没关系,因为两者用的都是相同的一个常量,因此就相当于两处用的虽然都是错的,但是都是相同的不会出问题。而且在定义常量后在使用常量时编辑器会有提示。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  INCREMENT</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./mutations-types&#x27;</span></span><br><span class="line"></span><br><span class="line">mutations: &#123;		<span class="comment">// 定义操作state的方法,这些方法中都有默认的形参,传入的就是store对象的state对象</span></span><br><span class="line">  <span class="comment">// 6.使用Mutations的类型常量</span></span><br><span class="line">  [INCREMENT](state) &#123;</span><br><span class="line">    state.counter++</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">decrement</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    state.counter--</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// 接收参数</span></span><br><span class="line">  <span class="function"><span class="title">incrementCount</span>(<span class="params">state, payload</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(state,payload);</span></span><br><span class="line">    state.counter += payload.count</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">addStudent</span>(<span class="params">state, stu</span>)</span> &#123;</span><br><span class="line">    state.students.push(stu)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="comment">// Mutations响应规则</span></span><br><span class="line">  <span class="function"><span class="title">updateInfo</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// state.info.name = &#x27;coderwhy&#x27;    // 响应式的</span></span><br><span class="line"></span><br><span class="line">    state.info[<span class="string">&#x27;address&#x27;</span>] = <span class="string">&#x27;洛杉矶&#x27;</span>    <span class="comment">// 非响应式的</span></span><br><span class="line">    <span class="comment">//Vue.set(state.info, &#x27;address&#x27;, &#x27;洛杉矶&#x27;)  // 响应式的</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// delete state.info.age   // 非响应式的</span></span><br><span class="line">    <span class="comment">// Vue.delete(state.info, &#x27;age&#x27;)   // 响应式的</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p>使用:</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;button @click=<span class="string">&quot;add&quot;</span>&gt;+&lt;/button&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;sub&quot;</span>&gt;-&lt;/button&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;addCount(5)&quot;</span>&gt;+<span class="number">5</span>&lt;/button&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;addCount(10)&quot;</span>&gt;+<span class="number">10</span>&lt;/button&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;addStudent&quot;</span>&gt;添加学生&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mutations响应规则</span></span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.state.info&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;updateInfo&quot;</span>&gt;修改信息&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  INCREMENT</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;./store/mutations-types&#x27;</span></span><br><span class="line"></span><br><span class="line">methods: &#123;</span><br><span class="line">  <span class="function"><span class="title">add</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 6.使用Mutations的类型常量</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(INCREMENT)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">sub</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// 使用$store.commit(&#x27;方法名&#x27;)来修改state</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;decrement&#x27;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">	<span class="function"><span class="title">addCount</span>(<span class="params">count</span>)</span> &#123;</span><br><span class="line">    <span class="comment">// payload: 负载</span></span><br><span class="line">    <span class="comment">// 1.普通的提交风格</span></span><br><span class="line">    <span class="comment">// this.$store.commit(&#x27;incrementCount&#x27;, count)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2.特殊的提交风格</span></span><br><span class="line">    <span class="built_in">this</span>.$store.commit(&#123;</span><br><span class="line">      type: <span class="string">&#x27;incrementCount&#x27;</span>,</span><br><span class="line">      count</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">addStudent</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> stu = &#123;<span class="attr">id</span>: <span class="number">114</span>, <span class="attr">name</span>: <span class="string">&#x27;alan&#x27;</span>, <span class="attr">age</span>: <span class="number">35</span>&#125;</span><br><span class="line">    <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;addStudent&#x27;</span>, stu)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="title">updateInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">    <span class="comment">// this.$store.commit(&#x27;updateInfo&#x27;)</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li><p>Action</p>
<p>​        时刻注意,不要在Mutations中进行异步操作。那样做虽然对数据存储和界面显示没有影响，但是这个时候vue的官方插件Devtools捕获不到这次操作，在Devtools界面中就会显示错误的信息。解决该问题的方法就是把异步操作放到Action中进行处理。（Action类似于Mutations, 但是是用来代替Mutations进行异步操作的.）</p>
<p>​        在使用时与Mutations类似，不同的是在Action中定义方法时他只能接收两个参数，第一个是context（context表示上下文,在这里就相当于store）第二个是payload。在使用时用$store.dispatch传入参数，他也是两个参数，第一个是要用于处理的Action中的方法名。第二个是携带的参数。</p>
</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用:</span></span><br><span class="line"><span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;aUpdateInfo&#x27;</span>,&#123;</span><br><span class="line">  message: <span class="string">&#x27;我是携带的信息&#x27;</span>,</span><br><span class="line">  success: <span class="function">() =&gt;</span> &#123;  <span class="comment">// 定义成功的回调</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">&#x27;里面已经完成了&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义:</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="comment">// context表示上下文,在这里就相当于store</span></span><br><span class="line">  <span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context,payload</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      context.commit(<span class="string">&#x27;updateInfo&#x27;</span>)</span><br><span class="line">      <span class="comment">// console.log(payload)</span></span><br><span class="line">      <span class="built_in">console</span>.log(payload.message)</span><br><span class="line">      payload.success()  <span class="comment">// 在commit调用成功的回调</span></span><br><span class="line">    &#125;, <span class="number">1000</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用promise</span></span><br><span class="line"><span class="comment">// 使用:</span></span><br><span class="line"><span class="function"><span class="title">updateInfo</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store</span><br><span class="line">    .dispatch(<span class="string">&#x27;aUpdateInfo&#x27;</span>,<span class="string">&#x27;我是携带的信息&#x27;</span>)</span><br><span class="line">    .then(<span class="function"><span class="params">res</span> =&gt;</span> &#123;		<span class="comment">//调用dispatch后因为对方return一个Promise实例,所以调用他的then方法及成功的回调函数</span></span><br><span class="line">    <span class="built_in">console</span>.log(res)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br><span class="line">  </span><br><span class="line"><span class="comment">//定义</span></span><br><span class="line">actions: &#123;</span><br><span class="line">  <span class="function"><span class="title">aUpdateInfo</span>(<span class="params">context,payload</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve,reject</span>)=&gt;</span>&#123;</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;updateInfo&#x27;</span>)</span><br><span class="line">        <span class="built_in">console</span>.log(payload)</span><br><span class="line">        resolve(<span class="string">&#x27;11111&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>


<ul>
<li>Module</li>
</ul>
<p>Module是模块的意思, 为什么在Vuex中我们要使用模块呢?</p>
<p>​        Vue使用单一状态树,那么也意味着很多状态都会交给Vuex来管理.当应用变得非常复杂时,store对象就有可能变得相当臃肿.<br>​        为了解决这个问题, Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutation、action、getters等</p>
<p>使用Module</p>
<ol>
<li>使用模块中的state<br>$store.state.模块名.属性名            例如:$store.state.a.name</li>
<li>使用模块中的mutations<br>例如:updatedName(state,payload) {state.name = payload},应参中的state仅仅表示模块中的state对象。payload表示传入的参数。在使用时是正常使用，他会在配置中循环遍历根和子模块中所有的mutations方法，只要是同名的都执行。</li>
<li>使用模块中的getters<br>和之前一样使用，但是要想访问根状态时就可在第三个参数传入rootState，这个参数就是根状态的state对象。</li>
<li>使用模块中的actions<br>此时这里面参数中的<font color="red">context</font>表示自己所处的模块，不在代表根状态整体store。并且内部还存储了一些根状态的信息。<font color="red"><strong>具体如下</strong></font>：</li>
</ol>
<p><a href="https://imgchr.com/i/s9KOdP"><img src="https://s3.ax1x.com/2021/01/03/s9KOdP.png" alt="s9KOdP.png"></a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 示例</span></span><br><span class="line">modules: &#123;</span><br><span class="line">  a: &#123;</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    getters: &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  b: &#123;</span><br><span class="line">    state: &#123;&#125;,</span><br><span class="line">    mutations: &#123;&#125;,</span><br><span class="line">    actions: &#123;&#125;,</span><br><span class="line">    getters: &#123;&#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 细节</span></span><br><span class="line"><span class="comment">// 使用</span></span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.state.a.name&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;updatedName&quot;</span>&gt;修改&lt;/button&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.fullname&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.fullname2&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;h2&gt;&#123;&#123;$store.getters.fullname3&#125;&#125;&lt;/h2&gt;</span><br><span class="line">&lt;button @click=<span class="string">&quot;asyncupdatedName&quot;</span>&gt;异步修改&lt;/button&gt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">updatedName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store.commit(<span class="string">&#x27;updatedName&#x27;</span>,<span class="string">&quot;lisi&quot;</span>)</span><br><span class="line">&#125;,</span><br><span class="line"><span class="function"><span class="title">asyncupdatedName</span>(<span class="params"></span>)</span> &#123;</span><br><span class="line">  <span class="built_in">this</span>.$store.dispatch(<span class="string">&#x27;aUpdateName&#x27;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义</span></span><br><span class="line"><span class="keyword">const</span> moduleA = &#123;</span><br><span class="line">  state: &#123;</span><br><span class="line">    name: <span class="string">&#x27;zhangsan&#x27;</span></span><br><span class="line">  &#125;,</span><br><span class="line">  mutations: &#123;</span><br><span class="line">    <span class="function"><span class="title">updatedName</span>(<span class="params">state,payload</span>)</span> &#123;</span><br><span class="line">      state.name = payload</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  getters: &#123;</span><br><span class="line">    <span class="function"><span class="title">fullname</span>(<span class="params">state</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> state.name + <span class="string">&#x27;11111&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullname2</span>(<span class="params">state, getters</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullname + <span class="string">&#x27;2222&#x27;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="function"><span class="title">fullname3</span>(<span class="params">state, getters, rootState</span>)</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> getters.fullname2 + rootState.counter</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  actions: &#123;</span><br><span class="line">    <span class="function"><span class="title">aUpdateName</span>(<span class="params">context</span>)</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(context)</span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        context.commit(<span class="string">&#x27;updatedName&#x27;</span>,<span class="string">&#x27;wangwu&#x27;</span>)</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">modules: &#123;</span><br><span class="line">  a: moduleA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<ul>
<li>项目结构组织</li>
</ul>
<p><a href="https://imgchr.com/i/s9Mkd0"><img src="https://s3.ax1x.com/2021/01/03/s9Mkd0.png" alt="s9Mkd0.png"></a></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>03_Vue的API</title>
    <url>/Vue/%E7%AC%94%E8%AE%B0/vue/03-Vue%E7%9A%84API/</url>
    <content><![CDATA[<h1 id="Vue的基础操作"><a href="#Vue的基础操作" class="headerlink" title="Vue的基础操作"></a>Vue的基础操作</h1><h2 id="插值的操作（Mustache语法）"><a href="#插值的操作（Mustache语法）" class="headerlink" title="插值的操作（Mustache语法）"></a>插值的操作（Mustache语法）</h2><h3 id="将数据显示在标签内容中"><a href="#将数据显示在标签内容中" class="headerlink" title="将数据显示在标签内容中"></a>将数据显示在标签内容中</h3><p>v-once数据不会变化</p>
<p>v-for=“item in movies”（item为双大括号的绑定数据movies为vue中的数组,表示item会循环遍历该数组呈现该数组中的数据）</p>
<a id="more"></a>

<p>v-on:click = “函数名或执行代码”    <font color="Cyan"><strong>语法糖：@click</strong></font> = “函数名或执行代码”（绑定事件及其回调函数）</p>
<p>v-html=”变量名”（该指令表示传入的(变量名)数据是html的格式,在解析时会将其解析为html）</p>
<p>v-cloak 将这个指令添加在vue管理DOM区域的便签属性上，再在css中添加[v-cloak]{display: none; }。就会使得在页面没有解析到vue代码时，会隐藏Mustache语法。给用户更好的体验。</p>
<p>v-pre（该指令表示不解析Mustache语法就将双大括号展示在界面）</p>
<p>v-text=”变量名”（该指令与Mustache类似但是该指令会覆盖这个便签中的内容，使用起来不灵活）</p>
<h2 id="动态绑定属性（v-bind）"><a href="#动态绑定属性（v-bind）" class="headerlink" title="动态绑定属性（v-bind）"></a>动态绑定属性（v-bind）</h2><h3 id="将数据绑定基本属性"><a href="#将数据绑定基本属性" class="headerlink" title="将数据绑定基本属性"></a>将数据绑定基本属性</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>当需要给一个标签的一个属性绑定一个vue数据时，在该属性前写入v-bind：将属性值写成“vue数据的属性名”即可</p>
<p><font color="Cyan"><strong>语法糖：将v-bind：仅写一个：即可</strong></font></p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">:src</span>=<span class="string">&quot;imgurl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">img</span> <span class="attr">v-bind:src</span>=<span class="string">&quot;imgurl&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span><br><span class="line">   el: <span class="string">&#x27;#app&#x27;</span>,</span><br><span class="line">   data: &#123;</span><br><span class="line">    message: <span class="string">&#x27;你好&#x27;</span>,</span><br><span class="line">    imgurl:<span class="string">&#x27;http://pic1.win4000.com/wallpaper/2018-05-21/5b0287e6cd57e.jpg&#x27;</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="动态绑定class属性"><a href="#动态绑定class属性" class="headerlink" title="动态绑定class属性"></a>动态绑定class属性</h3><h4 id="1-对象语法"><a href="#1-对象语法" class="headerlink" title="1_对象语法"></a><font color="blue">1_对象语法</font></h4><p>当一些类名有去除与添加的需求时就可使用v-bind，使用时class的值传入一个字符串(或一个函数的调用)，该字符串中为一个对象，对象中保存的属性名是类名，属性值是一个布尔值，当布尔值为true时对应的类名会添加到该标签上，反正则不添加。并且他会与不使用v-bind的类名结合，而不是互相覆盖。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;&#123;active:isActive,line:isLine&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;getClasses()&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">      el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">      data: &#123;</span><br><span class="line"><span class="javascript">        message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        isActive:<span class="literal">true</span>,</span></span><br><span class="line"><span class="javascript">        isLine:<span class="literal">true</span></span></span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line"><span class="javascript">        btnClick:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.isActive = !<span class="built_in">this</span>.isActive</span></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        getClasses:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          reurn &#123;<span class="attr">active</span>:<span class="built_in">this</span>.isActive,<span class="attr">line</span>:<span class="built_in">this</span>.isLine&#125;</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="2-数组语法"><a href="#2-数组语法" class="headerlink" title="2_数组语法"></a>2_数组语法</h4><p>与对象语法类似他一样可以传入数组或方法调用效果如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;[&#x27;active&#x27;,&#x27;line&#x27;]&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>  </span><br><span class="line">    <span class="comment">&lt;!-- class为：&quot;title active line&quot; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;[active,line]&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>   </span><br><span class="line">    <span class="comment">&lt;!-- class为：&quot;title aaaa bbbbb&quot; --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">class</span>=<span class="string">&quot;title&quot;</span> <span class="attr">:class</span>=<span class="string">&quot;getClasses()&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span>    </span><br><span class="line">    <span class="comment">&lt;!-- class为：&quot;title aaaa bbbbb&quot; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      active:<span class="string">&#x27;aaaa&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      line:<span class="string">&#x27;bbbbb&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getClasses:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> [<span class="built_in">this</span>.active,<span class="built_in">this</span>.line]</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="动态绑定style属性"><a href="#动态绑定style属性" class="headerlink" title="动态绑定style属性"></a>动态绑定style属性</h3><h4 id="1-对象绑定"><a href="#1-对象绑定" class="headerlink" title="1_对象绑定"></a><font color="blue">1_对象绑定</font></h4><p>为了将页面成模块化(提高复用)，就使得某些样式需要定制，将这些需要定制的样式写成可改变的就可使用v-bind。使用时style的值传入一个字符串(或一个函数的调用)，该字符串中为一个对象，对象中保存的属性名是css样式名，属性值是样式值(加引号)或变量(不加引号)。<font color="deeppink"><strong>属性值不加引号vue会将其当做变量去data对象中寻找。不加引号就相当于正常的css属性值</strong></font>为了使标签内部简化，可向style属性值中传入一个函数的调用(该函数返回的就是上述的对象)。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize:finalSize + &#x27;px&#x27;,backgroundColor:finalColor&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;getStyles()&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message:<span class="string">&#x27;nihao&#x27;</span>,</span></span><br><span class="line">      finalSize: 40,</span><br><span class="line"><span class="javascript">      finalColor: <span class="string">&#x27;#bfa&#x27;</span>,</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getStyles:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;<span class="attr">fontSize</span>:<span class="built_in">this</span>.finalSize + <span class="string">&#x27;px&#x27;</span>,<span class="attr">backgroundColor</span>:<span class="built_in">this</span>.finalColor&#125;</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="2-数组绑定"><a href="#2-数组绑定" class="headerlink" title="2_数组绑定"></a>2_数组绑定</h4><p>与对象绑定类似，style传入的值还可是数组。（极少使用）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;&#123;fontSize:&#x27;50px&#x27;,backgroundColor:&#x27;#bfa&#x27;&#125;&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">:style</span>=<span class="string">&quot;[baseStyle1,baseStyle2]&quot;</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message:<span class="string">&#x27;nihao&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      baseStyle1: &#123;<span class="attr">fontSize</span>: <span class="string">&#x27;50px&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">      baseStyle2: &#123;<span class="attr">backgroundColor</span>: <span class="string">&#x27;#bfa&#x27;</span>&#125;,</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="计算属性（computed）"><a href="#计算属性（computed）" class="headerlink" title="计算属性（computed）"></a>计算属性（computed）</h2><h3 id="基本使用-1"><a href="#基本使用-1" class="headerlink" title="基本使用"></a>基本使用</h3><p>为了在html中简化表示一些数据的结合，就可以使用计算属性（computed）。下边三种表示全名的结果相同（第三种为计算属性）</p>
<p><font color="red"><strong>计算属性（computed）与methods的区别：</strong></font></p>
<ul>
<li><strong>计算属性在多次调用时只计算一次(缓存)，但是methods却是调用几次计算几次。</strong></li>
<li><strong>计算属性调用时不用加小括号(因为他的简写,此时他是一个属性不是函数)，但是methods的函数需要加括号</strong></li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName:<span class="string">&#x27;lebron&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      lastName:<span class="string">&#x27;james&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line"><span class="javascript">      fullName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getFullName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="复杂操作"><a href="#复杂操作" class="headerlink" title="复杂操作"></a>复杂操作</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>总价格：&#123;&#123;totalPrice&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      books:[</span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">110</span>,<span class="attr">name</span>:<span class="string">&#x27;Unix编程艺术&#x27;</span>,<span class="attr">price</span>:<span class="number">58</span>&#125;,</span></span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">111</span>,<span class="attr">name</span>:<span class="string">&#x27;代码大全&#x27;</span>,<span class="attr">price</span>:<span class="number">69</span>&#125;,</span></span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">112</span>,<span class="attr">name</span>:<span class="string">&#x27;深入理解计算机原理&#x27;</span>,<span class="attr">price</span>:<span class="number">85</span>&#125;,</span></span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">113</span>,<span class="attr">name</span>:<span class="string">&#x27;现代操作系统&#x27;</span>,<span class="attr">price</span>:<span class="number">98</span>&#125;,</span></span><br><span class="line"><span class="javascript">        &#123;<span class="attr">id</span>:<span class="number">114</span>,<span class="attr">name</span>:<span class="string">&#x27;犀牛书&#x27;</span>,<span class="attr">price</span>:<span class="number">129</span>&#125;,</span></span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      totalPrice:<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> result = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.books.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">          result += <span class="built_in">this</span>.books[i].price</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> result</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="计算属性的get-和set"><a href="#计算属性的get-和set" class="headerlink" title="计算属性的get(和set)"></a>计算属性的get(和set)</h3><p>计算属性的完整写法如下</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName:<span class="string">&#x27;kobe&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      lastName:<span class="string">&#x27;Bryant&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    /*</span><br><span class="line">    计算属性的完整写法如下</span><br><span class="line">    computed: &#123;</span><br><span class="line">      fullName:&#123;</span><br><span class="line"><span class="javascript">        set:<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span></span><br><span class="line"></span><br><span class="line">        &#125;,</span><br><span class="line"><span class="javascript">        get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    */</span><br><span class="line">    </span><br><span class="line">    /*</span><br><span class="line">    但是一般计算属性没有set方法(只读属性)，他只是计算出基本数据的结果返回，</span><br><span class="line">    不需要对其进行设置,因此简写之后就变成了如下所示：</span><br><span class="line">    */</span><br><span class="line">    computed: &#123;</span><br><span class="line">      </span><br><span class="line">      /*</span><br><span class="line">      fullName:&#123;</span><br><span class="line"><span class="javascript">        get:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      */</span><br><span class="line">      </span><br><span class="line"><span class="javascript">      <span class="comment">//最终简写成这样</span></span></span><br><span class="line"><span class="javascript">      fullName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>因为最终简写之后fullName是一个属性而不是一个方法，所以调用时不用加括号。</p>
<h3 id="计算属性computed与methods的对比"><a href="#计算属性computed与methods的对比" class="headerlink" title="计算属性computed与methods的对比"></a>计算属性computed与methods的对比</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1.直接拼接：语法过于繁琐 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;firstName&#125;&#125; &#123;&#123;lastName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 2.通过定义methods --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;getFullName()&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 3.使用computed --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;fullName&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      firstName:<span class="string">&#x27;kobe&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      lastName:<span class="string">&#x27;Bryant&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      getFullName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;getFullName()&#x27;</span>)		<span class="comment">//打印了4次</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    computed: &#123;</span><br><span class="line"><span class="javascript">      fullName:<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;fullName&#x27;</span>)		<span class="comment">//打印了1次</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="built_in">this</span>.firstName + <span class="string">&#x27; &#x27;</span> + <span class="built_in">this</span>.lastName</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>通过多次调用可以看出两者在重复使用时，computed利用了缓存只调用了一次(当内部内容改变时才会再次调用)，而methods是使用几次则调用几次。</p>
<h2 id="事件监听-v-on"><a href="#事件监听-v-on" class="headerlink" title="事件监听(v-on/@)"></a>事件监听(v-on/@)</h2><h3 id="v-on的参数问题"><a href="#v-on的参数问题" class="headerlink" title="v-on的参数问题"></a>v-on的参数问题</h3><ul>
<li><p>事件定义的方法没有形参时</p>
<p>此时在标签中调用函数加不加括号都可以</p>
</li>
<li><p>事件定义的方法有形参时</p>
<ul>
<li><font color="deeppink">当不带括号时候</font><ul>
<li><font color="red">此时vue会将event对象传入函数第一个参数</font></li>
</ul>
</li>
<li>当带括号不传入参数时<ul>
<li>此时函数中就接收不到任何参数，形参的值在初始化时都变成了undefined</li>
</ul>
</li>
<li>当带括号传入参数时<ul>
<li>正常传入参数时（传入参数个数与形参个数相同）<ul>
<li>当传入的参数为基本数据类型时，就以该数据传入函数</li>
<li>当传入的参数不是基本数据类型时，会去vue对象的data对象中寻找对应的变量传入函数<font color="red">（注意字符串要带引号否则就认为去data对象寻找）</font></li>
<li><font color="red">注意当需要向函数中传入event对象时，要写成**$event**。如果将传入的参数直接写成event时，vue会将其当做变量去data对象中寻找对应的变量。在里边找不到会报错，并将其赋值为undefined</font></li>
</ul>
</li>
<li>不正常传入参数时（传入参数个数与形参个数不匹配）<ul>
<li>与前者类似，只不过不够的会初始化时成为undefined，多的会没用</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 1.事件定义的方法没有参数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn1Click&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn1Click()&quot;</span>&gt;</span>按钮1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 2.在事件定义的方法有参数时 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click(123)&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click()&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn2Click&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 3.event对象 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(123,event)&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(123,$event)&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btn3Click(123,$event,13,16)&quot;</span>&gt;</span>按钮3<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      abc:123</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btn1Click</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;btn1Click()&#x27;</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btn2Click</span>(<span class="params">event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;btn2Click()&#x27;</span>,event)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btn3Click</span>(<span class="params">abc,event</span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;btn3Click()&#x27;</span>,abc,event)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="v-on的修饰符"><a href="#v-on的修饰符" class="headerlink" title="v-on的修饰符"></a>v-on的修饰符</h3><ul>
<li>.stop    禁止事件冒泡，相当于调用event.stopPropagation()</li>
<li>.prevent    禁止默认行为，相当于调用event.preventDefault()</li>
<li>.{keyCode|keyAlias}    只当事件是从特定按键触发时才会触发的回调。keyCode表示按键的编码(查表)，keyAlias表示按键的关键词</li>
<li>.once    只触发一次的回调</li>
<li>.native    监听组件根元素的原生事件</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- .stop的使用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> @<span class="attr">click</span>=<span class="string">&quot;divClick&quot;</span>&gt;</span></span><br><span class="line">    我是div</span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.stop</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- .prevent的使用 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;baidu&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;提交&quot;</span> @<span class="attr">click.prevent</span>=<span class="string">&quot;submitClick&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 监听某个按键 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> @<span class="attr">keyup.enter</span>=<span class="string">&quot;keyUp&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 监听一次的事件 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click.once</span>=<span class="string">&quot;btn2Click&quot;</span>&gt;</span>按钮2<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      abc:123</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;btnClick()&#x27;</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">divClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;divClick()&#x27;</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">submitClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;submitClick()&#x27;</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">keyUp</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;keyUp()&#x27;</span>)</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btn2Click</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;btn2Click()&#x27;</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="条件判断"><a href="#条件判断" class="headerlink" title="条件判断"></a>条件判断</h2><h3 id="v-if和v-else的使用"><a href="#v-if和v-else的使用" class="headerlink" title="v-if和v-else的使用"></a>v-if和v-else的使用</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-if</span>=<span class="string">&quot;isShow&quot;</span>&gt;</span></span><br><span class="line">    &#123;&#123;message&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>isShow为true时显示<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>isShow为false时显示<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message:<span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      isShow:<span class="literal">true</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="v-if、v-else-if和v-else的使用"><a href="#v-if、v-else-if和v-else的使用" class="headerlink" title="v-if、v-else-if和v-else的使用"></a>v-if、v-else-if和v-else的使用</h3><p>如果判断逻辑较多不建议使用，应该写成方法调用。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-if</span>=<span class="string">&quot;score&gt;=90&quot;</span>&gt;</span>优秀<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score&gt;=80&quot;</span>&gt;</span>良好<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else-if</span>=<span class="string">&quot;score&gt;=60&quot;</span>&gt;</span>及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span> <span class="attr">v-else</span>&gt;</span>不及格<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;&#123;result&#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      score:95</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">result</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> showMessage = <span class="string">&#x27;&#x27;</span>;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">if</span>(<span class="built_in">this</span>.score&gt;=<span class="number">90</span>)&#123;</span></span><br><span class="line"><span class="javascript">          showMessage = <span class="string">&#x27;优秀&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.score&gt;=<span class="number">80</span>)&#123;</span></span><br><span class="line"><span class="javascript">          showMessage = <span class="string">&#x27;良好&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">this</span>.score&gt;=<span class="number">60</span>)&#123;</span></span><br><span class="line"><span class="javascript">          showMessage = <span class="string">&#x27;及格&#x27;</span></span></span><br><span class="line"><span class="javascript">        &#125;<span class="keyword">else</span>&#123;</span></span><br><span class="line"><span class="javascript">          showMessage = <span class="string">&#x27;不及格&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> showMessage</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h4><p><font color="deeppink">在输入框中输入内容后，点击切换按钮，输入框中的内容不会清除。</font><br>原因：<br>因为vue在处理DOM元素时，是先将其存储在内存中的一个虚拟DOM中，在切换时vue会对比相同标签的key值如果两者相同则会在原来基础上进行修改(提高复用性,提高性能)，而不是创建一个新的DOM。如果两者key值不同，则会创建一个新的DOM去覆盖之前的DOM。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-if</span>=<span class="string">&#x27;isUser&#x27;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;username&quot;</span>&gt;</span>用户账号<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;username&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户账号&quot;</span> <span class="attr">key</span>=<span class="string">&quot;username&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">span</span> <span class="attr">v-else</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;email&quot;</span>&gt;</span>用户邮箱<span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">id</span>=<span class="string">&quot;email&quot;</span> <span class="attr">placeholder</span>=<span class="string">&quot;用户邮箱&quot;</span> <span class="attr">key</span>=<span class="string">&quot;email&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;isUser=!isUser&quot;</span>&gt;</span>切换类型<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      isUser: <span class="literal">true</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="v-show与v-if"><a href="#v-show与v-if" class="headerlink" title="v-show与v-if"></a>v-show与v-if</h3><p>v-if和v-show都可使一个DOM元素消失。<br>    v-if的消失是将该DOM元素从DOM树中删除。<br>    v-show的消失是给该DOM元素设置display为none，但该DOM元素依然在DOM树中。</p>
<p>两者的使用场景：<br>当显示与隐藏的切换频繁时使用v-show，当只有一次切换时使用v-if</p>
<h2 id="v-for遍历"><a href="#v-for遍历" class="headerlink" title="v-for遍历"></a>v-for遍历</h2><h3 id="遍历数组与对象"><a href="#遍历数组与对象" class="headerlink" title="遍历数组与对象"></a>遍历数组与对象</h3><ul>
<li>遍历数组<ul>
<li>仅使用一个值，则改值表示item</li>
<li>使用两个值，第一个表示item，第二个表示index</li>
</ul>
</li>
<li>遍历对象<ul>
<li>仅使用一个值，则改值表示value</li>
<li>使用两个值，第一个表示value，第二个表示key</li>
<li>使用三个值，第一个表示value，第二个表示key，第三个表示index</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app-Array&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in names&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in names&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;-&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app-Object&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;value in person&quot;</span>&gt;</span>&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key) in person&quot;</span>&gt;</span>&#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;(value,key,index) in person&quot;</span>&gt;</span>&#123;&#123;index&#125;&#125;-&#123;&#123;key&#125;&#125;-&#123;&#123;value&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app_Array = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app-Array&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      names:[<span class="string">&#x27;ysj&#x27;</span>,<span class="string">&#x27;lufei&#x27;</span>,<span class="string">&#x27;yingyan&#x27;</span>,<span class="string">&#x27;suolong&#x27;</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app_Object = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app-Object&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      person:&#123;</span><br><span class="line"><span class="javascript">        name:<span class="string">&#x27;ysj&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        age:<span class="string">&#x27;21&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        heght:<span class="string">&#x27;1.78&#x27;</span></span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="遍历注意事项使用key提高性能"><a href="#遍历注意事项使用key提高性能" class="headerlink" title="遍历注意事项使用key提高性能"></a>遍历注意事项使用key提高性能</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in letters&quot;</span> <span class="attr">:key</span>=<span class="string">&quot;item&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      letters:[<span class="string">&#x27;a&#x27;</span>,<span class="string">&#x27;b&#x27;</span>,<span class="string">&#x27;c&#x27;</span>,<span class="string">&#x27;d&#x27;</span>,<span class="string">&#x27;e&#x27;</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>例如：在这个示例中在letters数组中第二个位置插入一个元素f，此时vue的虚拟DOM中就会将原本第三个显示c的li变为显示f，第四个显示d的li变为显示c，以此类推然后最后再添加一个li的DOM元素显示e。这样做的性能及其低。<br>为了解决这一问题需要向li中添加一个key属性，并且要保证key值与其DOM元素的内容关联起来，因此写成：<font color="deeppink"><strong>:key=”item”</strong></font>这样此时再向数组中间插入一个f时，vue则会优先判断DOM元素中的key属性值是否与内容相关联（<font color="blue">调用diff算法</font>），相关联则保持原本不变，此时就会新创建一个li的DOM元素并写入f，然后插入到对应位置。此时的性能就比之前高很多。</p>
<h3 id="哪些数组的方法是响应式的"><a href="#哪些数组的方法是响应式的" class="headerlink" title="哪些数组的方法是响应式的"></a>哪些数组的方法是响应式的</h3><h4 id="响应式的："><a href="#响应式的：" class="headerlink" title="响应式的："></a><font color="deeppink"><strong>响应式的：</strong></font></h4><p>push()    在数组最后添加一个或多个元素<br>unshift()    在数组前面添加一个或多个元素<br>pop()    删除数组最后一个元素<br>shift()    删除数组第一个元素<br>sort()    排序<br>reverse()    反转数组<br>splice()    删除元素/插入元素/替换元素</p>
<h4 id="不是响应式的："><a href="#不是响应式的：" class="headerlink" title="不是响应式的："></a><font color="deeppink"><strong>不是响应式的：</strong></font></h4><p>使用数组下标值更改数组内容<br>例如：arr[0] = ‘aaaa’</p>
<p>替换为响应式的方法：</p>
<ul>
<li>arr.splice(0,1,’aaaa’)</li>
<li><font color="blue"><strong>Vue.set(arr,0,’aaaa’)</strong></font></li>
</ul>
<p><font color="blue"><strong>第二种方法为Vue内部的方法使用方式为：</strong></font></p>
<p>第一个参数表示要修改的对象，第二个为修改的索引值，第三个为修改后的值</p>
<h4 id="splice-使用方法："><a href="#splice-使用方法：" class="headerlink" title="splice()    使用方法："></a><font color="red"><strong>splice()    使用方法：</strong></font></h4><ul>
<li><p>参数：<br>第一个参数:    (start)操作数组开始的位置<br>第二个参数:    (delnum)删除元素个数,如果没有传入值则表示后边的全删,传入0表示不删<br>后续参数:    (item)表示从start位置插入的元素(可传入多个)</p>
</li>
<li><p>使用方法</p>
<p>删除元素就传入两个参数：第一个为删除起始位置，第二个为删除个数<br>插入元素就传入三个参数：第一个为起始位置，第二个为0，第三个为插入内容<br>替换元素就传入三个参数：第一个为起始位置，第二个为需要替换下来的元素个数（即把他们删除），第三个为插入内容</p>
</li>
</ul>
<h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>在vue对象中可以创建一个过滤器对象（filters），内部存入函数，这些函数是对数据进行过滤处理的。使用时在Mustache语法中的变量后添加<font color="deeppink"> | 过滤器函数名</font>即可。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">v-for</span>=<span class="string">&quot;(item,index) in books&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.id&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.name&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.date&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>&#123;&#123;item.price | showPrice&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>总价格：&#123;&#123;totalPrice | showPrice&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;./js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      books: [</span><br><span class="line">        &#123;</span><br><span class="line">          id: 1,</span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;《算法导论》&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          date: <span class="string">&#x27;2006-9&#x27;</span>,</span></span><br><span class="line">          price: 85.00,</span><br><span class="line">          count: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 2,</span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;《UNIX编程艺术》&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          date: <span class="string">&#x27;2006-2&#x27;</span>,</span></span><br><span class="line">          price: 59.00,</span><br><span class="line">          count: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 3,</span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;《编程珠玑》&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          date: <span class="string">&#x27;2008-10&#x27;</span>,</span></span><br><span class="line">          price: 39.00,</span><br><span class="line">          count: 1</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">          id: 4,</span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;《代码大全》&#x27;</span>,</span></span><br><span class="line"><span class="javascript">          date: <span class="string">&#x27;2006-3&#x27;</span>,</span></span><br><span class="line">          price: 128.00,</span><br><span class="line">          count: 1</span><br><span class="line">        &#125;,</span><br><span class="line">      ]</span><br><span class="line">    &#125;,</span><br><span class="line">    computed:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">totalPrice</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">let</span> totalPrice = <span class="number">0</span></span></span><br><span class="line"><span class="javascript">        <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">this</span>.books.length; i++) &#123;</span></span><br><span class="line"><span class="javascript">          totalPrice += <span class="built_in">this</span>.books[i].price * <span class="built_in">this</span>.books[i].count</span></span><br><span class="line">        &#125;</span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> totalPrice</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    filters:&#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">showPrice</span>(<span class="params">price</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> <span class="string">&#x27;￥&#x27;</span> + price.toFixed(<span class="number">2</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="v-model-表单-textarea-数据的双向绑定"><a href="#v-model-表单-textarea-数据的双向绑定" class="headerlink" title="v-model:表单(textarea)数据的双向绑定"></a>v-model:表单(textarea)数据的双向绑定</h2><h3 id="基本使用及其原理"><a href="#基本使用及其原理" class="headerlink" title="基本使用及其原理"></a>基本使用及其原理</h3><p>v-model其实是一个语法糖，他背后的本质是包含两个操作</p>
<ul>
<li>v-bind绑定一个value属性（使vue对象中的数据绑定到BOM中）</li>
<li>v-on指令给当前元素绑定input事件（使页面中数据改变会同步到vue对象的数据中）</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;message&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;valueChange&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;message&quot;</span> @<span class="attr">input</span>=<span class="string">&quot;message = $event.target.value&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  &#123;&#123;message&#125;&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      valueChange:<span class="function"><span class="keyword">function</span> (<span class="params">e</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.message = e.target.value</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="v-model结合radio使用"><a href="#v-model结合radio使用" class="headerlink" title="v-model结合radio使用"></a>v-model结合radio使用</h3><p>注意点：</p>
<ul>
<li>radio单选框要实现单选需要绑定相同的name属性值，但是如果都使用的相同的v-model属性值则name属性可以省略。</li>
<li>默认值：当时使用v-model时，将其进行初始化，此时就会默认选中初始化的值。</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;male&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;male&quot;</span> <span class="attr">value</span>=<span class="string">&quot;男&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;sex&#x27;</span>&gt;</span>男</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;female&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">id</span>=<span class="string">&quot;female&quot;</span> <span class="attr">value</span>=<span class="string">&quot;女&quot;</span> <span class="attr">v-model</span>=<span class="string">&#x27;sex&#x27;</span>&gt;</span>女</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您选择的性别是：&#123;&#123;sex&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      sex:<span class="string">&#x27;男&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="v-model结合checkbox使用"><a href="#v-model结合checkbox使用" class="headerlink" title="v-model结合checkbox使用"></a>v-model结合checkbox使用</h3><ul>
<li><p>单选（仅有一个checkbox）例如同意协议<br>对应一个Boolean值</p>
</li>
<li><p>多选（有多个checkbox）<br>对应一个数组</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 单选 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">&quot;agree&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">id</span>=<span class="string">&quot;agree&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;isAgree&quot;</span>&gt;</span>同意协议</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的选择是：&#123;&#123;isAgree&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">:disabled</span>=<span class="string">&quot;!isAgree&quot;</span>&gt;</span>下一步<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">&lt;!-- 多选 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;篮球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>篮球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;羽毛球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>羽毛球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;乒乓球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>乒乓球</span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">value</span>=<span class="string">&quot;足球&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;hobbies&quot;</span>&gt;</span>足球</span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的爱好是:&#123;&#123;hobbies&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      isAgree: <span class="literal">false</span>,</span></span><br><span class="line">      hobbies:[]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="值绑定"><a href="#值绑定" class="headerlink" title="值绑定"></a>值绑定</h4><p>将数据并不是写死到DOM元素中，而是通过vue的数据来显示在页面中。（使用v-for遍历）</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">label</span> <span class="attr">v-for</span>=<span class="string">&quot;item in originFruits&quot;</span> <span class="attr">:for</span>=<span class="string">&quot;item&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">:value</span>=<span class="string">&quot;item&quot;</span> <span class="attr">:id</span>=<span class="string">&quot;item&quot;</span> <span class="attr">v-model</span>=<span class="string">&quot;fruits&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的选择的水果是：&#123;&#123;fruits&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line">      fruits:[],</span><br><span class="line"><span class="javascript">      originFruits:[<span class="string">&#x27;苹果&#x27;</span>,<span class="string">&#x27;香蕉&#x27;</span>,<span class="string">&#x27;梨&#x27;</span>,<span class="string">&#x27;榴莲&#x27;</span>,<span class="string">&#x27;葡萄&#x27;</span>,<span class="string">&#x27;菠萝&#x27;</span>,<span class="string">&#x27;哈密瓜&#x27;</span>]</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h3 id="v-model结合select使用"><a href="#v-model结合select使用" class="headerlink" title="v-model结合select使用"></a>v-model结合select使用</h3><p>v-model绑定在select标签上而不是option标签</p>
<ul>
<li><p>选择一个<br>对应一个数据（当给该数据初始化赋值后,会默认选中该选项）</p>
</li>
<li><p>选择多个<br>要想选中多个需要在select标签上添加multiple属性，此时用户需要多选时按住Ctrl点击即可多选。<br>对应一个数组</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 单选 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;fruit&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香蕉&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;梨&quot;</span>&gt;</span>梨<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;葡萄&quot;</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的选择的水果是：&#123;&#123;fruit&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 多选 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">select</span> <span class="attr">v-model</span>=<span class="string">&quot;fruits&quot;</span> <span class="attr">multiple</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;苹果&quot;</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;香蕉&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;梨&quot;</span>&gt;</span>梨<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">&quot;葡萄&quot;</span>&gt;</span>葡萄<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您的选择的水果是：&#123;&#123;fruits&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      fruit: <span class="string">&#x27;香蕉&#x27;</span>,</span></span><br><span class="line">      fruits:[]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="v-model修饰符的使用"><a href="#v-model修饰符的使用" class="headerlink" title="v-model修饰符的使用"></a>v-model修饰符的使用</h3><ul>
<li>lazy<ul>
<li>默认情况下，数据的双向绑定是实时的</li>
<li>即在input中只要输入的内容发生改变，数据就会频繁的与vue中的存储数据进行对应变化</li>
<li>lazy修饰符可以使用户在输入框中点击回车，或输入框失去焦点时才进行数据更新。</li>
</ul>
</li>
<li>number<ul>
<li>默认情况下，在输入框无论我们输入的是数字韩式字母，v-model在传输时都会将其转化为string处理</li>
<li>但是当我们希望处理的是数字类型，可以使用number修饰符。此时会将输入框的内容自动转换成数字类型。</li>
</ul>
</li>
<li>trim<ul>
<li>如果输入的内容首尾有很多空格，通常我们希望将其去除</li>
<li>trim修饰符就可将输入框中的左右两边空格去除后再存入vue的数据中。</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.lazy</span>=<span class="string">&quot;message&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;message&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;number&quot;</span> <span class="attr">v-model.number</span>=<span class="string">&quot;age&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;age&#125;&#125;_&#123;&#123;typeof age&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">v-model.trim</span>=<span class="string">&quot;name&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>您输入的名字:&#123;&#123;name&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line">      age: 18,</span><br><span class="line"><span class="javascript">      name: <span class="string">&#x27;&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h1 id="Vue的组件化"><a href="#Vue的组件化" class="headerlink" title="Vue的组件化"></a><font color="red">Vue的组件化</font></h1><h2 id="组件化的基本使用"><a href="#组件化的基本使用" class="headerlink" title="组件化的基本使用"></a>组件化的基本使用</h2><p><font color="Cyan"><strong>组件化思想：</strong></font>（提高复用性，降低耦合性）<br>将一个页面拆分成一个一个的小功能块（每个功能块又可以向下继续查分更小的功能块。最终将其抽象成一个组件树），每个功能块完成属于自己这部分独立的功能，那么之后整个页面的管理和维护就会变得很容易。</p>
<p>组件使用步骤：</p>
<ul>
<li><p>创建组件构造器对象</p>
<p>使用Vue的extend方法创建组件构造器对象，该方法需要传入一个对象作为参数，对象中有一个template(模板)属性，该属性的属性值为字符串，用来存储html的模板。</p>
</li>
<li><p>注册组件</p>
<p>使用Vue的component(组件)方法注册组件，该方法传入两个值。第一个为使用组件时的标签名，第二个为对应的构造器对象。<font color="deeppink">（通过该方式注册的组件为全局组件）</font></p>
</li>
<li><p>使用组件</p>
<p>在html中直接使用注册组件时的标签名即可使用该组件（注意必须放在vue控制的范围内才会生效）</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span> </span><br><span class="line"><span class="javascript">  <span class="comment">//1.创建组件构造器对象 </span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnC = Vue.extend(&#123;</span></span><br><span class="line">    template:`</span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,哈哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="comment">// 2.注册组件</span></span></span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;my_con&#x27;</span>,cpnC)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a>全局组件和局部组件</h3><ul>
<li><p>全局组件    (即可以在任何一个vue的实例中使用)</p>
<p>使用Vue的component(组件)方法注册组件就是全局组件</p>
</li>
<li><p><font color="blue">局部组件</font>    (仅可以再对应的vue实例中使用)</p>
<p>在vue实例中的components属性中注册的组件就是局部组件,仅能在这个vue实例控制的DOM元素中使用</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">con</span>&gt;</span><span class="tag">&lt;/<span class="name">con</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">con</span>&gt;</span><span class="tag">&lt;/<span class="name">con</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app1&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">con</span>&gt;</span><span class="tag">&lt;/<span class="name">con</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">con</span>&gt;</span><span class="tag">&lt;/<span class="name">con</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">my_con</span>&gt;</span><span class="tag">&lt;/<span class="name">my_con</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">con</span>&gt;</span><span class="tag">&lt;/<span class="name">con</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span> </span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnC = Vue.extend(&#123;</span></span><br><span class="line">    template:`</span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,哈哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn1C = Vue.extend(&#123;</span></span><br><span class="line">    template:`</span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;my_con&#x27;</span>,cpnC)</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      con:cpn1C</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app1 = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app1&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="注册组件语法糖"><a href="#注册组件语法糖" class="headerlink" title="注册组件语法糖"></a>注册组件语法糖</h3><p>省略了创建组件构造器对象的步骤，而将其直接写入注册组件中。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">Vue.component(&#x27;my_con&#x27;,&#123;</span><br><span class="line">  template:`</span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  `</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">const app = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;你好&#x27;</span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    con:&#123;</span><br><span class="line">      template:`</span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      `</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">const app1 = new Vue(&#123;</span><br><span class="line">  el: &#x27;#app1&#x27;,</span><br><span class="line">  data: &#123;</span><br><span class="line">    message: &#x27;你好&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="组件模板抽离"><a href="#组件模板抽离" class="headerlink" title="组件模板抽离"></a>组件模板抽离</h2><p>两种方式：</p>
<ul>
<li>使用script标签引入,类型必须是text/x-template</li>
<li>使用template标签</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 1.使用script标签引入,类型必须是text/x-template --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/x-template&#x27;</span> <span class="attr">id</span>=<span class="string">&quot;template1&quot;</span>&gt;</span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是template1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">  <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是template1内容,哈哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2.使用template标签 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;template2&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是template2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是template2内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span> </span><br><span class="line"><span class="javascript">Vue.component(<span class="string">&#x27;cpn1&#x27;</span>,&#123;</span></span><br><span class="line"><span class="javascript">  template: <span class="string">&#x27;#template1&#x27;</span></span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  components:&#123;</span><br><span class="line"><span class="javascript">    <span class="string">&#x27;cpn2&#x27;</span>:&#123;</span></span><br><span class="line"><span class="javascript">      template: <span class="string">&#x27;#template2&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="组件中的数据存储问题"><a href="#组件中的数据存储问题" class="headerlink" title="组件中的数据存储问题"></a><font color="red">组件中的数据存储问题</font></h2><p>首先组件无法访问vue实例的data数据，就算可以也不建议，这样会让vue实例存储内容过多。耦合性增强。</p>
<p>数据应该存储在组件构造器对象中（这个对象与vue实例对象很相似，可以存储data，methods等等）当将数据存储到组件构造器对象的data中时不能以对象的形式存入，要以函数其函数返回对象的形式存入。</p>
<p><strong><font color="red">为什么组件中数据存储时必须存入一个函数且函数返回一个对象：</font></strong></p>
<p>​        因为组件是会被多次使用的，如果直接存入对象（虽然会报错），这些组件实例多次使用这个组件时，当一个组件实例使用组件内对这个数据进行修改时，其他的组件实例中的数据内容也会随之更改。<br>​        当数据被存入到一个函数且函数返回一个对象时，每个组件实例中的数据对象是不同的，其中一个更改数据，对其他组件实例没有影响。</p>
<p>当写成下列方式会出现修改其中一个数据，其他组件实例数据跟随改变。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--组件实例对象--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>当前计数: &#123;&#123;counter&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;increment&quot;</span>&gt;</span>+<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;decrement&quot;</span>&gt;</span>-<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../js/vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="comment">// 1.注册组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> obj = &#123;</span></span><br><span class="line">    counter: 0</span><br><span class="line">  &#125;</span><br><span class="line"><span class="javascript">  Vue.component(<span class="string">&#x27;cpn&#x27;</span>, &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="comment">// data() &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   return &#123;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//     counter: 0</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">//   &#125;</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// &#125;,</span></span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> obj</span></span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">increment</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.counter++</span></span><br><span class="line">      &#125;,</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">decrement</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.counter--</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="父组件与子组件"><a href="#父组件与子组件" class="headerlink" title="父组件与子组件"></a>父组件与子组件</h2><p>父子组件即，在一个组件中的components属性中注册了另一个组件。此时后者便是前者的子组件。</p>
<p>如果想要在#app中使用cpn1组件,那么这个组件要么是全局组件,要么在管理app的vue实例中定义过局部组件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn2</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn2</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span> </span><br><span class="line"><span class="javascript">  <span class="comment">// 子组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnC1 = Vue.extend(&#123;</span></span><br><span class="line">    template:`</span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题1<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,哈哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="comment">// 父组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpnC2 = Vue.extend(&#123;</span></span><br><span class="line">    template:`</span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是标题2<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是内容,呵呵呵呵呵<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">      <span class="tag">&lt;<span class="name">cpn1</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn1</span>&gt;</span></span></span></span><br><span class="line"><span class="handlebars"><span class="xml">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span></span><br><span class="line">    `,</span><br><span class="line">    components:&#123;</span><br><span class="line">      cpn1:cpnC1</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="javascript">  <span class="comment">// root(根组件)</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components:&#123;</span><br><span class="line">      cpn2:cpnC2</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="父子组件的通信-数据"><a href="#父子组件的通信-数据" class="headerlink" title="父子组件的通信(数据)"></a><font color="red">父子组件的通信</font>(数据)</h3><p>​        首先子组件是不能引用父组件或vue实例的数据的<br>在开发时通常是将网络请求的任务交给最外边的大组件(降低发送请求次数,降低服务器网络负担，这时候就需要将请求到的数据从父组件传递给子组件。</p>
<p>通信方式：</p>
<ul>
<li><p>通过props（properties属性）向子组件传递数据</p>
<p>首先在子组件的组件构造器对象中添加props属性，其属性值为一个数组(不常用)或一个对象，然后在使用组件时用v-bind绑定子组件数据与父组件数据的对应关系。此时就可在模板中使用这些数据了。</p>
<p>注意：</p>
<ol>
<li>props的属性值为数组时，数组中每一项都要加引号，但他们表示的是变量</li>
<li>在使用组件时<font color="red">必须用v-bind绑定</font>否则会将其等号右侧的当做一个字符串而不是变量。</li>
<li>props中的<font color="blue">驼峰标示</font>时，当在使用该组件时，标签属性中使用时应该讲驼峰标示转换为以-连接的语法（例如：cMessage变成c-message）其中得原因是html没有大小写的概念。</li>
</ol>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>  <span class="attr">:c-message</span>=<span class="string">&quot;message&quot;</span> <span class="attr">:c-movies</span>=<span class="string">&quot;movies&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in cMovies&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;&#123;cMessage&#125;&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="comment">// 父传子:props</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">  template:<span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">  <span class="comment">// props: [&#x27;cmovies&#x27;,&#x27;cmessage&#x27;],</span></span></span><br><span class="line">  props: &#123;</span><br><span class="line"><span class="javascript">    <span class="comment">// cmovies: Array,		//类型的限制</span></span></span><br><span class="line"><span class="javascript">    <span class="comment">// cmassage: String,	</span></span></span><br><span class="line">    cMessage: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">String</span>,       <span class="comment">//类型限制</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="string">&#x27;aaaaa&#x27;</span>,   <span class="comment">//默认值</span></span></span><br><span class="line"><span class="javascript">      required: <span class="literal">true</span>      <span class="comment">//是否是必传值</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    cMovies: &#123;</span><br><span class="line"><span class="javascript">      type: <span class="built_in">Array</span>,</span></span><br><span class="line"><span class="javascript">      <span class="comment">// default: [],     //这样写会报错,数组和对象默认值直接写会报错,提示使用工厂函数返回一个对象或数组</span></span></span><br><span class="line"><span class="javascript">      <span class="keyword">default</span>: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> []</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    movies: [<span class="string">&#x27;海王&#x27;</span>,<span class="string">&#x27;海贼王&#x27;</span>,<span class="string">&#x27;海尔兄弟&#x27;</span>]</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components:&#123;</span><br><span class="line">    cpn</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<ul>
<li><p>通过自定义事件向父组件发送消息</p>
<p>​        一般都是子组件触发了什么事件，此时子组件将触发事件的消息传递给父组件</p>
<p>​        首先在子组件的模板绑定的事件被触发，在这个触发事件的回调函数中使用this.$emit（发射）方法向父组件传递信息，这个方法需要传递进两个参数，第一个是自定义事件的名称（字符串），后边的参数是想要传递给父组件的信息。然后在父组件的模板中监听子组件的自定义事件，在父组件中处理这个自定义事件。</p>
</li>
</ul>
<p>注意：</p>
<ol>
<li>在父组件模板中监听子组件的自定义事件时不用定义参数，这时<font color="blue">不会像往常一样给回调函数传入event，而是传入子组件的后续参数。</font></li>
<li>驼峰标示问题</li>
</ol>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!--父组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 在这里不写参数不会像之前给函数传入event而会传入子组件的后续参数 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> @<span class="attr">item-click</span>=<span class="string">&quot;cpnClick&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--子组件模板--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">v-for</span>=<span class="string">&quot;item in categories&quot;</span></span></span><br><span class="line"><span class="tag">            @<span class="attr">click</span>=<span class="string">&quot;btnClick(item)&quot;</span>&gt;</span></span><br><span class="line">      &#123;&#123;item.name&#125;&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 1.子组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> cpn = &#123;</span></span><br><span class="line"><span class="javascript">    template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line">        categories: [</span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;aaa&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;热门推荐&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;bbb&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;手机数码&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;ccc&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;家用家电&#x27;</span>&#125;,</span></span><br><span class="line"><span class="javascript">          &#123;<span class="attr">id</span>: <span class="string">&#x27;ddd&#x27;</span>, <span class="attr">name</span>: <span class="string">&#x27;电脑办公&#x27;</span>&#125;,</span></span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">btnClick</span>(<span class="params">item</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="comment">// 发射事件: 自定义事件</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.$emit(<span class="string">&#x27;item-click&#x27;</span>, item)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">  <span class="comment">// 2.父组件</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn</span><br><span class="line">    &#125;,</span><br><span class="line">    methods: &#123;</span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">cpnClick</span>(<span class="params">item</span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">console</span>.log(<span class="string">&#x27;cpnClick&#x27;</span>, item);</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="父子组件访问-方法"><a href="#父子组件访问-方法" class="headerlink" title="父子组件访问(方法)"></a>父子组件访问(方法)</h3><h4 id="父组件访问子组件"><a href="#父组件访问子组件" class="headerlink" title="父组件访问子组件"></a>父组件访问子组件</h4><p>使用$children或者$refs（reference引用）</p>
<ul>
<li><p>$children（这个属性<strong>不建议使用</strong>，因为他是通过下标取得对应的子组件，当组件个数发生更改就会导致出现问题。）</p>
<p>在父组件中使用该属性时返回的是一个<font color="red">数组</font>，数组中存储的是所有的子组。通过下标来获得对应子组件的使用权。</p>
</li>
<li><p>$refs (reference)</p>
<p>使用时先在父组件中使用该属性时返回的是一个<font color="red">对象</font>，中存储的是所有的子组。通过下标来获得对应子组件的使用权。</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span> <span class="attr">ref</span>=<span class="string">&quot;aaa&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span>我是子组件<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line">  &#125;,</span><br><span class="line">  methods: &#123;</span><br><span class="line"><span class="javascript">    <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="comment">// 1.使用$children  数组类型</span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// console.log(this.$children) </span></span></span><br><span class="line"><span class="javascript">      <span class="comment">// this.$children[0].showMessage()</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">      <span class="comment">// 2.使用$refs  对象类型</span></span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs)</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="built_in">this</span>.$refs.aaa.name)</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    cpn: &#123;</span><br><span class="line"><span class="javascript">      template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          name: <span class="string">&#x27;我是子组件的name&#x27;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      methods: &#123;</span><br><span class="line">        showMessage () &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">console</span>.log(<span class="string">&#x27;showMessage()&#x27;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h4 id="子组件访问父组件"><a href="#子组件访问父组件" class="headerlink" title="子组件访问父组件"></a>子组件访问父组件</h4><p>使用$parent以及$root</p>
<ul>
<li><p>$parent    (不建议使用因为会加强子组件对父组件的依赖,使耦合性增强,复用性降低)</p>
</li>
<li><p>$root</p>
<p>访问到的是顶层的Vue实例对象</p>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是cpn组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">ccpn</span>&gt;</span><span class="tag">&lt;/<span class="name">ccpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;ccpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是子组件ccpn<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> @<span class="attr">click</span>=<span class="string">&quot;btnClick&quot;</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../js/vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    message: <span class="string">&#x27;你好&#x27;</span>,</span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    cpn: &#123;</span><br><span class="line"><span class="javascript">      template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">      <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">          name: <span class="string">&quot;我是cpn组件的name&quot;</span></span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">      components: &#123;</span><br><span class="line">        ccpn: &#123;</span><br><span class="line"><span class="javascript">          template: <span class="string">&#x27;#ccpn&#x27;</span>,</span></span><br><span class="line">          methods: &#123;</span><br><span class="line"><span class="javascript">            <span class="function"><span class="title">btnClick</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">              <span class="comment">// 1.访问父组件的$parent</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent)       <span class="comment">//VueComponent对象</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.$parent.name)</span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.$root)         <span class="comment">//顶层Vue实例对象</span></span></span><br><span class="line"><span class="javascript">              <span class="built_in">console</span>.log(<span class="built_in">this</span>.$root.message)</span></span><br><span class="line">            &#125;</span><br><span class="line">          &#125;,</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h2 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a><font color="red">插槽slot</font></h2><p>插槽的特点：</p>
<ul>
<li><font color="red">为了让封装的组件更加具有扩展性。</font></li>
<li><font color="red">让使用者可以决定组件内部的一些内容到底展示什么。</font></li>
</ul>
<p>使用插槽的原则：抽取共性，保留不同。</p>
<h3 id="基本使用-2"><a href="#基本使用-2" class="headerlink" title="基本使用"></a>基本使用</h3><ul>
<li>插槽的基本使用：在模板中使用&lt;slot&gt;&lt;/slot&gt;</li>
<li>插槽的默认值：在使用插槽时向该插槽中写入的就是该插槽的默认值，在使用组件时不像组件中添加内容就会使用该插槽的默认值</li>
<li>如果有多个值同时被放入组件进行替换时会全部替换</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>哈哈哈<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">i</span>&gt;</span>hehehe<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h2</span>&gt;</span>我是组件<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">p</span>&gt;</span>我是组件,哈哈哈哈<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span>&gt;</span><span class="tag">&lt;<span class="name">button</span>&gt;</span>按钮<span class="tag">&lt;/<span class="name">button</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    cpn: &#123;</span><br><span class="line"><span class="javascript">      template: <span class="string">&#x27;#cpn&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="具名插槽"><a href="#具名插槽" class="headerlink" title="具名插槽"></a>具名插槽</h3><p>当在使用组件时如果该组件没有设置插槽，此时在组件内写的HTML内容会被组件直接替换。如果设置的插槽（无名），此时没有指定插槽的HTML内容会将其替换后再加入DOM，如果设置的插槽（有名），此时将对应指定插槽的HTML内容会将其替换后再加入DOM。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&#x27;app&#x27;</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span>搜索栏<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;left&quot;</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;left&quot;</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">slot</span>=<span class="string">&quot;center&quot;</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="comment">&lt;!-- 2.6之后的新写法及其简写(必须用template包裹) --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">v-slot:left</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>返回<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">center</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>标题<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;left&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>左边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;center&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>中间<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&quot;rigth&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>右边<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span> <span class="attr">src</span>=<span class="string">&#x27;../vue.js&#x27;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">&#x27;text/javascript&#x27;</span>&gt;</span></span><br><span class="line"><span class="javascript"><span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">  el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">  data: &#123;</span><br><span class="line"><span class="javascript">    message: <span class="string">&#x27;你好&#x27;</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  components: &#123;</span><br><span class="line">    cpn: &#123;</span><br><span class="line"><span class="javascript">      template: <span class="string">&#x27;#cpn&#x27;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>


<h3 id="编译作用域以及作用域插槽"><a href="#编译作用域以及作用域插槽" class="headerlink" title="编译作用域以及作用域插槽"></a>编译作用域以及作用域插槽</h3><p>改变了父子组件数据的通信</p>
<p><font color="red">父组件模板的内容在父组件作用域编译，子组件模板的内容在子组件作用域编译</font></p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;app&quot;</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span><span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!-- 旧写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--目的是获取子组件中的pLanguages--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">slot</span>=<span class="string">&quot;a&quot;</span> <span class="attr">slot-scope</span>=<span class="string">&quot;slot&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!--&lt;span v-for=&quot;item in slot.data&quot;&gt;&#123;&#123;item&#125;&#125; * &lt;/span&gt;--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">span</span>&gt;</span>&#123;&#123;slot.data.join(&#x27; * &#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- 新写法 --&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">cpn</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--目的是获取子组件中的pLanguages--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">template</span> #<span class="attr">a</span>=<span class="string">&quot;slotProps&quot;</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 将包含所有插槽 prop 的对象命名为 slotProps --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;slotProps&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- 这里注意大小写HTML没有大写只认识小写 --&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">div</span>&gt;</span>&#123;&#123;slotProps.data.join(&#x27; * &#x27;)&#125;&#125;<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">cpn</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span> <span class="attr">id</span>=<span class="string">&quot;cpn&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 把pLanguages数组改名为data绑定传输过去 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">slot</span> <span class="attr">name</span>=<span class="string">&#x27;a&#x27;</span> <span class="attr">:data</span>=<span class="string">&quot;pLanguages&quot;</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">li</span> <span class="attr">v-for</span>=<span class="string">&quot;item in pLanguages&quot;</span>&gt;</span>&#123;&#123;item&#125;&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">slot</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;../vue.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">const</span> app = <span class="keyword">new</span> Vue(&#123;</span></span><br><span class="line"><span class="javascript">    el: <span class="string">&#x27;#app&#x27;</span>,</span></span><br><span class="line">    data: &#123;</span><br><span class="line"><span class="javascript">      message: <span class="string">&#x27;你好啊&#x27;</span></span></span><br><span class="line">    &#125;,</span><br><span class="line">    components: &#123;</span><br><span class="line">      cpn: &#123;</span><br><span class="line"><span class="javascript">        template: <span class="string">&#x27;#cpn&#x27;</span>,</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="title">data</span>(<span class="params"></span>)</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="javascript">            pLanguages: [<span class="string">&#x27;JavaScript&#x27;</span>, <span class="string">&#x27;C++&#x27;</span>, <span class="string">&#x27;Java&#x27;</span>, <span class="string">&#x27;C#&#x27;</span>, <span class="string">&#x27;Python&#x27;</span>, <span class="string">&#x27;Go&#x27;</span>, <span class="string">&#x27;Swift&#x27;</span>]</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>




<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV15741177Eh">coderwhy讲解Vue</a></p>
]]></content>
      <categories>
        <category>Vue</category>
        <category>笔记</category>
      </categories>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
</search>
